<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Property Listings</title>
  
  <!-- HubSpot Tracking Code -->
  <script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/24160521.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap">
  <!-- Mapbox GL JS for map integration -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-color: #bf9959;
      --secondary-color: #ff6b4a;
      --accent-color: #009688;
      --accent-light: #b2dfdb;
      --accent-dark: #134F5C;
      --light-bg: #ffffff;
      --white: #ffffff;
      --dark-text: #1e293b;
      --medium-text: #334155;
      --light-text: #64748b;
      --border-color: #e2e8f0;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.07), 0 1px 3px rgba(0,0,0,0.08);
      --shadow-lg: 0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05);
      --transition-normal: all 0.3s ease;
      --transition-fast: all 0.2s ease;
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
    }
    
    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      color: var(--dark-text);
      line-height: 1.6;
      background-color: var(--light-bg);
      font-size: 16px;
    }
    
    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: var(--spacing-xl) var(--spacing-md);
    }
    
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Montserrat', sans-serif;
      color: var(--dark-text);
      font-weight: 600;
      line-height: 1.3;
    }
    
    a {
      color: var(--primary-color);
      text-decoration: none;
      transition: var(--transition-fast);
    }
    
    a:hover {
      color: var(--accent-color);
    }
    
    button {
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
    }
    
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
    
    /* Header and Castle Group branding */
    .cg-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-logo {
      width: 240px;
      height: auto;
      max-width: 100%;
    }
    
    .cg-tagline {
      font-family: 'Montserrat', sans-serif;
      font-size: 14px;
      color: var(--light-text);
      font-style: italic;
    }
    
    .cg-page-title {
      font-size: 2.5rem;
      margin-bottom: var(--spacing-lg);
      color: var(--primary-color);
    }
    
    .cg-section-title {
      font-size: 1.25rem;
      margin-bottom: var(--spacing-md);
      color: var(--dark-text);
    }
    
    /* Top search bar and filters */
    .cg-search-wrapper {
      position: sticky;
      top: 0;
      z-index: 100;
      background-color: var(--white);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
      transition: var(--transition-normal);
    }
    
    .cg-search-sticky {
      box-shadow: var(--shadow-lg);
    }
    
    .cg-quick-search {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    .cg-search-input-wrapper {
      position: relative;
      flex-grow: 1;
    }
    
    .cg-search-input {
      width: 100%;
      padding: 12px 16px 12px 42px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      font-size: 16px;
      transition: var(--transition-fast);
    }
    
    .cg-search-input:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--light-text);
      pointer-events: none;
    }
    
    .cg-search-btn {
      background-color: var(--secondary-color);
      color: var(--white);
      border: none;
      border-radius: var(--radius-md);
      padding: 12px 24px;
      font-weight: 500;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      transition: var(--transition-fast);
    }
    
    .cg-search-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-quick-filters {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-md);
    }
    
    .cg-quick-filter {
      background-color: var(--white);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 6px 16px;
      font-size: 14px;
      font-weight: 500;
      color: var(--medium-text);
      transition: var(--transition-fast);
    }
    
    .cg-quick-filter:hover {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-quick-filter.active,
    button.cg-quick-filter.active {
      background-color: var(--accent-color) !important;
      border-color: var(--accent-color) !important;
      color: var(--white) !important;
      font-weight: 600 !important;
      box-shadow: var(--shadow-sm) !important;
    }
    
    /* Filter panel */
    .cg-filter-panel {
      background-color: var(--white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-filter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-filter-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--dark-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-filter-toggle {
      background: none;
      border: none;
      color: var(--accent-color);
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      transition: var(--transition-fast);
    }
    
    .cg-filter-toggle:hover {
      color: var(--accent-dark);
    }
    
    .cg-filter-toggle.active {
      color: var(--accent-dark);
      background-color: var(--accent-light);
      padding: 6px 12px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
    }
    
    .cg-filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--spacing-lg);
    }
    
    .cg-filter-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }
    
    .cg-filter-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    .cg-filter-select {
      appearance: none;
      background-color: var(--white);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 10px 36px 10px 16px;
      font-size: 16px;
      color: var(--dark-text);
      transition: var(--transition-fast);
      width: 100%;
    }
    
    .cg-filter-select:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-filter-buttons {
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      margin-top: var(--spacing-xl);
    }
    
    .cg-btn-clear {
      background-color: var(--light-bg);
      color: var(--medium-text);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-btn-clear:hover {
      background-color: var(--border-color);
    }
    
    .cg-btn-apply {
      background-color: var(--primary-color);
      color: var(--white);
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-btn-apply:hover {
      background-color: var(--accent-color);
    }
    
    /* Active Filters */
    .cg-active-filters {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-lg);
    }
    
    .cg-filter-pill {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--accent-light);
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 500;
      color: var(--accent-dark);
      transition: var(--transition-fast);
      cursor: pointer;
    }
    
    .cg-filter-pill.active,
    .cg-filter-pill.selected,
    div.cg-filter-pill.active {
      background-color: var(--accent-color) !important;
      color: var(--white) !important;
      box-shadow: var(--shadow-sm) !important;
      border-color: var(--accent-color) !important;
    }
    
    .cg-filter-pill-label {
      font-weight: 600;
      margin-right: 4px;
    }
    
    .cg-filter-pill-remove {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background-color: var(--accent-dark);
      color: var(--white);
      border-radius: 50%;
      font-size: 10px;
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-filter-pill-remove:hover {
      background-color: var(--dark-text);
    }
    
    /* View toggle and sorting */
    .cg-view-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-view-toggle {
      display: flex;
      gap: 1px;
      background-color: var(--border-color);
      border-radius: var(--radius-md);
      padding: 2px;
    }
    
    .cg-view-btn {
      background: none;
      border: none;
      padding: 8px 16px;
      font-size: 15px;
      font-weight: 500;
      color: var(--medium-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      border-radius: var(--radius-sm);
      transition: var(--transition-fast);
    }
    
    .cg-view-btn.active {
      background-color: var(--white);
      color: var(--primary-color);
      box-shadow: var(--shadow-sm);
    }
    
    .cg-sort-controls {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }
    
    .cg-sort-label {
      font-size: 15px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    .cg-sort-select {
      appearance: none;
      background-color: var(--white);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 8px 36px 8px 16px;
      font-size: 15px;
      color: var(--dark-text);
      min-width: 180px;
      transition: var(--transition-fast);
    }
    
    .cg-sort-select:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-sort-direction {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--white);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 8px 16px;
      font-size: 15px;
      color: var(--medium-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-sort-direction:hover {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-sort-direction i {
      color: var(--accent-color);
    }
    
    /* Property Grid */
    .cg-properties-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
    }
    
    /* Property Card */
    .cg-property-card {
      background-color: var(--white);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      transition: var(--transition-normal);
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    
    .cg-property-card:hover {
      transform: translateY(-8px);
      box-shadow: var(--shadow-lg);
    }
    
    .cg-property-link {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      text-decoration: none;
      color: inherit;
    }
    
    .cg-property-header {
      padding: var(--spacing-md);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    }
    
    .cg-property-status {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .cg-status-available {
      background-color: #10b981;
      color: white;
    }
    
    .cg-status-under-offer {
      background-color: #f59e0b;
      color: white;
    }
    
    .cg-status-hold {
      background-color: #fbbf24;
      color: #1e293b;
    }
    
    .cg-status-exclusive {
      background-color: #8b5cf6;
      color: white;
    }
    
    .cg-property-price {
      font-size: 18px;
      font-weight: 700;
      color: var(--dark-text);
    }
    
    .cg-property-content {
      padding: var(--spacing-lg);
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    
    .cg-property-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: var(--spacing-sm);
      color: var(--primary-color);
    }
    
    .cg-property-location {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      color: var(--medium-text);
      font-size: 15px;
    }
    
    .cg-property-location i {
      color: var(--accent-color);
    }
    
    .cg-property-meta {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      font-size: 14px;
      color: var(--medium-text);
    }
    
    .cg-meta-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-meta-item i {
      color: var(--accent-color);
      width: 16px;
      text-align: center;
    }
    
    .cg-meta-label {
      font-weight: 500;
      margin-right: 4px;
    }
    
    .cg-registration-date {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      padding: 6px 12px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      background-color: #e6fffa;
      color: #0d9488;
    }
    
    .cg-title-type-badge {
      position: absolute;
      top: 60px;
      right: 0;
      background-color: var(--secondary-color);
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 4px 12px;
      border-top-left-radius: var(--radius-md);
      border-bottom-left-radius: var(--radius-md);
      z-index: 2;
    }
    
    .cg-new-badge {
      position: absolute;
      top: 16px;
      right: 16px;
      background-color: #10b981;
      color: white;
      font-size: 12px;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 16px;
      z-index: 2;
    }
    
    .cg-property-specs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-md);
      padding: var(--spacing-md) 0;
      margin: var(--spacing-md) 0;
      border-top: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-spec-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    
    .cg-spec-icon {
      color: var(--accent-color);
      margin-bottom: 4px;
      font-size: 20px;
    }
    
    .cg-spec-value {
      font-weight: 600;
      font-size: 18px;
      color: var(--dark-text);
      margin-bottom: 2px;
    }
    
    .cg-spec-label {
      font-size: 13px;
      color: var(--light-text);
    }
    
    .cg-property-details {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-detail-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 14px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-detail-row:last-child {
      border-bottom: none;
    }
    
    .cg-detail-label {
      font-weight: 500;
      color: var(--light-text);
    }
    
    .cg-detail-value {
      font-weight: 600;
      color: var(--dark-text);
    }
    
    .cg-property-cta {
      margin-top: auto;
      background-color: var(--primary-color);
      color: white;
      text-align: center;
      padding: 12px;
      border-radius: var(--radius-md);
      font-weight: 600;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .cg-property-cta:hover {
      background-color: var(--accent-color);
    }
    
    .cg-lot-size-badge {
      display: inline-block;
      padding: 4px 8px;
      background-color: #e6fffa;
      color: #0d9488;
      border-radius: var(--radius-sm);
      font-size: 12px;
      font-weight: 600;
      margin-top: 6px;
    }
    
    .cg-zoning-info {
      margin-top: var(--spacing-md);
      padding: var(--spacing-md);
      background-color: #f0f9ff;
      border-radius: var(--radius-md);
      font-size: 14px;
    }
    
    .cg-school-zone {
      display: inline-block;
      margin-top: 5px;
      padding: 3px 8px;
      background-color: #dbeafe;
      color: #3b82f6;
      border-radius: var(--radius-sm);
      font-size: 12px;
    }
    
    /* Map View */
    .cg-map-container {
      position: relative;
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-property-map {
      height: 650px;
      width: 100%;
    }
    
    .cg-map-controls {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .cg-map-btn {
      background-color: white;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      font-size: 14px;
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-map-btn:hover {
      background-color: var(--light-bg);
    }
    
    .cg-map-btn.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }
    
    .cg-map-preview {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 320px;
      background-color: white;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      z-index: 10;
      overflow: hidden;
      transform: translateY(0);
      transition: transform 0.3s ease;
    }
    
    .cg-preview-hidden {
      transform: translateY(calc(100% + 24px));
    }
    
    .cg-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background-color: var(--light-bg);
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-preview-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--dark-text);
      margin: 0;
    }
    
    .cg-preview-close {
      background: none;
      border: none;
      font-size: 20px;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-preview-close:hover {
      color: var(--dark-text);
    }
    
    .cg-preview-content {
      padding: 16px;
    }
    
    .cg-preview-status {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    
    .cg-preview-price {
      font-size: 20px;
      font-weight: 700;
      color: var(--dark-text);
      margin-bottom: 12px;
    }
    
    .cg-preview-details {
      font-size: 14px;
      color: var(--medium-text);
      margin-bottom: 16px;
    }
    
    .cg-preview-zoning {
      padding: 12px;
      background-color: #f0f9ff;
      border-radius: var(--radius-md);
      font-size: 13px;
      color: var(--medium-text);
      margin-bottom: 16px;
    }
    
    .cg-preview-btn {
      width: 100%;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 12px;
      font-size: 15px;
      font-weight: 600;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .cg-preview-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-map-marker {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    
    .cg-map-marker:hover, .cg-map-marker.active {
      transform: scale(1.3);
      box-shadow: 0 3px 6px rgba(0,0,0,0.4);
      z-index: 10 !important;
    }
    
    .cg-marker-available {
      background-color: #10b981;
    }
    
    .cg-marker-under-offer {
      background-color: #f59e0b;
    }
    
    .cg-marker-hold {
      background-color: #fbbf24;
    }
    
    .cg-marker-exclusive {
      background-color: #8b5cf6;
    }
    
    .cg-map-disclaimer {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 12px;
      max-width: 300px;
      z-index: 5;
      box-shadow: var(--shadow-sm);
      color: var(--medium-text);
    }
    
    .mapboxgl-popup-content {
      padding: 0;
      border-radius: var(--radius-md);
      overflow: hidden;
      box-shadow: var(--shadow-lg);
    }
    
    .mapboxgl-popup-close-button {
      font-size: 18px;
      color: var(--light-text);
      padding: 6px;
      right: 6px;
      top: 6px;
    }
    
    .cg-popup-content {
      padding: 12px;
    }
    
    .cg-popup-title {
      font-weight: 600;
      margin-bottom: 5px;
      color: var(--dark-text);
      font-size: 14px;
    }
    
    .cg-popup-price {
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 8px;
      font-size: 15px;
    }
    
    .cg-popup-details {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--medium-text);
    }
    
    .cg-popup-status {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 10px;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    
    /* Loading State */
    .cg-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 0;
      text-align: center;
    }
    
    .cg-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(0, 150, 136, 0.2);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      animation: cg-spin 1s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes cg-spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    .cg-loading-text {
      font-size: 18px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    /* Skeleton loading */
    .cg-skeleton {
      background-color: #e2e5e7;
      background-image: 
        linear-gradient(
          90deg, 
          rgba(255, 255, 255, 0), 
          rgba(255, 255, 255, 0.5),
          rgba(255, 255, 255, 0)
        );
      background-size: 200px 100%;
      background-repeat: no-repeat;
      background-position: left -40px top 0;
      animation: cg-shine 1.5s ease infinite;
      border-radius: var(--radius-sm);
    }
    
    @keyframes cg-shine {
      to {
        background-position: right -40px top 0;
      }
    }
    
    /* Error and No Results */
    .cg-error-container, .cg-no-results {
      text-align: center;
      padding: 40px 24px;
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-error-container {
      background-color: #fee2e2;
      border: 1px solid #fecaca;
    }
    
    .cg-no-results {
      background-color: var(--light-bg);
      border: 1px solid var(--border-color);
    }
    
    .cg-error-title, .cg-no-results-title {
      font-size: 24px;
      margin-bottom: var(--spacing-md);
    }
    
    .cg-error-title {
      color: #dc2626;
    }
    
    .cg-error-message, .cg-no-results-message {
      font-size: 16px;
      margin-bottom: var(--spacing-lg);
      color: var(--medium-text);
    }
    
    .cg-error-buttons {
      display: flex;
      justify-content: center;
      gap: var(--spacing-md);
    }
    
    .cg-error-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 16px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-error-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-error-btn.secondary {
      background-color: white;
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
    }
    
    .cg-error-btn.secondary:hover {
      background-color: var(--light-bg);
    }
    
    /* Pagination */
    .cg-pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--spacing-sm);
      margin: var(--spacing-xl) 0;
    }
    
    .cg-pagination-btn {
      min-width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border-color);
      background-color: white;
      color: var(--medium-text);
      border-radius: var(--radius-md);
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-pagination-btn:hover:not(:disabled) {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .cg-pagination-btn.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }
    
    .cg-pagination-ellipsis {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 40px;
      padding: 0 12px;
      color: var(--medium-text);
      font-weight: 500;
    }
    
    /* Results Count */
    .cg-results-count {
      margin-top: var(--spacing-md);
      font-size: 14px;
      color: var(--medium-text);
      text-align: center;
    }
    
    /* Sample Data Notice */
    .cg-sample-data-notice {
      background-color: var(--accent-light);
      border: 1px solid #b2dfdb;
      color: var(--accent-dark);
      padding: 12px 16px;
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-sample-data-notice i {
      font-size: 18px;
    }
    
    /* Quick View Modal */
    .cg-quick-view-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .cg-quick-view-modal.active {
      opacity: 1;
      visibility: visible;
    }
    
    .cg-modal-content {
      background-color: white;
      border-radius: var(--radius-lg);
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
      transform: translateY(20px);
      transition: transform 0.3s ease;
    }
    
    .cg-quick-view-modal.active .cg-modal-content {
      transform: translateY(0);
    }
    
    .cg-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-modal-title {
      font-size: 22px;
      font-weight: 600;
      color: var(--dark-text);
      margin: 0;
    }
    
    .cg-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-modal-close:hover {
      color: var(--dark-text);
    }
    
    .cg-modal-body {
      padding: 24px;
    }
    
    .cg-modal-footer {
      padding: 16px 24px;
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      border-top: 1px solid var(--border-color);
    }
    
    .cg-modal-btn {
      padding: 10px 20px;
      border-radius: var(--radius-md);
      font-size: 16px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-modal-btn.primary {
      background-color: var(--primary-color);
      color: white;
      border: none;
    }
    
    .cg-modal-btn.primary:hover {
      background-color: var(--accent-color);
    }
    
    .cg-modal-btn.secondary {
      background-color: white;
      color: var(--medium-text);
      border: 1px solid var(--border-color);
    }
    
    .cg-modal-btn.secondary:hover {
      background-color: var(--light-bg);
    }
    
    /* Save Favorites Feature */
   /* Update the favorites button position to top-right instead of top-left */
/* Save Favorites Feature - Updated positioning */
.cg-save-favorite {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  right: 16px;
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}
/* Favorites Button Icon Styling */
.cg-save-favorite i {
  color: #d1d5db; /* Light gray for default state */
  font-size: 18px; /* Explicit size definition */
}

.cg-save-favorite:hover i {
  color: var(--primary-color); /* Gold/tan color on hover */
}

.cg-save-favorite.active i {
  color: var(--primary-color); /* Gold/tan for active state */
}

/* Enhanced button styling */
.cg-save-favorite.active {
  background-color: #fff; /* Maintain white background */
  border: 1px solid var(--primary-color); /* Add border in primary color */
}

.cg-save-favorite:hover {
  transform: scale(1.1); /* Subtle scale effect on hover */
  box-shadow: var(--shadow-lg); /* Enhanced shadow on hover */
}
/* Share Feature - Updated positioning */
.cg-share-property {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  right: 60px;
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}

/* Compare Properties badge - Updated positioning */
.cg-compare-badge {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  left: 16px; /* Move to left side */
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}

/* Remove new badge from display */
.cg-new-badge {
  display: none;
}

/* Ensure property header has clear space */
.cg-property-header {
  padding: var(--spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
  position: relative;
  z-index: 4; /* Ensure header is above the badges */
}

/* Make sure price is clearly visible */
.cg-property-price {
  font-size: 18px;
  font-weight: 700;
  color: var(--dark-text);
  position: relative;
  z-index: 6; /* Higher than the badges */
}

/* Ensure property header elements (status, price) don't overlap with title */
.cg-property-header {
  padding: var(--spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
  margin-top: 0; /* Ensure no top margin */
}

/* Remove new badge styles entirely */
.cg-new-badge {
  display: none; /* Hide it completely */
}

/* Add more spacing to property title to prevent overlap */
.cg-property-title {
  font-size: 20px;
  font-weight: 700;
  margin-top: var(--spacing-md); /* Add top margin to push down from header */
  margin-bottom: var(--spacing-sm);
  color: var(--primary-color);
}
    /* Geocoding Status */
    .cg-geocoding-status {
      position: absolute;
      top: 16px;
      left: 16px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      max-width: 300px;
      z-index: 5;
      box-shadow: var(--shadow-sm);
    }
    
    .cg-geocoding-progress {
      margin-top: 8px;
      height: 4px;
      width: 100%;
      background-color: var(--border-color);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .cg-geocoding-bar {
      height: 100%;
      background-color: #10b981;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    /* Compare Properties */
    .cg-compare-badge {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background-color: white;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      z-index: 5;
      transition: var(--transition-fast);
    }
    
    .cg-compare-badge:hover {
      transform: scale(1.1);
    }
    
    .cg-compare-badge i {
      font-size: 18px;
      color: var(--light-text);
      transition: var(--transition-fast);
    }
    
    .cg-compare-badge.active {
      background-color: var(--primary-color);
    }
    
    .cg-compare-badge.active i {
      color: white;
    }
    
    .cg-compare-drawer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
      box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1);
      padding: 16px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 100;
    }
    
    .cg-compare-drawer.active {
      transform: translateY(0);
    }
    
    .cg-compare-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .cg-compare-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--dark-text);
    }
    
    .cg-compare-close {
      background: none;
      border: none;
      font-size: 20px;
      color: var(--light-text);
      cursor: pointer;
    }
    
    .cg-compare-items {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      padding-bottom: 8px;
    }
    
    .cg-compare-item {
      min-width: 200px;
      flex: 0 0 auto;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      overflow: hidden;
      position: relative;
    }
    
    .cg-compare-remove {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
      cursor: pointer;
      font-size: 12px;
      color: var(--light-text);
    }
    
    .cg-compare-details {
      padding: 10px;
    }
    
    .cg-compare-name {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--dark-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .cg-compare-price {
      font-size: 15px;
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 4px;
    }
    
    .cg-compare-specs {
      font-size: 12px;
      color: var(--medium-text);
    }
    
    .cg-compare-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 16px;
    }
    
    .cg-compare-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: var(--transition-fast);
    }
    
    .cg-compare-btn:hover {
      background-color: var(--accent-color);
    }
    
    /* Toast Notifications */
    .cg-toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 320px;
    }
    
    .cg-toast {
      background-color: white;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: cg-toast-in 0.3s ease forwards;
      transform: translateX(100%);
    }
    
    .cg-toast.exit {
      animation: cg-toast-out 0.3s ease forwards;
    }
    
    @keyframes cg-toast-in {
      to {
        transform: translateX(0);
      }
    }
    
    @keyframes cg-toast-out {
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    .cg-toast-icon {
      min-width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
    }
    
    .cg-toast-success .cg-toast-icon {
      background-color: #10b981;
    }
    
    .cg-toast-error .cg-toast-icon {
      background-color: #ef4444;
    }
    
    .cg-toast-warning .cg-toast-icon {
      background-color: #f59e0b;
    }
    
    .cg-toast-info .cg-toast-icon {
      background-color: #3b82f6;
    }
    
    .cg-toast-content {
      flex: 1;
    }
    
    .cg-toast-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
      color: var(--dark-text);
    }
    
    .cg-toast-message {
      font-size: 13px;
      color: var(--medium-text);
    }
    
    .cg-toast-close {
      background: none;
      border: none;
      font-size: 16px;
      color: var(--light-text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 1024px) {
      .cg-properties-grid {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .cg-filter-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      
      .cg-property-map {
        height: 500px;
      }
    }
    
    @media (max-width: 768px) {
      .cg-properties-grid {
        grid-template-columns: 1fr;
      }
      
      .cg-quick-search {
        flex-direction: column;
      }
      
      .cg-view-controls {
        flex-direction: column;
        gap: var(--spacing-md);
        align-items: flex-start;
      }
      
      .cg-filter-grid {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
      }
      
      .cg-property-map {
        height: 400px;
      }
      
      .cg-map-preview {
        width: calc(100% - 48px);
      }
      
      .cg-filter-buttons {
        flex-direction: column;
      }
      
      .cg-pagination {
        flex-wrap: wrap;
      }
    }
    
    @media (max-width: 480px) {
      .cg-container {
        padding: var(--spacing-md) var(--spacing-sm);
      }
      
      .cg-search-wrapper {
        padding: var(--spacing-md) var(--spacing-sm);
      }
      
      .cg-filter-panel {
        padding: var(--spacing-md);
      }
      
      .cg-property-specs {
        gap: var(--spacing-sm);
      }
      
      .cg-spec-value {
        font-size: 16px;
      }
      
      .cg-spec-icon {
        font-size: 18px;
      }
      
      .cg-property-map {
        height: 350px;
      }
      
      .cg-modal-content {
        width: 95%;
      }
    }
  </style>
</head>
  <body>
  <!-- Authentication Overlay -->
  <div id="auth-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255,255,255,0.95); z-index: 9999; display: flex; justify-content: center; align-items: center;">
    <div style="background-color: white; padding: 30px; border-radius: 8px; max-width: 600px; width: 100%; box-shadow: 0 5px 15px rgba(0,0,0,0.1); text-align: center;">
      <h2>Property Listings Access</h2>
      <p>Please register to view our exclusive property listings. Your information will help us provide you with personalized property recommendations.</p>
      
      <!-- HubSpot Form -->
      <iframe 
        id="hubspot-form"
        src="https://share.hsforms.com/1oA8fZxSQRKelcRQtpTdzgwedudl?cg_needs_verification=Yes" 
        width="100%" 
        height="500px" 
        style="border: none;">
      </iframe>
      
      <!-- Confirmation Message (initially hidden) -->
      <div id="confirmation-message" style="display: none; background-color: #f1f9f1; border: 1px solid #dff0d8; padding: 15px; border-radius: 4px; margin-top: 20px;">
        <h3 style="color: #3c763d; margin-top: 0;">Thank you for getting in touch!</h3>
        <p style="color: #3c763d;">We appreciate your enquiry.</p>
        <p style="color: #3c763d;">One of our sales team will be in touch shortly. <strong>Please check your inbox for a verification link to access the listings.</strong></p>
        <p style="color: #3c763d; font-style: italic;">The verification email may take a few minutes to arrive. Please also check your spam folder.</p>
        <button id="access-now-btn" style="background-color: #5cb85c; color: white; border: none; padding: 10px 20px; border-radius: 4px; margin-top: 15px; cursor: pointer;">Access Listings Now</button>
      </div>
    </div>
  </div>
  
  <div class="container" id="listings-container" style="display: none;">
    
    <!-- Search Bar - Sticky -->
    <div class="cg-search-wrapper" id="cg-search-wrapper">
      <div class="cg-quick-search">
        <div class="cg-search-input-wrapper">
          <i class="fas fa-search cg-search-icon"></i>
          <input type="text" id="property-search" class="cg-search-input" placeholder="Search by location, project, lot number...">
        </div>
        <button id="search-button" class="cg-search-btn">
          <i class="fas fa-search"></i>
          Search
        </button>
      </div>
      
      <!-- Quick Filters -->
      <div class="cg-quick-filters">
        <button class="cg-quick-filter active" data-filter="all">All Properties</button>
        <button class="cg-quick-filter" data-filter="available">Available</button>
        <button class="cg-quick-filter" data-filter="house-and-land">House & Land</button>
        <button class="cg-quick-filter" data-filter="land-only">Land Only</button>
        <button class="cg-quick-filter" data-filter="registered">Registered</button>
        <!-- Removed "coming soon" button as requested -->
      </div>
    </div>
    
    <!-- Filter Panel -->
<div class="cg-filter-panel">
  <div class="cg-filter-header">
    <h2 class="cg-filter-title">
      <i class="fas fa-filter"></i>
      Filter Properties
    </h2>
    <button id="toggle-filters" class="cg-filter-toggle">
      <span class="toggle-text">Show All Filters</span>
      <i class="fas fa-chevron-down"></i>
    </button>
  </div>
  <!-- Filter Grid - Primary Filters Row -->
  <div class="cg-filter-grid">
    <div class="cg-filter-group">
      <label for="project-filter" class="cg-filter-label">Project</label>
      <select id="project-filter" class="cg-filter-select">
        <option value="">All Projects</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="suburb-filter" class="cg-filter-label">Suburb</label>
      <select id="suburb-filter" class="cg-filter-select">
        <option value="">All Suburbs</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="listing-type-filter" class="cg-filter-label">Listing Type</label>
      <select id="listing-type-filter" class="cg-filter-select">
        <option value="">All Listing Types</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
  </div>
  
  <!-- Secondary Filters Row -->
  <div class="cg-filter-grid" style="margin-top: var(--spacing-lg);">
    <div class="cg-filter-group">
      <label for="status-filter" class="cg-filter-label">Status</label>
      <select id="status-filter" class="cg-filter-select">
        <option value="">All Statuses</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="neighborhood-filter" class="cg-filter-label">Neighborhood</label>
      <select id="neighborhood-filter" class="cg-filter-select">
        <option value="">All Neighborhoods</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="registration-date-filter" class="cg-filter-label">Registration Date</label>
      <select id="registration-date-filter" class="cg-filter-select">
        <option value="">Any Date</option>
        <option value="next-3-months">Next 3 Months</option>
        <option value="next-6-months">Next 6 Months</option>
        <option value="this-year">This Year</option>
        <option value="next-year">Next Year</option>
        <option value="registered">Already Registered</option>
      </select>
    </div>
  </div>
  
  <!-- Advanced Filters - Initially Hidden -->
  <div id="advanced-filters" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="land-shape-filter" class="cg-filter-label">Land Shape</label>
      <select id="land-shape-filter" class="cg-filter-select">
        <option value="">All Land Shapes</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="aspect-filter" class="cg-filter-label">Aspect</label>
      <select id="aspect-filter" class="cg-filter-select">
        <option value="">All Aspects</option>
        <option value="North">North</option>
        <option value="South">South</option>
        <option value="East">East</option>
        <option value="West">West</option>
        <option value="North East">North East</option>
        <option value="North West">North West</option>
        <option value="South East">South East</option>
        <option value="South West">South West</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="title-type-filter" class="cg-filter-label">Title Type</label>
      <select id="title-type-filter" class="cg-filter-select">
        <option value="">All Title Types</option>
        <option value="cg_torrens">Torrens</option>
        <option value="cg_community">Community</option>
      </select>
    </div>
  </div>
  
  <!-- More Advanced Filters - Initially Hidden -->
  <div id="advanced-filters-2" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="land-size-filter" class="cg-filter-label">Land Size</label>
      <select id="land-size-filter" class="cg-filter-select">
        <option value="">Any Size</option>
        <option value="0-300">Under 300m</option>
        <option value="300-450">300m - 450m</option>
        <option value="450-600">450m - 600m</option>
        <option value="600-800">600m - 800m</option>
        <option value="800+">Over 800m</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="frontage-filter" class="cg-filter-label">Frontage (m)</label>
      <select id="frontage-filter" class="cg-filter-select">
        <option value="">Any Frontage</option>
        <option value="0-10">Under 10m</option>
        <option value="10-15">10m - 15m</option>
        <option value="15-20">15m - 20m</option>
        <option value="20+">Over 20m</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="price-filter" class="cg-filter-label">Price Range</label>
      <select id="price-filter" class="cg-filter-select">
        <option value="">Any Price</option>
        <option value="0-500000">Under $500,000</option>
        <option value="500000-750000">$500,000 - $750,000</option>
        <option value="750000-1000000">$750,000 - $1,000,000</option>
        <option value="1000000-1500000">$1,000,000 - $1,500,000</option>
        <option value="1500000+">$1,500,000+</option>
      </select>
    </div>
  </div>
  
  <!-- Property Specs Filters - Initially Hidden -->
  <div id="advanced-filters-3" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="bedrooms-filter" class="cg-filter-label">Bedrooms</label>
      <select id="bedrooms-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
        <option value="5">5+</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="bathrooms-filter" class="cg-filter-label">Bathrooms</label>
      <select id="bathrooms-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="car-spaces-filter" class="cg-filter-label">Car Spaces</label>
      <select id="car-spaces-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
      </select>
    </div>
  </div>
  
  <!-- Active Filters Pills -->
  <div id="active-filters" class="cg-active-filters">
    <!-- Will be populated dynamically -->
  </div>
  
  <!-- Filter Action Buttons -->
  <div id="filter-buttons" class="cg-filter-buttons" style="display: none;">
    <button id="clear-filters" class="cg-btn-clear">
      <i class="fas fa-times"></i> Clear All Filters
    </button>
    <button id="apply-filters" class="cg-btn-apply">
      <i class="fas fa-check"></i> Apply Filters
    </button>
  </div>
</div>
    
    <!-- View Toggle and Sorting Controls -->
    <div class="cg-view-controls">
      <div class="cg-view-toggle">
        <button id="grid-view-toggle" class="cg-view-btn active">
          <i class="fas fa-th-large"></i> Grid View
        </button>
        <button id="map-view-toggle" class="cg-view-btn">
          <i class="fas fa-map-marked-alt"></i> Map View
        </button>
      </div>
      
      <div class="cg-sort-controls">
        <div class="cg-sort-label">Sort By:</div>
        <select id="sort-by" class="cg-sort-select">
          <option value="default">Default</option>
          <option value="price-asc">Price (Low to High)</option>
          <option value="price-desc">Price (High to Low)</option>
          <option value="land-size-asc">Land Size (Small to Large)</option>
          <option value="land-size-desc">Land Size (Large to Small)</option>
          <option value="frontage-desc">Frontage (Largest First)</option>
          <option value="registration-date-asc">Registration (Soonest First)</option>
          <option value="bedrooms-desc">Bedrooms (Most First)</option>
          <option value="project">Project Name</option>
          <option value="newest">Newest First</option>
        </select>
        
        <div id="toggle-direction" class="cg-sort-direction">
          <i class="fas fa-sort-amount-down"></i>
          <span>Descending</span>
        </div>
      </div>
    </div>
    
    <!-- Results Count -->
    <div id="results-count" class="cg-results-count">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Map View Container -->
    <div id="map-view-container" class="cg-map-container" style="display: none;">
      <!-- Geocoding Status Indicator -->
      <div id="geocoding-status" class="cg-geocoding-status" style="display: none;">
        <div id="geocoding-message">Geocoding properties...</div>
        <div class="cg-geocoding-progress">
          <div id="geocoding-progress-bar" class="cg-geocoding-bar"></div>
        </div>
      </div>
      
      <!-- Map Controls -->
      <div class="cg-map-controls">
        <button id="map-streets" class="cg-map-btn active">
          <i class="fas fa-road"></i> Streets
        </button>
        <button id="map-satellite" class="cg-map-btn">
          <i class="fas fa-satellite"></i> Satellite
        </button>
        <button id="map-hybrid" class="cg-map-btn">
          <i class="fas fa-layer-group"></i> Hybrid
        </button>
      </div>
      
      <!-- Map Disclaimer -->
      <div id="map-disclaimer" class="cg-map-disclaimer">
        <strong>Note:</strong> All property locations shown are approximate and for reference purposes only. Locations are based on project coordinates and may not represent exact property boundaries.
      </div>
      
      <!-- Map Element -->
      <div id="property-map" class="cg-property-map"></div>
      
      <!-- Property Preview Panel -->
      <div id="map-property-preview" class="cg-map-preview cg-preview-hidden">
        <div class="cg-preview-header">
          <h3 id="preview-title" class="cg-preview-title">Property Title</h3>
          <button id="close-preview" class="cg-preview-close">&times;</button>
        </div>
        <div class="cg-preview-content">
          <div id="preview-status" class="cg-preview-status cg-status-available">Available</div>
          <p id="preview-price" class="cg-preview-price">$450,000</p>
          <p id="preview-details" class="cg-preview-details">450m  15m frontage  North</p>
          <div id="preview-zoning" class="cg-preview-zoning">
            <strong>Zoning:</strong> <span id="preview-zoning-value">Low Density Residential</span><br>
            <strong>School Zone:</strong> <span id="preview-school-zone" class="cg-school-zone">Local High School</span>
          </div>
          <button id="preview-view-btn" class="cg-preview-btn">
            <i class="fas fa-external-link-alt"></i> View Details
          </button>
        </div>
      </div>
    </div>
    
    <!-- Properties Container -->
    <div id="properties-container">
      <!-- Loading State (will be dynamically replaced) -->
      <div class="cg-loading">
        <div class="cg-spinner"></div>
        <p class="cg-loading-text">Loading properties...</p>
      </div>
    </div>
    
    <!-- Pagination -->
    <div id="pagination" class="cg-pagination" style="display: none;">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Quick View Modal -->
    <div id="quick-view-modal" class="cg-quick-view-modal">
      <div class="cg-modal-content">
        <div class="cg-modal-header">
          <h3 id="modal-title" class="cg-modal-title">Property Details</h3>
          <button id="modal-close" class="cg-modal-close">&times;</button>
        </div>
        <div id="modal-body" class="cg-modal-body">
          <!-- Modal content will be dynamically inserted -->
        </div>
        <div class="cg-modal-footer">
          <button id="modal-close-btn" class="cg-modal-btn secondary">Close</button>
          <button id="modal-view-details" class="cg-modal-btn primary">
            <i class="fas fa-external-link-alt"></i> View Full Details
          </button>
        </div>
      </div>
    </div>
    
    <!-- Saved Properties Compare Drawer -->
    <div id="compare-drawer" class="cg-compare-drawer">
      <div class="cg-compare-header">
        <h3 class="cg-compare-title">Compare Properties (<span id="compare-count">0</span>)</h3>
        <button id="compare-close" class="cg-compare-close">&times;</button>
      </div>
      <div id="compare-items" class="cg-compare-items">
        <!-- Will be populated dynamically -->
      </div>
      <div class="cg-compare-actions">
        <button id="compare-btn" class="cg-compare-btn" disabled>
          <i class="fas fa-chart-bar"></i> Compare Properties
        </button>
      </div>
    </div>
    
    <!-- Toast Notifications Container -->
    <div id="toast-container" class="cg-toast-container">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Debug information (hidden by default) -->
    <div id="debug-info" style="display: none;"></div>
  </div>
  <script>
  // Castle Group Property Listings
document.addEventListener('DOMContentLoaded', function() {
  // ========================
  // Configuration & Constants
  // ========================
  const CONFIG = {
    apiEndpoint: 'https://eo6b0y2wbmrsq7l.m.pipedream.net',
    mapboxApiEndpoint: 'https://eo9gqdeujnljhqh.m.pipedream.net/',
    propertiesPerPage: 9,
    geocodingThreshold: 1.0, // 1.0km proximity threshold
    defaultLocation: { lat: -33.8688, lng: 151.2093 }, // Sydney
    debugMode: new URLSearchParams(window.location.search).get('debug') === 'true'
  };
  
  const NSW_BOUNDS = {
    north: -28.15, // Northern border
    south: -37.50, // Southern border
    east: 153.64,  // Eastern border (coastline)
    west: 141.00   // Western border
  };
  
  // Default suburb centers for faster geocoding
  const SUBURB_CENTERS = {
    'Austral': { lat: -33.9501, lng: 150.8273 },
    'Kellyville': { lat: -33.7014, lng: 150.9487 },
    'Leppington': { lat: -33.9605, lng: 150.7836 },
    'Oakville': { lat: -33.6250, lng: 150.8544 },
    'Pitt Town': { lat: -33.5849, lng: 150.8594 },
    'Rouse Hill': { lat: -33.6818, lng: 150.9157 },
    'Vineyard': { lat: -33.6473, lng: 150.8399 },
    // Keep other suburbs as fallbacks
    'Sydney': { lat: -33.8688, lng: 151.2093 },
    'Parramatta': { lat: -33.8150, lng: 151.0011 },
    'Chatswood': { lat: -33.7986, lng: 151.1809 },
    'Bondi': { lat: -33.8920, lng: 151.2775 },
    'Manly': { lat: -33.7971, lng: 151.2844 },
    'Penrith': { lat: -33.7511, lng: 150.6942 }
  };
  
  // Project-specific coordinates for more accurate mapping
  const PROJECT_COORDINATES = {
    'Fifteenth Avenue': { lat: -33.91615699103137, lng: 150.80745524232896 },
    '505-535 Fifteenth Avenue': { lat: -33.91615699103137, lng: 150.80745524232896 },
    'Valley Rise': { lat: -33.960965, lng: 150.821498 },
    'Bloomfield': { lat: -33.935464, lng: 150.792713 },
    'River Oaks': { lat: -33.64437800332728, lng: 150.87371022590727 },
    'Riviere': { lat: -33.573160492410885, lng: 150.86985371241119 },
    'The Rouse Hill Estate': { lat: -33.67859665482809, lng: 150.88611618357965 },
    'One FairWay': { lat: -33.719811127758454, lng: 150.96226740715773 },
    'Park Avenue 2': { lat: -33.68860529650804, lng: 150.89938596823788 },
    'Park Avenue': { lat: -33.68820738573453, lng: 150.8959351134934 },
    // Additional projects with their coordinates
    'Meadowview': { lat: -33.695123, lng: 150.883546 },
    'Riverside Estates': { lat: -33.603482, lng: 150.891234 },
    'Highland Park': { lat: -33.712345, lng: 150.923456 },
    'Summit Ridge': { lat: -33.723456, lng: 150.912345 }
  };

  // ========================
  // State Management
  // ========================
  const CastleApp = {
    state: {
      allProperties: [],
      filteredProperties: [],
      currentPage: 1,
      currentSort: 'default',
      isDescending: true,
      map: null,
      mapInitialized: false,
      mapMarkers: [],
      currentMapBounds: null,
      selectedMarker: null,
      mapboxToken: null,
      tokenExpiry: 0,
      geocodingCache: {},
      geocodingQueue: [],
      isGeocodingInProgress: false,
      compareProperties: [],
      favorites: JSON.parse(localStorage.getItem('cg-favorites') || '[]'),
      filters: {
        search: '',
        project: '',
        suburb: '',
        neighborhood: '',
        listingType: '',
        status: '',
        landShape: '',
        aspect: '',
        titleType: '',
        registrationDate: '',
        storeys: '',
        isLandOnly: false, // Added for Land Only filter
        priceMin: null,
        priceMax: null,
        landSizeMin: null,
        landSizeMax: null,
        buildSizeMin: null,
        buildSizeMax: null,
        frontageMin: null,
        frontageMax: null,
        depthMin: null,
        depthMax: null,
        minBedrooms: null,
        minBathrooms: null,
        minCarSpaces: null
      }
    },
    
    // ========================
    // Initialization Functions
    // ========================
    init() {
      this.setupDebugMode();
      this.initializeUIInteractions();
      this.initializeFilters();
      this.loadProperties();
      this.initQuickView();
      this.initCompareDrawer();
      this.initToastSystem();
      
      // Sticky search on scroll
      window.addEventListener('scroll', this.handleSearchSticky);
    },
    
    setupDebugMode() {
      if (CONFIG.debugMode) {
        document.getElementById('debug-info').style.display = 'block';
      }
    },
    
    // ========================
    // Property Loading & Data Handling
    // ========================
    async loadProperties() {
      const container = document.getElementById('properties-container');
      
      // Show loading state immediately
      if (container) {
        this.displaySkeletonLoaders();
      }
      
      try {
        this.log("Starting property fetch...");
        
        // Use a timestamp to prevent caching
        const timestamp = new Date().getTime();
        const url = `${CONFIG.apiEndpoint}?_t=${timestamp}`;
        
        this.log(`Fetching from: ${url}`);
        
        // Set a timeout to abort long-running requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
        
        const response = await fetch(url, {
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        this.log(`Received response: ${response.status}`);
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        
        const data = await response.json();
        
        this.log(`Data parsed successfully, success: ${data.success}, results: ${data.results?.length || 0}`);
        
        if (!data.success) {
          throw new Error(data.error || "Unknown API error");
        }
        
        if (!data.results || data.results.length === 0) {
          this.renderNoResults();
          return;
        }
        
        // Store all properties
        this.state.allProperties = data.results;
        
        // Filter for only the specified statuses
        const includedStatuses = [
          "cg_exclusive",
          "cg_available",
          "cg_under_offer",
          "cg_hold"
        ];
        
        // Filter out any properties with status not in includedStatuses
        this.state.allProperties = this.state.allProperties.filter(property => {
          const status = property.properties?.cg_status;
          return status && includedStatuses.includes(status);
        });
        
        this.log(`After status filtering: ${this.state.allProperties.length} properties remain`);
        
        // Initialize filter dropdowns with available options
        this.populateFilterOptions();
        
        // Apply initial filtering (no filters active)
        this.filterProperties();
        
        // Log cache status if available
        if (data.cached) {
          this.log(`Using cached data (${data.cache_age} seconds old)`);
        }
        
      } catch (error) {
        this.log(`ERROR: ${error.message}`);
        
        // Check if it was a timeout
        const errorMessage = error.name === 'AbortError' 
          ? 'Request timed out. The server is taking too long to respond.' 
          : error.message;
        
        this.renderError(errorMessage);
      }
    },
    
    // ========================
    // Filtering & Sorting
    // ========================
    filterProperties() {
      // Define included statuses
      const includedStatuses = [
        "cg_exclusive",
        "cg_available",
        "cg_under_offer",
        "cg_hold"
      ];
      
      // Add debug logging for all active filters
      if (CONFIG.debugMode) {
        const activeFilters = Object.entries(this.state.filters)
          .filter(([key, value]) => value && value !== '')
          .map(([key, value]) => `${key}: ${value}`)
          .join(', ');
        
        this.log(`Active filters: ${activeFilters || 'None'}`);
        
        // Log specific filters of interest
        if (this.state.filters.titleType) {
          const availableTitles = Array.from(new Set(
            this.state.allProperties
              .map(p => p.properties?.cg_title)
              .filter(Boolean)
          ));
          this.log(`Available title types: ${availableTitles.join(', ')}`);
        }
        
        if (this.state.filters.listingType) {
          const availableListingTypes = Array.from(new Set(
            this.state.allProperties
              .map(p => p.properties?.hs_listing_type)
              .filter(Boolean)
          ));
          this.log(`Available listing types: ${availableListingTypes.join(', ')}`);
        }
      }
      
      this.state.filteredProperties = this.state.allProperties.filter(property => {
        const props = property.properties || {};
        
        // First check: Only include properties with desired statuses
        if (!props.cg_status || !includedStatuses.includes(props.cg_status)) {
          return false;
        }
        
        // Land Only filter - check the cg_land field
        if (this.state.filters.isLandOnly) {
          // Keep only properties that have a value in cg_land field
          if (!props.cg_land) {
            return false;
          }
        }
        
        // Search filter - check multiple fields
        if (this.state.filters.search) {
          const searchFields = [
            props.hs_listing_type,
            props.cg_project,
            props.cg_stage,
            props.cg_dp_lot,
            props.cg_mp_lot,
            props.hs_address_1,
            props.hs_city,
            props.cg_house_type,
            props.cg_land_type,
            props.cg_aspect,
            props.cg_title,
            props.hs_neighborhood
          ];
          
          const searchText = searchFields.filter(field => field).join(' ').toLowerCase();
          if (!searchText.includes(this.state.filters.search)) {
            return false;
          }
        }
        
        // Project filter
        if (this.state.filters.project && props.cg_project !== this.state.filters.project) {
          return false;
        }
        
        // Suburb filter
        if (this.state.filters.suburb && props.hs_city !== this.state.filters.suburb) {
          return false;
        }
        
        // Neighborhood filter
        if (this.state.filters.neighborhood && props.hs_neighborhood !== this.state.filters.neighborhood) {
          return false;
        }
        
        // Listing Type filter - Using exact match for special values
if (this.state.filters.listingType) {
  // For House and Land Only, use exact matching with the internal values
  if (this.state.filters.listingType === 'house' || 
      this.state.filters.listingType === 'cg_land') {
    if (props.hs_listing_type !== this.state.filters.listingType) {
      return false;
    }
  } else {
    // For other listing types, continue using flexible matching for better UX
    const propListingType = (props.hs_listing_type || '').toLowerCase().trim();
    const filterListingType = this.state.filters.listingType.toLowerCase().trim();
    
    if (!propListingType.includes(filterListingType) && !filterListingType.includes(propListingType)) {
      return false;
    }
  }
}
        
        // Status filter
        if (this.state.filters.status && props.cg_status !== this.state.filters.status) {
          return false;
        }
        
        // Land Shape filter (formerly Land Type)
        if (this.state.filters.landShape && props.cg_land_type !== this.state.filters.landShape) {
          return false;
        }
        
        // Aspect filter
        if (this.state.filters.aspect && props.cg_aspect !== this.state.filters.aspect) {
          return false;
        }
        
        // Title type filter - Updated to use the internal values
        if (this.state.filters.titleType && props.cg_title) {
          // Direct match with internal HubSpot values (cg_torrens, cg_community)
          if (this.state.filters.titleType !== props.cg_title) {
            return false;
          }
        } else if (this.state.filters.titleType) {
          return false;
        }
        
        // Registration date filter
        if (this.state.filters.registrationDate) {
          if (this.state.filters.registrationDate === 'registered') {
            // Check if property is registered (has a registration date in the past)
            if (!props.cg_registration_date) {
              return false;
            }
            
            const regDate = new Date(props.cg_registration_date);
            const today = new Date();
            
            if (regDate > today) {
              return false;
            }
          } else {
            // For other registration date filters, implement specific logic
            // ...
          }
        }
        
        // Price range filter
        if (this.state.filters.priceMin || this.state.filters.priceMax) {
          const price = this.getPriceValue(props);
          
          if (this.state.filters.priceMin && price < this.state.filters.priceMin) {
            return false;
          }
          
          if (this.state.filters.priceMax && price > this.state.filters.priceMax) {
            return false;
          }
        }
        
        // Land size filter
        if (this.state.filters.landSizeMin || this.state.filters.landSizeMax) {
          const landSize = parseFloat(props.hs_lot_size || 0);
          
          if (this.state.filters.landSizeMin && landSize < this.state.filters.landSizeMin) {
            return false;
          }
          
          if (this.state.filters.landSizeMax && landSize > this.state.filters.landSizeMax) {
            return false;
          }
        }
        
        // Build size filter
        if (this.state.filters.buildSizeMin || this.state.filters.buildSizeMax) {
          const buildSize = parseFloat(props.cg_total_build_size || 0);
          
          if (this.state.filters.buildSizeMin && buildSize < this.state.filters.buildSizeMin) {
            return false;
          }
          
          if (this.state.filters.buildSizeMax && buildSize > this.state.filters.buildSizeMax) {
            return false;
          }
        }
        
        // Frontage filter
        if (this.state.filters.frontageMin || this.state.filters.frontageMax) {
          const frontage = parseFloat(props.cg_frontage || 0);
          
          if (this.state.filters.frontageMin && frontage < this.state.filters.frontageMin) {
            return false;
          }
          
          if (this.state.filters.frontageMax && frontage > this.state.filters.frontageMax) {
            return false;
          }
        }
        
        // Depth filter
        if (this.state.filters.depthMin || this.state.filters.depthMax) {
          const depth = parseFloat(props.cg_depth || 0);
          
          if (this.state.filters.depthMin && depth < this.state.filters.depthMin) {
            return false;
          }
          
          if (this.state.filters.depthMax && depth > this.state.filters.depthMax) {
            return false;
          }
        }
        
        // Bedroom filter
        if (this.state.filters.minBedrooms) {
          const bedrooms = parseInt(props.hs_bedrooms || 0);
          
          if (bedrooms < this.state.filters.minBedrooms) {
            return false;
          }
        }
        
        // Bathroom filter
        if (this.state.filters.minBathrooms) {
          const bathrooms = parseInt(props.hs_bathrooms || 0);
          
          if (bathrooms < this.state.filters.minBathrooms) {
            return false;
          }
        }
        
        // Car spaces filter
        if (this.state.filters.minCarSpaces) {
          const carSpaces = parseInt(props.cg_car || 0);
          
          if (carSpaces < this.state.filters.minCarSpaces) {
            return false;
          }
        }
        
        return true;
      });
      
      // Reset to first page when filters change
      this.state.currentPage = 1;
      
      // Apply sorting
      this.sortProperties();
      
      // Render the filtered properties
      this.renderProperties();
      
      // Update pagination
      this.updatePagination();
      
      // Update results count
      this.updateResultsCount();
      
      // Update map markers if map is initialized and visible
      if (this.state.mapInitialized && document.getElementById('map-view-container').style.display !== 'none') {
        this.renderPropertyMarkers();
      }
      
      this.log(`Filtered to ${this.state.filteredProperties.length} properties`);
    },
    
    sortProperties() {
      if (!this.state.filteredProperties.length) return;
      
      // Define sort types and their functions
      const sortFunctions = {
        'default': (a, b) => 0, // No specific sort, use default API order
        'price-asc': (a, b) => {
          const priceA = this.getPriceValue(a.properties);
          const priceB = this.getPriceValue(b.properties);
          return this.state.isDescending ? priceB - priceA : priceA - priceB;
        },
        'price-desc': (a, b) => {
          const priceA = this.getPriceValue(a.properties);
          const priceB = this.getPriceValue(b.properties);
          return this.state.isDescending ? priceA - priceB : priceB - priceA;
        },
        'land-size-asc': (a, b) => {
          const sizeA = parseFloat(a.properties?.hs_lot_size || 0);
          const sizeB = parseFloat(b.properties?.hs_lot_size || 0);
          return this.state.isDescending ? sizeB - sizeA : sizeA - sizeB;
        },
        'land-size-desc': (a, b) => {
          const sizeA = parseFloat(a.properties?.hs_lot_size || 0);
          const sizeB = parseFloat(b.properties?.hs_lot_size || 0);
          return this.state.isDescending ? sizeA - sizeB : sizeB - sizeA;
        },
        'frontage-desc': (a, b) => {
          const frontageA = parseFloat(a.properties?.cg_frontage || 0);
          const frontageB = parseFloat(b.properties?.cg_frontage || 0);
          return this.state.isDescending ? frontageA - frontageB : frontageB - frontageA;
        },
        'registration-date-asc': (a, b) => {
          const dateA = a.properties?.cg_registration_date ? new Date(a.properties.cg_registration_date) : new Date(9999, 11, 31);
          const dateB = b.properties?.cg_registration_date ? new Date(b.properties.cg_registration_date) : new Date(9999, 11, 31);
          return this.state.isDescending ? dateB - dateA : dateA - dateB;
        },
        'bedrooms-desc': (a, b) => {
          const bedroomsA = parseInt(a.properties?.hs_bedrooms || 0);
          const bedroomsB = parseInt(b.properties?.hs_bedrooms || 0);
          return this.state.isDescending ? bedroomsA - bedroomsB : bedroomsB - bedroomsA;
        },
        'project': (a, b) => {
          const projectA = a.properties?.cg_project || '';
          const projectB = b.properties?.cg_project || '';
          const compare = projectA.localeCompare(projectB);
          return this.state.isDescending ? -compare : compare;
        },
        'newest': (a, b) => {
          // For demo, using ID as proxy for "newest" since we don't have created date
          const idA = parseInt(a.id || 0);
          const idB = parseInt(b.id || 0);
          return this.state.isDescending ? idB - idA : idA - idB;
        }
      };
      
      // Apply the selected sort function
      const sortFunction = sortFunctions[this.state.currentSort] || sortFunctions['default'];
      this.state.filteredProperties.sort(sortFunction);
      
      // Reset to first page when sort changes
      this.state.currentPage = 1;
    },
    
    getPriceValue(props) {
      if (!props) return 0;
      
      const price = parseFloat(props.hs_price || 
                  props.cg_listed_package_price || 
                  props.cg_build_list_price || 
                  props.cg_land_release_price || 0);
      return price;
    },
    
    // ========================
    // UI Rendering
    // ========================
    renderProperties() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      // Calculate page properties
      const startIndex = (this.state.currentPage - 1) * CONFIG.propertiesPerPage;
      const endIndex = startIndex + CONFIG.propertiesPerPage;
      const paginatedProperties = this.state.filteredProperties.slice(startIndex, endIndex);
      
      if (this.state.filteredProperties.length === 0) {
        this.renderNoResults();
        return;
      }
      
      let html = '<div class="cg-properties-grid">';
      
      // Add each property card
      paginatedProperties.forEach(property => {
        const props = property.properties || {};
        const id = property.id || '';
        
        // Get all details with proper null handling
        const rawListingType = props.hs_listing_type || props.cg_listing_type || '';
        const title = this.formatListingType(rawListingType);
        const project = props.cg_project || '';
        const stage = props.cg_stage || '';
        const dpLot = props.cg_dp_lot || '';
        const mpLot = props.cg_mp_lot || '';
        const suburb = props.hs_city || '';
        const neighborhood = props.hs_neighborhood || '';
        
        // Get address for property card
        const address = props.hs_address_1 || '';
        
        // Get formatted status and CSS class
        const statusRaw = props.cg_status || '';
        const status = this.formatFieldName(statusRaw);
        const statusClass = this.getStatusClass(statusRaw);
        
        const bedrooms = props.hs_bedrooms || '';
        const bathrooms = props.hs_bathrooms || '';
        const carSpaces = props.cg_car || '';
        const aspect = props.cg_aspect || 'N/A';
        const titleType = props.cg_title || '';
        const frontage = props.cg_frontage || '';
        const depth = props.cg_depth || '';
        const registrationDate = props.cg_registration_date || '';
        
        // Get price from various fields - prioritize cg_listed_package_price
        let price = props.cg_listed_package_price || props.hs_price || 
                   props.cg_build_list_price || props.cg_land_release_price || '';
        
        // Get more details
        const buildSize = props.cg_total_build_size || '';
        const lotSize = props.hs_lot_size || '';
        const landShape = this.formatFieldName(props.cg_land_type || '');
        const houseType = this.formatFieldName(props.cg_house_type || '');
        
        // Check if it's a new listing (for demo purposes, random)
        const isNew = Math.random() > 0.8; // 20% chance to be marked as new
        
        // Check if property is in favorites
        const isFavorite = this.state.favorites.includes(id);
        
        // Check if property is in compare list
        const isInCompare = this.state.compareProperties.some(p => p.id === id);
        
        // Check if it's a land listing - using cg_land field now
        const isLandOnly = props.cg_land ? true : false;
        
        // Display suburb as NSW
        const displaySuburb = suburb ? `${suburb}, NSW` : 'NSW';
        
        // Format title type display name from internal value
        let displayTitleType = '';
        if (titleType === 'cg_torrens') {
          displayTitleType = 'Torrens';
        } else if (titleType === 'cg_community') {
          displayTitleType = 'Community';
        } else {
          displayTitleType = titleType;
        }
        
        html += `
  <div class="cg-property-card" data-id="${id}">
    <a href="property-detail?id=${id}" class="cg-property-link">
      <!-- Removed the 'new' badge -->
      ${displayTitleType ? `<div class="cg-title-type-badge">${displayTitleType}</div>` : ''}
      
      <!-- Positioned favorites button at top-right instead of top-left -->
      <button type="button" class="cg-save-favorite ${isFavorite ? 'active' : ''}" 
              data-id="${id}" aria-label="Save to favorites">
        <i class="${isFavorite ? 'fas' : 'far'} fa-heart"></i>
      </button>
      
      <button type="button" class="cg-compare-badge ${isInCompare ? 'active' : ''}" 
              data-id="${id}" aria-label="Add to compare">
        <i class="fas fa-balance-scale"></i>
      </button>
      
      <div class="cg-property-header">
        <div class="cg-property-status cg-status-${statusClass}">${status}</div>
        <div class="cg-property-price">${this.formatPrice(price)}</div>
      </div>
      
      <div class="cg-property-content">
        <h3 class="cg-property-title">${title}</h3>
                
                <!-- Display address if available -->
                ${address ? `
                <div class="cg-property-location">
                  <i class="fas fa-map-marker-alt"></i>
                  ${address}${suburb ? `, ${suburb}, NSW` : ', NSW'}
                </div>` : ''}
                
                <div class="cg-property-meta">
                  ${project ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-project-diagram"></i>
                    <span><span class="cg-meta-label">Project:</span> ${this.formatFieldName(project)}</span>
                  </div>` : ''}
                  
                  ${stage ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-layer-group"></i>
                    <span><span class="cg-meta-label">Stage:</span> ${this.formatFieldName(stage)}</span>
                  </div>` : ''}
                  
                  ${dpLot ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-map"></i>
                    <span><span class="cg-meta-label">DP Lot:</span> ${dpLot}</span>
                  </div>` : ''}
                  
                  ${mpLot ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-map-signs"></i>
                    <span><span class="cg-meta-label">MP Lot:</span> ${mpLot}</span>
                  </div>` : ''}
                </div>
                
                ${suburb && !address ? `
                <div class="cg-meta-item">
                  <i class="fas fa-city"></i>
                  <span><span class="cg-meta-label">Suburb:</span> ${displaySuburb}</span>
                </div>` : ''}
                
                ${neighborhood ? `
                <div class="cg-meta-item">
                  <i class="fas fa-building"></i>
                  <span><span class="cg-meta-label">Neighborhood:</span> ${neighborhood}</span>
                </div>` : ''}
                
                ${registrationDate ? `
                <div class="cg-registration-date">
                  <i class="fas fa-calendar-check"></i>
                  Registration: ${this.formatDate(registrationDate)}
                </div>` : ''}
                
                <!-- Add lot size badge -->
                <div class="cg-lot-size-badge">Low Density Residential</div>
                
                <div class="cg-property-specs">
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-ruler-combined"></i>
                    <div class="cg-spec-value">${lotSize || 'N/A'}</div>
                    <div class="cg-spec-label">Land m</div>
                  </div>
                  
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-compass"></i>
                    <div class="cg-spec-value">${aspect || 'N/A'}</div>
                    <div class="cg-spec-label">Aspect</div>
                  </div>
                  
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-arrows-alt-h"></i>
                    <div class="cg-spec-value">${frontage || 'N/A'}</div>
                    <div class="cg-spec-label">Frontage m</div>
                  </div>
                </div>
                
                <div class="cg-property-details">
                  ${displayTitleType ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Title Type:</div>
                    <div class="cg-detail-value">${displayTitleType}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && bedrooms ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Bedrooms:</div>
                    <div class="cg-detail-value">${bedrooms}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && bathrooms ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Bathrooms:</div>
                    <div class="cg-detail-value">${bathrooms}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && carSpaces ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Car Spaces:</div>
                    <div class="cg-detail-value">${carSpaces}</div>
                  </div>` : ''}
                  
                  ${frontage ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Frontage:</div>
                    <div class="cg-detail-value">${frontage}m</div>
                  </div>` : ''}
                  
                  ${depth ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Depth:</div>
                    <div class="cg-detail-value">${depth}m</div>
                  </div>` : ''}
                </div>
                
                <div class="cg-property-cta">
                  <i class="fas fa-external-link-alt"></i> View Details
                </div>
              </div>
            </a>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      
      // Add event listeners to favorite and compare buttons
      document.querySelectorAll('.cg-save-favorite').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const propertyId = btn.getAttribute('data-id');
          this.toggleFavorite(propertyId, btn);
        });
      });
      
      document.querySelectorAll('.cg-compare-badge').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const propertyId = btn.getAttribute('data-id');
          this.toggleCompare(propertyId, btn);
        });
      });
      
      this.log(`Rendered ${paginatedProperties.length} properties for page ${this.state.currentPage}`);
    },
    
    renderNoResults() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      container.innerHTML = `
        <div class="cg-no-results">
          <h3 class="cg-no-results-title">No Properties Found</h3>
          <p class="cg-no-results-message">No properties match your current filters. Try adjusting your search criteria.</p>
          <button id="clear-all-filters" class="cg-btn-apply">Clear All Filters</button>
        </div>
      `;
      
      // Add event listener to the clear filters button
      document.getElementById('clear-all-filters').addEventListener('click', () => {
        this.clearAllFilters();
      });
    },
    
    renderError(errorMessage) {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      container.innerHTML = `
        <div class="cg-error-container">
          <h3 class="cg-error-title">Error Loading Properties</h3>
          <p class="cg-error-message">${errorMessage}</p>
          <div class="cg-error-buttons">
            <button onclick="location.reload()" class="cg-error-btn">Try Again</button>
            <button id="btn-load-sample" class="cg-error-btn secondary">View Sample Properties</button>
          </div>
        </div>
      `;
      
      // Add event listener for load sample button
      document.getElementById('btn-load-sample').addEventListener('click', () => {
        this.loadSampleData();
      });
    },
    
    displaySkeletonLoaders() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      let html = '<div class="cg-properties-grid">';
      
      // Create 6 skeleton loaders
      for (let i = 0; i < 6; i++) {
        html += `
          <div class="cg-property-card">
            <div class="cg-property-header">
              <div class="cg-skeleton" style="width: 30%; height: 24px;"></div>
              <div class="cg-skeleton" style="width: 40%; height: 24px;"></div>
            </div>
            
            <div class="cg-property-content">
              <div class="cg-skeleton" style="width: 80%; height: 28px; margin-bottom: 12px;"></div>
              <div class="cg-skeleton" style="width: 60%; height: 18px; margin-bottom: 16px;"></div>
              
              <div class="cg-property-specs">
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
              </div>
              
              <div class="cg-property-details">
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
              </div>
              
              <div class="cg-skeleton" style="width: 100%; height: 40px; margin-top: 20px;"></div>
            </div>
          </div>
        `;
      }
      
      html += '</div>';
      container.innerHTML = html;
    },
    
    updateResultsCount() {
      const container = document.getElementById('results-count');
      if (!container) return;
      
      if (this.state.filteredProperties.length === 0) {
        container.textContent = 'No properties match your current filters.';
      } else if (this.state.filteredProperties.length === 1) {
        container.textContent = '1 property found';
      } else {
        container.textContent = `${this.state.filteredProperties.length} properties found`;
      }
    },
    
    updatePagination() {
      const paginationContainer = document.getElementById('pagination');
      if (!paginationContainer) return;
      
      const totalPages = Math.ceil(this.state.filteredProperties.length / CONFIG.propertiesPerPage);
      
      // If only one page or no results, hide pagination
      if (totalPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
      }
      
      paginationContainer.style.display = 'flex';
      let paginationHtml = '';
      
      // Previous button
      paginationHtml += `
        <button class="cg-pagination-btn prev-btn" ${this.state.currentPage === 1 ? 'disabled' : ''}>
          <i class="fas fa-chevron-left"></i>
        </button>
      `;
      
      // Page numbers
      const maxDisplayedPages = 5;
      let startPage = Math.max(1, this.state.currentPage - Math.floor(maxDisplayedPages / 2));
      let endPage = Math.min(totalPages, startPage + maxDisplayedPages - 1);
      
      // Adjust start page if end page is at maximum
      if (endPage === totalPages) {
        startPage = Math.max(1, endPage - maxDisplayedPages + 1);
      }
      
      // First page
      if (startPage > 1) {
        paginationHtml += `<button class="cg-pagination-btn" data-page="1">1</button>`;
        if (startPage > 2) {
          paginationHtml += `<span class="cg-pagination-ellipsis">...</span>`;
        }
      }
      
      // Page numbers
      for (let i = startPage; i <= endPage; i++) {
        paginationHtml += `
          <button class="cg-pagination-btn ${i === this.state.currentPage ? 'active' : ''}" data-page="${i}">
            ${i}
          </button>
        `;
      }
      
      // Last page
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          paginationHtml += `<span class="cg-pagination-ellipsis">...</span>`;
        }
        paginationHtml += `<button class="cg-pagination-btn" data-page="${totalPages}">${totalPages}</button>`;
      }
      
      // Next button
      paginationHtml += `
        <button class="cg-pagination-btn next-btn" ${this.state.currentPage === totalPages ? 'disabled' : ''}>
          <i class="fas fa-chevron-right"></i>
        </button>
      `;
      
      paginationContainer.innerHTML = paginationHtml;
      
      // Add event listeners to pagination buttons
      document.querySelectorAll('.cg-pagination-btn').forEach(button => {
        button.addEventListener('click', () => {
          if (button.hasAttribute('disabled')) return;
          
          if (button.classList.contains('prev-btn')) {
            if (this.state.currentPage > 1) {
              this.state.currentPage--;
              this.renderProperties();
              this.updatePagination();
            }
          } else if (button.classList.contains('next-btn')) {
            if (this.state.currentPage < totalPages) {
              this.state.currentPage++;
              this.renderProperties();
              this.updatePagination();
            }
          } else {
            const page = parseInt(button.getAttribute('data-page'));
            if (page !== this.state.currentPage) {
              this.state.currentPage = page;
              this.renderProperties();
              this.updatePagination();
            }
          }
          
          // Scroll to top of properties container
          document.getElementById('properties-container').scrollIntoView({ behavior: 'smooth' });
        });
      });
    },
    
    // ========================
    // Mapbox Integration
    // ========================
    async initializeMapView() {
      if (this.state.mapInitialized) return true;
      
      try {
        // Show loading indicator for the map
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          mapContainer.innerHTML = '<div class="cg-loading"><div class="cg-spinner"></div><p class="cg-loading-text">Loading map...</p></div>';
        }
        
        // Get token - now with async/await pattern
        try {
          this.state.mapboxToken = await this.getMapboxToken();
        } catch (tokenError) {
          this.log(`Token error: ${tokenError.message}, will attempt initialization anyway`);
        }
        
        if (!this.state.mapboxToken) {
          throw new Error("No valid Mapbox token available");
        }
        
        // Initialize map with proper error handling
        mapboxgl.accessToken = this.state.mapboxToken;
        
        // Check if mapboxgl is available
        if (!mapboxgl) {
          throw new Error("Mapbox GL JS library not loaded");
        }
        
        // Initialize map centered on Greater Sydney region
        this.state.map = new mapboxgl.Map({
          container: 'property-map',
          style: 'mapbox://styles/mapbox/streets-v11',
          center: [150.9000, -33.7500], // Center on Western Sydney where most suburbs are
          zoom: 9.5,
          attributionControl: true
        });
        
        // Add navigation controls
        this.state.map.addControl(new mapboxgl.NavigationControl(), 'top-left');
        
        // Add event handlers for map style controls
        document.getElementById('map-streets').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/streets-v11');
        });
        
        document.getElementById('map-satellite').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/satellite-v9');
        });
        
        document.getElementById('map-hybrid').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/satellite-streets-v11');
        });
        
        // Map property preview panel events
        document.getElementById('close-preview').addEventListener('click', () => {
          document.getElementById('map-property-preview').classList.add('cg-preview-hidden');
          
          // Reset previously selected marker if exists
          if (this.state.selectedMarker) {
            this.state.selectedMarker.getElement().style.width = '16px';
            this.state.selectedMarker.getElement().style.height = '16px';
            this.state.selectedMarker.getElement().style.zIndex = '1';
          }
          
          this.state.selectedMarker = null;
        });
        
        // When map loads, populate markers with proper error handling
        this.state.map.on('load', () => {
          try {
            // Make disclaimer always visible
            document.getElementById('map-disclaimer').style.display = 'block';
            
            // Process all properties - let renderPropertyMarkers handle the priority
            this.renderPropertyMarkers();
            this.state.mapInitialized = true;
            
            // Add bounds changed event to update visible properties
            this.state.map.on('moveend', () => {
              this.state.currentMapBounds = this.state.map.getBounds();
            });
            
            this.log("Map initialized successfully");
          } catch (markersError) {
            this.log(`Error rendering property markers: ${markersError.message}`);
            // Continue with map initialization even if markers fail
            this.state.mapInitialized = true;
          }
        });
        
        // Add error event handler
        this.state.map.on('error', (e) => {
          this.log(`Mapbox error: ${e.error ? e.error.message : 'Unknown error'}`);
        });
        
        return true;
      } catch (error) {
        this.log(`Error initializing map: ${error.message}`);
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          mapContainer.innerHTML = '<div class="cg-map-error">Unable to load map. Please try again later.</div>';
        }
        return false;
      }
    },
    
    renderPropertyMarkers() {
      // Clear existing markers
      this.clearMapMarkers();
      
      // If no properties, return
      if (!this.state.filteredProperties.length) {
        return;
      }
      
      // Create bounds object to fit all markers
      const bounds = new mapboxgl.LngLatBounds();
      let validMarkers = 0;
      
      // Process project properties with DIRECT coordinate forcing
      const projectProperties = this.state.filteredProperties.filter(p => 
        p.properties && p.properties.cg_project && PROJECT_COORDINATES[p.properties.cg_project]
      );
      
      // Process all project properties first with FORCED coordinates
      projectProperties.forEach(property => {
        try {
          const props = property.properties;
          const project = props.cg_project;
          
          // Get project center coordinates - this is now ALWAYS used
          const projectCenter = PROJECT_COORDINATES[project];
          
          // Generate a very small deterministic offset (max 50m)
          const offset = this.getControlledProjectOffset(property, projectCenter);
          
          // ALWAYS update property coordinates to forced values
          props.hs_latitude = (projectCenter.lat + offset.lat).toString();
          props.hs_longitude = (projectCenter.lng + offset.lng).toString();
          props._geocoding_source = 'project-forced';
          
          // Create marker with the strictly enforced coordinates
          const marker = this.createMarkerWithCoordinates(property, 
                                                projectCenter.lat + offset.lat, 
                                                projectCenter.lng + offset.lng);
          if (marker) {
            this.state.mapMarkers.push(marker);
            bounds.extend(marker.getLngLat());
            validMarkers++;
          }
        } catch (error) {
          this.log(`Error creating project marker for property ${property.id}: ${error.message}`);
        }
      });
      
      // Process remaining non-project properties normally
      const otherProperties = this.state.filteredProperties.filter(p => 
        !p.properties || 
        !p.properties.cg_project || 
        !PROJECT_COORDINATES[p.properties.cg_project]
      );
      
      // Regular handling for non-project properties
      let pendingGeocoding = 0;
      otherProperties.forEach(property => {
        try {
          const props = property.properties;
          
          // If we already have geocoded coordinates, create marker directly
          if (props?.hs_latitude && props?.hs_longitude) {
            const lat = parseFloat(props.hs_latitude);
            const lng = parseFloat(props.hs_longitude);
            
            if (!isNaN(lat) && !isNaN(lng) && this.isWithinNSWBounds(lat, lng)) {
              // Create marker directly
              const marker = this.createMarkerWithCoordinates(property, lat, lng);
              if (marker) {
                this.state.mapMarkers.push(marker);
                bounds.extend(marker.getLngLat());
                validMarkers++;
              }
              return;
            }
          }
          
          // Queue for geocoding
          pendingGeocoding++;
          this.queuePropertyForGeocoding(property, (coordinates) => {
            const marker = this.createMarkerWithCoordinates(property, coordinates.lat, coordinates.lng);
            if (marker) {
              this.state.mapMarkers.push(marker);
              bounds.extend(marker.getLngLat());
            }
          });
        } catch (error) {
          this.log(`Error creating non-project marker for property ${property.id}: ${error.message}`);
        }
      });
      
      // Update geocoding status message
      const statusElement = document.getElementById('geocoding-message');
      if (statusElement && pendingGeocoding > 0) {
        statusElement.textContent = `Geocoding ${pendingGeocoding} properties...`;
        document.getElementById('geocoding-status').style.display = 'block';
      } else if (statusElement) {
        document.getElementById('geocoding-status').style.display = 'none';
      }
      
      // If we have valid markers, fit map to bounds
      if (validMarkers > 0) {
        this.state.map.fitBounds(bounds, {
          padding: 50,
          maxZoom: 15
        });
        this.state.currentMapBounds = bounds;
        this.log(`Created ${validMarkers} property markers on map with ${pendingGeocoding} pending geocoding`);
      } else if (pendingGeocoding === 0) {
        this.log('No valid property markers could be created');
        
        // Show no results message on the map
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          const noResultsElement = document.createElement('div');
          noResultsElement.className = 'cg-map-error';
          noResultsElement.textContent = 'No properties could be located on the map. Try adjusting your filters or check back later.';
          mapContainer.appendChild(noResultsElement);
        }
      }
    },
    
    createMarkerWithCoordinates(property, lat, lng) {
      if (!this.state.map || isNaN(lat) || isNaN(lng)) return null;
      
      const props = property.properties || {};
      
      // If this is a forced project marker, don't modify coordinates
      if (props._geocoding_source === 'project-forced') {
        // Create marker directly with the forced coordinates
        const statusClass = this.getMarkerClass(props.cg_status || '');
        const el = document.createElement('div');
        el.className = `cg-map-marker ${statusClass}`;
        
        const marker = new mapboxgl.Marker(el)
          .setLngLat([lng, lat])
          .addTo(this.state.map);
        
        el.addEventListener('click', () => {
          this.showPropertyPreview(property, marker);
        });
        
        return marker;
      }
      
      // Get project if available for proximity validation
      const project = props.cg_project || '';
      const projectCenter = project && PROJECT_COORDINATES[project] ? 
        PROJECT_COORDINATES[project] : null;
      
      // FIXED: Always ensure coordinates are close to project if project is available
      if (projectCenter) {
        // Skip proximity check and ALWAYS use project coordinates with controlled offset
        const offset = this.getControlledProjectOffset(property, projectCenter);
        lat = projectCenter.lat + offset.lat;
        lng = projectCenter.lng + offset.lng;
        
        // Update property coordinates for consistency
        props.hs_latitude = lat.toString();
        props.hs_longitude = lng.toString();
        props._geocoding_source = 'project-marker-forced';
      }
      // Non-project properties can still use their coordinates with validation
      else {
        // Final verification that coordinates are within NSW
        if (!this.isWithinNSWBounds(lat, lng)) {
          // Fallback to suburb if needed
          if (props.hs_city && SUBURB_CENTERS[props.hs_city]) {
            const suburb = props.hs_city;
            const offset = this.generateDeterministicOffset(property, 0.0005);
            lat = SUBURB_CENTERS[suburb].lat + offset.lat;
            lng = SUBURB_CENTERS[suburb].lng + offset.lng;
            props._geocoding_source = 'suburb-marker-fallback';
            this.log(`Coordinates outside NSW bounds, using suburb fallback for ${suburb}`);
          } else {
            // Default to Sydney area
            const offset = this.generateDeterministicOffset(property, 0.003);
            lat = CONFIG.defaultLocation.lat + offset.lat;
            lng = CONFIG.defaultLocation.lng + offset.lng;
            props._geocoding_source = 'default-marker-fallback';
            this.log(`Coordinates outside NSW bounds, using Sydney fallback`);
          }
        }
      }
      
      // Update property coordinates
      props.hs_latitude = lat.toString();
      props.hs_longitude = lng.toString();
      
      // Get property status for marker color
      const status = props.cg_status || '';
      const statusClass = this.getMarkerClass(status);
      
      // Create marker element
      const el = document.createElement('div');
      el.className = `cg-map-marker ${statusClass}`;
      
      // Create marker
      const marker = new mapboxgl.Marker(el)
        .setLngLat([lng, lat])
        .addTo(this.state.map);
      
      // Add click event to marker
      el.addEventListener('click', () => {
        this.showPropertyPreview(property, marker);
      });
      
      return marker;
    },
    
    showPropertyPreview(property, marker) {
      const props = property.properties || {};
      const id = property.id || '';
      
      // Reset previously selected marker if exists
      if (this.state.selectedMarker) {
        this.state.selectedMarker.getElement().style.width = '16px';
        this.state.selectedMarker.getElement().style.height = '16px';
        this.state.selectedMarker.getElement().style.zIndex = '1';
      }
      
      // Update selected marker
      this.state.selectedMarker = marker;
      marker.getElement().style.width = '20px';
      marker.getElement().style.height = '20px';
      marker.getElement().style.zIndex = '10';
      
      // Get property details
      const title = this.formatListingType(props.hs_listing_type || '');
      const status = this.formatFieldName(props.cg_status || '');
      const statusClass = this.getStatusClass(props.cg_status || '');
      
      // Get price from various fields
      let price = props.cg_listed_package_price || props.hs_price || 
                 props.cg_build_list_price || props.cg_land_release_price || '';
      price = this.formatPrice(price);
      
      // Get property details for preview
      const lotSize = props.hs_lot_size ? `${props.hs_lot_size}m` : '';
      const frontage = props.cg_frontage ? `${props.cg_frontage}m frontage` : '';
      const aspect = props.cg_aspect || '';
      
      // Include address in preview if available
      const address = props.hs_address_1 || '';
      const suburb = props.hs_city || '';
      let locationText = '';
      
      if (address) {
        locationText += address;
      }
      if (suburb) {
        locationText += (locationText ? ', ' : '') + suburb;
      }
      
      // Build details string
      let detailsText = '';
      if (lotSize) detailsText += lotSize;
      if (frontage) detailsText += detailsText ? `  ${frontage}` : frontage;
      if (aspect) detailsText += detailsText ? `  ${aspect}` : aspect;
      
      // Update preview panel
      document.getElementById('preview-title').textContent = title;
      if (locationText) {
        document.getElementById('preview-title').textContent += ` - ${locationText}`;
      }
      
      document.getElementById('preview-status').textContent = status;
      document.getElementById('preview-status').className = `cg-preview-status cg-status-${statusClass}`;
      document.getElementById('preview-price').textContent = price;
      document.getElementById('preview-details').textContent = detailsText;
      
      // Set zoning info
      document.getElementById('preview-zoning-value').textContent = props.cg_zoning || 'Low Density Residential';
      document.getElementById('preview-school-zone').textContent = props.cg_school_zone || 'Local School Zone';
      
      // Update view details button
      document.getElementById('preview-view-btn').onclick = () => {
        window.location.href = `property-detail?id=${id}`;
      };
      
      // Show preview panel
      document.getElementById('map-property-preview').classList.remove('cg-preview-hidden');
    },
    
    clearMapMarkers() {
      this.state.mapMarkers.forEach(marker => marker.remove());
      this.state.mapMarkers = [];
    },
    // ========================
    // Geocoding Functions
    // ========================
    async getMapboxToken() {
      try {
        // Show token loading indicator if needed
        this.log("Fetching map credentials...");
        
        // Cache mechanism - check if we have a valid token already
        if (this.state.mapboxToken && this.state.tokenExpiry > Date.now()) {
          this.log("Using cached map token");
          return this.state.mapboxToken;
        }
        
        // Call the credentials endpoint
        const response = await fetch(CONFIG.mapboxApiEndpoint);
        
        if (!response.ok) {
          throw new Error(`Failed to get map credentials: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.success || !data.token) {
          throw new Error("Invalid credential response");
        }
        
        // Store token and expiry
        this.state.mapboxToken = data.token;
        this.state.tokenExpiry = data.expires || (Date.now() + (4 * 60 * 1000)); // 4 minutes from now as fallback
        
        this.log("Map credentials successfully retrieved");
        return this.state.mapboxToken;
      } catch (error) {
        this.log(`Error retrieving map token: ${error.message}`);
        // Fallback to default token for emergency cases only
        return 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4M29iazA2Z2gycXA4N2pmbDZmangifQ.-g_vE53SD2WrJ6tFX7QHmA';
      }
    },
    
    async geocodeAddress(property) {
      if (!property || !property.properties) {
        return { ...CONFIG.defaultLocation, source: 'default-no-property' };
      }
      
      const props = property.properties;
      const address = props.hs_address_1 || '';
      const suburb = props.hs_city || '';
      const project = props.cg_project || '';
      
      // Create a cache key from address, suburb, and project
      const cacheKey = `${address || ''}_${suburb || ''}_${project || ''}_${props.id || ''}`.toLowerCase().trim();
      
      // Check if we already have cached coordinates
      if (this.state.geocodingCache[cacheKey]) {
        return this.state.geocodingCache[cacheKey];
      }
      
      // Get project coordinates if available
      const projectCenter = project && PROJECT_COORDINATES[project] ? 
        PROJECT_COORDINATES[project] : null;
      
      // FIXED: Always prioritize project coordinates if available
      if (projectCenter) {
        // Create a deterministic offset for visual distribution
        const offset = this.getControlledProjectOffset(property, projectCenter);
        
        // CHANGE: Skip checking existing coordinates and always use project coordinates
        // This is the key change to enforce proximity
        const projectResult = {
          lat: projectCenter.lat + offset.lat,
          lng: projectCenter.lng + offset.lng,
          source: 'project-with-offset'
        };
        
        this.log(`Using project coordinates for "${project}" with deterministic offset`);
        this.state.geocodingCache[cacheKey] = projectResult;
        return projectResult;
      }
      
      // If no project is available, continue with standard geocoding
      
      // Try existing coordinates if available and valid
      if (props.hs_latitude && props.hs_longitude) {
        const lat = parseFloat(props.hs_latitude);
        const lng = parseFloat(props.hs_longitude);
        
        if (!isNaN(lat) && !isNaN(lng) && this.isWithinNSWBounds(lat, lng)) {
          const result = { lat, lng, source: 'existing-no-validation' };
          this.state.geocodingCache[cacheKey] = result;
          return result;
        }
      }
      
      // Try geocoding address if available
      if (address) {
        try {
          // Ensure we have a mapbox token
          if (!this.state.mapboxToken) {
            this.state.mapboxToken = await this.getMapboxToken();
          }
          
          // Build search query combining address and suburb
          const query = this.formatAddress(address, suburb);
          const encodedQuery = encodeURIComponent(query);
          
          // Make request to Mapbox Geocoding API
          const response = await fetch(
            `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedQuery}.json?access_token=${this.state.mapboxToken}&limit=1&country=au&region=au.nsw`
          );
          
          if (!response.ok) {
            throw new Error(`Geocoding failed: ${response.status}`);
          }
          
          const data = await response.json();
          
          // If we have results, check the coordinates
          if (data.features && data.features.length > 0) {
            const coordinates = data.features[0].center; // [lng, lat]
            const geocodedResult = {
              lng: coordinates[0],
              lat: coordinates[1],
              source: 'address-geocoded'
            };
            
            // Validate coordinates are in NSW
            if (this.isWithinNSWBounds(geocodedResult.lat, geocodedResult.lng)) {
              // Address geocoding is valid
              this.state.geocodingCache[cacheKey] = geocodedResult;
              return geocodedResult;
            }
          }
        } catch (error) {
          this.log(`Address geocoding error: ${error.message}`);
        }
      }
      
      // Suburb center if available
      if (suburb && SUBURB_CENTERS[suburb]) {
        const suburbCenter = SUBURB_CENTERS[suburb];
        const offset = this.generateDeterministicOffset(property, 0.0005);
        
        // Add deterministic offset for visual distribution
        const suburbResult = {
          lat: suburbCenter.lat + offset.lat,
          lng: suburbCenter.lng + offset.lng,
          source: 'suburb-with-offset'
        };
        
        this.log(`Using suburb center for "${suburb}" with deterministic offset`);
        this.state.geocodingCache[cacheKey] = suburbResult;
        return suburbResult;
      }
      
      // FALLBACK: Create a deterministic location in the Sydney area
      const offset = this.generateDeterministicOffset(property, 0.003);
      const fallbackResult = {
        lat: CONFIG.defaultLocation.lat + offset.lat,
        lng: CONFIG.defaultLocation.lng + offset.lng,
        source: 'sydney-fallback'
      };
      
      this.log(`Using fallback coordinates for unlocatable property`);
      this.state.geocodingCache[cacheKey] = fallbackResult;
      return fallbackResult;
    },
    
    async processGeocodingQueue() {
      if (this.state.isGeocodingInProgress || this.state.geocodingQueue.length === 0) {
        return;
      }
      
      this.state.isGeocodingInProgress = true;
      
      // Show geocoding status
      const statusContainer = document.getElementById('geocoding-status');
      const progressBar = document.getElementById('geocoding-progress-bar');
      const messageElement = document.getElementById('geocoding-message');
      
      if (statusContainer) statusContainer.style.display = 'block';
      
      const totalItems = this.state.geocodingQueue.length;
      let processedItems = 0;
      
      try {
        // Process items one by one with a small delay
        while (this.state.geocodingQueue.length > 0) {
          const item = this.state.geocodingQueue.shift();
          
          try {
            // Get coordinates using enhanced geocoding
            const coordinates = await this.geocodeAddress(item.property);
            
            // Update property with coordinates
            if (item.property && item.property.properties) {
              item.property.properties.hs_latitude = coordinates.lat.toString();
              item.property.properties.hs_longitude = coordinates.lng.toString();
              
              // Store geocoding source and details for debugging
              if (coordinates.source) {
                item.property.properties._geocoding_source = coordinates.source;
                
                // If we had to use project instead of address, store the distance for debugging
                if (coordinates.originalDistance) {
                  item.property.properties._distance_from_project = coordinates.originalDistance.toFixed(2) + "km";
                }
              }
            }
            
            // Call callback if provided
            if (item.callback) {
              item.callback(coordinates);
            }
          } catch (error) {
            this.log(`Error geocoding item: ${error.message}`);
          }
          
          // Update progress
          processedItems++;
          if (progressBar) {
            progressBar.style.width = `${(processedItems / totalItems) * 100}%`;
          }
          
          if (messageElement) {
            messageElement.textContent = `Geocoding properties... ${processedItems}/${totalItems}`;
          }
          
          // Add small delay to avoid hitting API rate limits
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } finally {
        this.state.isGeocodingInProgress = false;
        
        // Hide geocoding status after a delay
        setTimeout(() => {
          if (statusContainer) statusContainer.style.display = 'none';
        }, 1000);
        
        // Render markers if map is active
        if (this.state.mapInitialized && document.getElementById('map-view-container').style.display !== 'none') {
          this.renderPropertyMarkers();
        }
      }
    },
    
    queuePropertyForGeocoding(property, callback) {
      if (!property || !property.properties) return;
      
      // Add to geocoding queue with property information
      this.state.geocodingQueue.push({
        property,
        callback
      });
      
      // Start processing queue if not already in progress
      if (!this.state.isGeocodingInProgress) {
        this.processGeocodingQueue();
      }
    },
    
    // ========================
    // Helper Functions
    // ========================
    getControlledProjectOffset(property, projectCenter) {
      const props = property.properties || {};
      const id = property.id || '';
      const lot = props.cg_dp_lot || props.cg_mp_lot || '';
      
      // Create deterministic but tiny offset based on lot number
      const offsetMultiplier = 0.00005; // ~5-50 meters
      const seed = (parseInt(id.replace(/\D/g, '') || '0') + 
                  parseInt(lot.replace(/\D/g, '') || '0')) % 1000;
      
      // Create controlled circular pattern around project center
      const angle = (seed / 1000) * (Math.PI * 2); // 0-2 range
      const distance = Math.min(0.00001 + (seed % 10) * 0.000005, offsetMultiplier);
      
      return {
        lat: Math.sin(angle) * distance,
        lng: Math.cos(angle) * distance
      };
    },
    
    generateDeterministicOffset(property, baseMultiplier = 0.0001) {
      const props = property.properties || {};
      
      // Create a string to hash from property details
      const hashSource = [
        props.id || '',
        props.hs_address_1 || '',
        props.cg_dp_lot || '',
        props.cg_mp_lot || ''
      ].join('_');
      
      // Create a hash value
      const hashValue = this.hashString(hashSource);
      
      // Generate sin/cos values for the hash to get a position on a circle
      const angle = hashValue * 2 * Math.PI; // Convert to radians (0-2)
      
      // Calculate distance from center with a cap to avoid too large offsets
      const distance = Math.min(
        0.00005 + (Math.abs(Math.sin(hashValue * 5)) * baseMultiplier),
        baseMultiplier * 0.7
      );
      
      // Calculate offset using polar coordinates
      return {
        lat: Math.sin(angle) * distance,
        lng: Math.cos(angle) * distance
      };
    },
    
    hashString(str) {
      let hash = 0;
      if (!str || str.length === 0) return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash / 100000; // Scale to a reasonable number for use with trig functions
    },
    
    formatAddress(address, suburb) {
      if (!address && !suburb) return '';
      
      let formattedAddress = '';
      
      // Format address if available
      if (address) {
        formattedAddress = address.trim().replace(/,\s*$/, '');
        
        // Add suburb if not already included
        if (!formattedAddress.match(/,/) && !formattedAddress.match(/NSW/i)) {
          formattedAddress += suburb ? `, ${suburb}` : '';
        }
      } else if (suburb) {
        formattedAddress = suburb;
      }
      
      // Ensure NSW, Australia is added
      if (!formattedAddress.match(/NSW/i)) {
        formattedAddress += ', NSW';
      }
      if (!formattedAddress.match(/Australia/i)) {
        formattedAddress += ', Australia';
      }
      
      return formattedAddress;
    },
    
    calculateDistance(point1, point2) {
      if (!point1 || !point2) return Infinity;
      
      const R = 6371; // Earth's radius in km
      const dLat = (point2.lat - point1.lat) * Math.PI / 180;
      const dLng = (point2.lng - point1.lng) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c; // Distance in km
      
      return distance;
    },
    
    isWithinProjectProximity(coordinates, projectCoordinates, thresholdKm = CONFIG.geocodingThreshold) {
      if (!coordinates || !projectCoordinates) return false;
      
      const distance = this.calculateDistance(coordinates, projectCoordinates);
      return distance <= thresholdKm;
    },
    
    isWithinNSWBounds(lat, lng) {
      return (
        lat >= NSW_BOUNDS.south &&
        lat <= NSW_BOUNDS.north &&
        lng >= NSW_BOUNDS.west &&
        lng <= NSW_BOUNDS.east
      );
    },
    
    getMarkerClass(status) {
      if (!status) return 'available';
      
      const statusMap = {
        'cg_available': 'available',
        'cg_under_offer': 'under-offer',
        'cg_hold': 'hold',
        'cg_exclusive': 'exclusive'
      };
      
      return statusMap[status] || 'available';
    },
    
    getStatusClass(status) {
      if (!status) return 'available';
      
      const statusMap = {
        'cg_available': 'available',
        'cg_under_offer': 'under-offer',
        'cg_hold': 'hold',
        'cg_exclusive': 'exclusive'
      };
      
      return statusMap[status] || '';
    },
    
    formatFieldName(fieldName) {
      if (!fieldName) return '';
      return String(fieldName).replace(/^(cg_|hs_)/, '')
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    },
    
    formatListingType(listingType) {
      if (!listingType) return 'Property';
      
      // Convert to string and lowercase for consistent comparison
      const rawType = String(listingType).toLowerCase();
      
      // Remove prefixes like cg_ or hs_
      const cleanType = rawType.replace(/^(cg_|hs_)/, '');
      
      // Handle specific cases
      if (cleanType === 'land') {
        return 'Land';
      }
      
      if (cleanType === 'house' || cleanType.includes('house_and_land') || cleanType.includes('house-and-land')) {
        return 'House and Land';
      }
      
      if (cleanType === 'townhouse') {
        return 'Townhouse';
      }
      
      if (cleanType === 'apartment') {
        return 'Apartment';
      }
      
      // Default case: capitalize first letter of each word
      return cleanType
        .split(/[_\s-]/)  // Split on underscore, space, or hyphen
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    },
    
    formatPrice(price) {
      if (!price) return 'Contact for pricing';
      const numericPrice = String(price).replace(/[^\d.]/g, '');
      if (!numericPrice) return 'Contact for pricing';
      return '$' + parseFloat(numericPrice).toLocaleString();
    },
    
    formatDate(dateValue) {
      if (!dateValue) return 'Not specified';
      
      // Handle different date formats
      let date;
      
      // If it's a timestamp
      if (!isNaN(dateValue)) {
        date = new Date(parseInt(dateValue));
      } else {
        // Try to parse as ISO date
        date = new Date(dateValue);
      }
      
      // Check if date is valid
      if (isNaN(date.getTime())) {
        return dateValue; // Return original if not parseable
      }
      
      // Format the date
      const options = { year: 'numeric', month: 'short', day: 'numeric' };
      return date.toLocaleDateString('en-AU', options);
    },
    
    formatNumber(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    },
    
    // ========================
    // UI Interaction Setup
    // ========================
    initializeUIInteractions() {
      // Toggle filters visibility
      const toggleFiltersBtn = document.getElementById('toggle-filters');
      const toggleText = toggleFiltersBtn.querySelector('.toggle-text');
      const toggleIcon = toggleFiltersBtn.querySelector('i');
      const advancedFilters = [
        document.getElementById('advanced-filters'),
        document.getElementById('advanced-filters-2'),
        document.getElementById('advanced-filters-3')
      ];
      
      // Function to update filter display based on screen size
      const updateFilterDisplay = (filtersVisible) => {
        if (!filtersVisible) return; // Only update if filters are visible
        
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const displayType = isMobile ? 'flex' : 'grid';
        
        advancedFilters.forEach(filterRow => {
          if (filterRow && filterRow.style.display !== 'none') {
            filterRow.style.display = displayType;
          }
        });
      };
      
      // Handle window resize events
      window.addEventListener('resize', () => {
        const filtersVisible = advancedFilters[0].style.display !== 'none';
        updateFilterDisplay(filtersVisible);
      });
      
      toggleFiltersBtn.addEventListener('click', function() {
        const isVisible = advancedFilters[0].style.display !== 'none';
        
        // Check screen width to determine correct display type
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const newDisplay = isVisible ? 'none' : (isMobile ? 'flex' : 'grid');
        
        // Toggle button active state
        if (isVisible) {
          toggleFiltersBtn.classList.remove('active');
        } else {
          toggleFiltersBtn.classList.add('active');
        }
        
        // Toggle all advanced filter rows together
        advancedFilters.forEach(filterRow => {
          if (filterRow) filterRow.style.display = newDisplay;
        });
        
        toggleText.textContent = isVisible ? 'Show All Filters' : 'Hide Filters';
        toggleIcon.className = isVisible ? 'fas fa-chevron-down' : 'fas fa-chevron-up';
      });
      
      // Apply filters button
      document.getElementById('apply-filters').addEventListener('click', () => {
        this.filterProperties();
      });
      
      // Clear filters button
      document.getElementById('clear-filters').addEventListener('click', () => {
        this.clearAllFilters();
      });
      
      // Search button
      document.getElementById('search-button').addEventListener('click', () => {
        const searchInput = document.getElementById('property-search');
        this.state.filters.search = searchInput.value.toLowerCase();
        this.updateActiveFilters();
        this.filterProperties();
      });
      
      // Search input enter key
      document.getElementById('property-search').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          this.state.filters.search = e.target.value.toLowerCase();
          this.updateActiveFilters();
          this.filterProperties();
        }
      });
      
      // Sort selection change
      document.getElementById('sort-by').addEventListener('change', (e) => {
        this.state.currentSort = e.target.value;
        this.sortProperties();
        this.renderProperties();
      });
      
      // Sort direction toggle
      document.getElementById('toggle-direction').addEventListener('click', (e) => {
        this.state.isDescending = !this.state.isDescending;
        
        // Update UI
        const icon = e.currentTarget.querySelector('i');
        const text = e.currentTarget.querySelector('span');
        
        if (this.state.isDescending) {
          icon.className = 'fas fa-sort-amount-down';
          text.textContent = 'Descending';
        } else {
          icon.className = 'fas fa-sort-amount-up';
          text.textContent = 'Ascending';
        }
        
        this.sortProperties();
        this.renderProperties();
      });
      
      // Quick filter buttons
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.addEventListener('click', (e) => {
          // Remove active class from all quick filters and reset their styles
          document.querySelectorAll('.cg-quick-filter').forEach(b => {
            b.classList.remove('active');
            b.style.backgroundColor = '';
            b.style.borderColor = '';
            b.style.color = '';
            b.style.fontWeight = '';
            b.style.boxShadow = '';
          });
          
          // Add active class to clicked button
          e.currentTarget.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          e.currentTarget.style.backgroundColor = '#009688'; // --accent-color
          e.currentTarget.style.borderColor = '#009688'; // --accent-color
          e.currentTarget.style.color = '#ffffff'; // --white
          e.currentTarget.style.fontWeight = '600';
          e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
          
          // Apply the quick filter
          const filterType = e.currentTarget.getAttribute('data-filter');
          this.applyQuickFilter(filterType);
        });
      });
      
      // Toggle between grid and map views
      const gridViewToggle = document.getElementById('grid-view-toggle');
      const mapViewToggle = document.getElementById('map-view-toggle');
      const propertiesContainer = document.getElementById('properties-container');
      const mapViewContainer = document.getElementById('map-view-container');
      
      gridViewToggle.addEventListener('click', () => {
        gridViewToggle.classList.add('active');
        mapViewToggle.classList.remove('active');
        propertiesContainer.style.display = 'block';
        mapViewContainer.style.display = 'none';
      });
      
      mapViewToggle.addEventListener('click', async () => {
        // Switch to map view immediately to show loading state
        mapViewToggle.classList.add('active');
        gridViewToggle.classList.remove('active');
        propertiesContainer.style.display = 'none';
        mapViewContainer.style.display = 'block';
        
        // Initialize map if not already done
        if (!this.state.mapInitialized) {
          try {
            // Use await since initializeMapView is async
            const success = await this.initializeMapView();
            if (success) {
              this.log("Map initialized successfully");
            } else {
              this.log("Map initialization failed");
            }
          } catch (error) {
            this.log(`Error during map initialization: ${error.message}`);
          }
        } else {
          // If the map was previously initialized but needs a refresh
          try {
            this.renderPropertyMarkers();
            
            // Trigger a resize event to ensure map renders correctly
            if (this.state.map) {
              this.state.map.resize();
            }
          } catch (error) {
            this.log(`Error refreshing map: ${error.message}`);
          }
        }
      });
    },
    
    initializeFilters() {
      // Simple select filters
      const simpleFilters = [
        {id: 'project-filter', key: 'project'},
        {id: 'suburb-filter', key: 'suburb'},
        {id: 'neighborhood-filter', key: 'neighborhood'},
        {id: 'listing-type-filter', key: 'listingType'},
        {id: 'status-filter', key: 'status'},
        {id: 'land-shape-filter', key: 'landShape'},
        {id: 'aspect-filter', key: 'aspect'},
        {id: 'title-type-filter', key: 'titleType'},
        {id: 'registration-date-filter', key: 'registrationDate'},
        {id: 'storeys-filter', key: 'storeys'},
        {id: 'car-spaces-filter', key: 'minCarSpaces'}
      ];
      
      simpleFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            if (filter.key === 'minCarSpaces') {
              this.state.filters[filter.key] = e.target.value ? parseInt(e.target.value) : null;
            } else {
              this.state.filters[filter.key] = e.target.value;
            }
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Range filters
      const rangeFilters = [
        {id: 'price-filter', minKey: 'priceMin', maxKey: 'priceMax', label: 'Price'},
        {id: 'land-size-filter', minKey: 'landSizeMin', maxKey: 'landSizeMax', label: 'Land Size'},
        {id: 'build-size-filter', minKey: 'buildSizeMin', maxKey: 'buildSizeMax', label: 'Build Size'},
        {id: 'frontage-filter', minKey: 'frontageMin', maxKey: 'frontageMax', label: 'Frontage'},
        {id: 'depth-filter', minKey: 'depthMin', maxKey: 'depthMax', label: 'Depth'}
      ];
      
      rangeFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            const range = e.target.value.split('-');
            this.state.filters[filter.minKey] = range[0] ? parseInt(range[0]) : null;
            this.state.filters[filter.maxKey] = range[1] ? parseInt(range[1]) : null;
            if (range[0] && range[0].endsWith('+')) {
              this.state.filters[filter.minKey] = parseInt(range[0]);
              this.state.filters[filter.maxKey] = null;
            }
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Minimum value filters
      const minFilters = [
        {id: 'bedrooms-filter', key: 'minBedrooms', label: 'Bedrooms'},
        {id: 'bathrooms-filter', key: 'minBathrooms', label: 'Bathrooms'}
      ];
      
      minFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            this.state.filters[filter.key] = e.target.value ? parseInt(e.target.value) : null;
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Search input with debounce for typing
      const searchInput = document.getElementById('property-search');
      if (searchInput) {
        let debounceTimeout;
        searchInput.addEventListener('input', (e) => {
          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(() => {
            this.state.filters.search = e.target.value.toLowerCase();
            this.updateActiveFilters();
            this.filterProperties();
          }, 300); // 300ms debounce
        });
      }
    },
    
    updateActiveFilters() {
      const container = document.getElementById('active-filters');
      if (!container) return;
      
      // Clear existing filters
      container.innerHTML = '';
      
      // Helper to get select option text
      const getSelectOptionText = (selectId, value) => {
        const select = document.getElementById(selectId);
        if (!select) return value;
        
        const option = Array.from(select.options).find(opt => opt.value === value);
        return option ? option.textContent : (selectId === 'listing-type-filter' ? this.formatListingType(value) : this.formatFieldName(value));
      };
      
      // Check if we have any active filters
      let hasActiveFilters = false;
      
      // Add active filter pills
      if (this.state.filters.search) {
        this.addFilterPill(container, 'Search', `"${this.state.filters.search}"`, () => {
          this.state.filters.search = '';
          document.getElementById('property-search').value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.project) {
        this.addFilterPill(container, 'Project', getSelectOptionText('project-filter', this.state.filters.project), () => {
          this.state.filters.project = '';
          const element = document.getElementById('project-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.suburb) {
        this.addFilterPill(container, 'Suburb', getSelectOptionText('suburb-filter', this.state.filters.suburb), () => {
          this.state.filters.suburb = '';
          const element = document.getElementById('suburb-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.neighborhood) {
        this.addFilterPill(container, 'Neighborhood', getSelectOptionText('neighborhood-filter', this.state.filters.neighborhood), () => {
          this.state.filters.neighborhood = '';
          const element = document.getElementById('neighborhood-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.listingType) {
        this.addFilterPill(container, 'Listing Type', getSelectOptionText('listing-type-filter', this.state.filters.listingType), () => {
          this.state.filters.listingType = '';
          const element = document.getElementById('listing-type-filter');
          if (element) element.value = '';
          
          // Reset the quick filter buttons when removing a listing type filter
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Only filter pill if active
      if (this.state.filters.isLandOnly) {
        this.addFilterPill(container, 'Type', 'Land Only', () => {
          this.state.filters.isLandOnly = false;
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Title Type filter pill showing the display value (Torrens/Community)
      if (this.state.filters.titleType) {
        let displayValue = this.state.filters.titleType;
        if (this.state.filters.titleType === 'cg_torrens') {
          displayValue = 'Torrens';
        } else if (this.state.filters.titleType === 'cg_community') {
          displayValue = 'Community';
        }
        
        this.addFilterPill(container, 'Title Type', displayValue, () => {
          this.state.filters.titleType = '';
          const element = document.getElementById('title-type-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Status filter pill (from Available quick filter)
      if (this.state.filters.status) {
        let displayValue = 'Available';
        if (this.state.filters.status === 'cg_available') {
          displayValue = 'Available';
        } else {
          displayValue = this.formatFieldName(this.state.filters.status);
        }
        
        this.addFilterPill(container, 'Status', displayValue, () => {
          this.state.filters.status = '';
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Registration Date filter pill (from Registered quick filter)
      if (this.state.filters.registrationDate) {
        let displayValue = 'Registered';
        if (this.state.filters.registrationDate === 'registered') {
          displayValue = 'Registered';
        } else {
          displayValue = this.formatFieldName(this.state.filters.registrationDate);
        }
        
        this.addFilterPill(container, 'Registration', displayValue, () => {
          this.state.filters.registrationDate = '';
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Shape filter pill
      if (this.state.filters.landShape) {
        this.addFilterPill(container, 'Land Shape', getSelectOptionText('land-shape-filter', this.state.filters.landShape), () => {
          this.state.filters.landShape = '';
          const element = document.getElementById('land-shape-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Aspect filter pill
      if (this.state.filters.aspect) {
        this.addFilterPill(container, 'Aspect', getSelectOptionText('aspect-filter', this.state.filters.aspect), () => {
          this.state.filters.aspect = '';
          const element = document.getElementById('aspect-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Price Range filter pill
      if (this.state.filters.priceMin || this.state.filters.priceMax) {
        let displayValue = '';
        if (this.state.filters.priceMin && this.state.filters.priceMax) {
          displayValue = `${parseFloat(this.state.filters.priceMin).toLocaleString()} - ${parseFloat(this.state.filters.priceMax).toLocaleString()}`;
        } else if (this.state.filters.priceMin) {
          displayValue = `${parseFloat(this.state.filters.priceMin).toLocaleString()}+`;
        } else if (this.state.filters.priceMax) {
          displayValue = `Up to ${parseFloat(this.state.filters.priceMax).toLocaleString()}`;
        }
        
        this.addFilterPill(container, 'Price', displayValue, () => {
          this.state.filters.priceMin = null;
          this.state.filters.priceMax = null;
          const element = document.getElementById('price-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Bedrooms filter pill
      if (this.state.filters.minBedrooms) {
        this.addFilterPill(container, 'Bedrooms', `${this.state.filters.minBedrooms}+`, () => {
          this.state.filters.minBedrooms = null;
          const element = document.getElementById('bedrooms-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Bathrooms filter pill
      if (this.state.filters.minBathrooms) {
        this.addFilterPill(container, 'Bathrooms', `${this.state.filters.minBathrooms}+`, () => {
          this.state.filters.minBathrooms = null;
          const element = document.getElementById('bathrooms-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Car Spaces filter pill
      if (this.state.filters.minCarSpaces) {
        this.addFilterPill(container, 'Car Spaces', `${this.state.filters.minCarSpaces}+`, () => {
          this.state.filters.minCarSpaces = null;
          const element = document.getElementById('car-spaces-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Size filter pill
      if (this.state.filters.landSizeMin || this.state.filters.landSizeMax) {
        let displayValue = '';
        if (this.state.filters.landSizeMin && this.state.filters.landSizeMax) {
          displayValue = `${this.state.filters.landSizeMin} - ${this.state.filters.landSizeMax}m`;
        } else if (this.state.filters.landSizeMin) {
          displayValue = `${this.state.filters.landSizeMin}m+`;
        } else if (this.state.filters.landSizeMax) {
          displayValue = `Up to ${this.state.filters.landSizeMax}m`;
        }
        
        this.addFilterPill(container, 'Land Size', displayValue, () => {
          this.state.filters.landSizeMin = null;
          this.state.filters.landSizeMax = null;
          const element = document.getElementById('land-size-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Build Size filter pill
      if (this.state.filters.buildSizeMin || this.state.filters.buildSizeMax) {
        let displayValue = '';
        if (this.state.filters.buildSizeMin && this.state.filters.buildSizeMax) {
          displayValue = `${this.state.filters.buildSizeMin} - ${this.state.filters.buildSizeMax}m`;
        } else if (this.state.filters.buildSizeMin) {
          displayValue = `${this.state.filters.buildSizeMin}m+`;
        } else if (this.state.filters.buildSizeMax) {
          displayValue = `Up to ${this.state.filters.buildSizeMax}m`;
        }
        
        this.addFilterPill(container, 'Build Size', displayValue, () => {
          this.state.filters.buildSizeMin = null;
          this.state.filters.buildSizeMax = null;
          const element = document.getElementById('build-size-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Frontage filter pill
      if (this.state.filters.frontageMin || this.state.filters.frontageMax) {
        let displayValue = '';
        if (this.state.filters.frontageMin && this.state.filters.frontageMax) {
          displayValue = `${this.state.filters.frontageMin} - ${this.state.filters.frontageMax}m`;
        } else if (this.state.filters.frontageMin) {
          displayValue = `${this.state.filters.frontageMin}m+`;
        } else if (this.state.filters.frontageMax) {
          displayValue = `Up to ${this.state.filters.frontageMax}m`;
        }
        
        this.addFilterPill(container, 'Frontage', displayValue, () => {
          this.state.filters.frontageMin = null;
          this.state.filters.frontageMax = null;
          const element = document.getElementById('frontage-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Depth filter pill
      if (this.state.filters.depthMin || this.state.filters.depthMax) {
        let displayValue = '';
        if (this.state.filters.depthMin && this.state.filters.depthMax) {
          displayValue = `${this.state.filters.depthMin} - ${this.state.filters.depthMax}m`;
        } else if (this.state.filters.depthMin) {
          displayValue = `${this.state.filters.depthMin}m+`;
        } else if (this.state.filters.depthMax) {
          displayValue = `Up to ${this.state.filters.depthMax}m`;
        }
        
        this.addFilterPill(container, 'Depth', displayValue, () => {
          this.state.filters.depthMin = null;
          this.state.filters.depthMax = null;
          const element = document.getElementById('depth-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Show/hide the filter buttons based on active filters
      document.getElementById('filter-buttons').style.display = hasActiveFilters ? 'flex' : 'none';
    },
    
    // Helper function to reset quick filter buttons
    resetQuickFilters(activeFilterType) {
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.classList.remove('active');
        
        // Reset all inline styles
        btn.style.backgroundColor = '';
        btn.style.borderColor = '';
        btn.style.color = '';
        btn.style.fontWeight = '';
        btn.style.boxShadow = '';
        
        // Apply active class and styles to the specified filter
        if (btn.getAttribute('data-filter') === activeFilterType) {
          btn.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          btn.style.backgroundColor = '#009688'; // --accent-color
          btn.style.borderColor = '#009688'; // --accent-color
          btn.style.color = '#ffffff'; // --white
          btn.style.fontWeight = '600';
          btn.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
        }
      });
    },
    
    addFilterPill(container, label, value, removeCallback) {
      // Create a pill with explicit styling to ensure it appears highlighted
      const pill = document.createElement('div');
      pill.className = 'cg-filter-pill active'; // Add active class by default
      
      // Apply inline styles as a fallback to ensure it's visually highlighted
      // Use the same accent color as defined in CSS variables
      pill.style.backgroundColor = '#009688'; // --accent-color
      pill.style.color = '#ffffff'; // --white
      pill.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
      pill.style.borderColor = '#009688'; // --accent-color
      
      pill.innerHTML = `
        <span><span class="cg-filter-pill-label">${label}:</span> ${value}</span>
        <i class="cg-filter-pill-remove fas fa-times"></i>
      `;
      
      // Store the data attributes for identification
      pill.dataset.filterLabel = label;
      pill.dataset.filterValue = value;
      
      // Enhanced remove callback to reset quick filters
      const enhancedRemoveCallback = () => {
        // Call the original callback
        removeCallback();
        
        // After a small delay, make sure the quick filters are properly updated
        setTimeout(() => {
          // Determine which filter should be active based on current filters
          let activeFilter = 'all';
          if (this.state.filters.status === 'cg_available') {
            activeFilter = 'available';
          } else if (this.state.filters.listingType === 'house') {
            activeFilter = 'house-and-land';
          } else if (this.state.filters.listingType === 'cg_land') {
            activeFilter = 'land-only';
          } else if (this.state.filters.registrationDate === 'registered') {
            activeFilter = 'registered';
          }
          
          // Reset quick filters to the appropriate active state
          this.resetQuickFilters(activeFilter);
        }, 0);
      };
      
      // Replace the original removeCallback with our enhanced version
      pill.querySelector('.cg-filter-pill-remove').addEventListener('click', function(e) {
        // Prevent event bubbling
        e.stopPropagation();
        
        // Call our enhanced callback
        enhancedRemoveCallback();
        
        // Remove this pill directly from the DOM
        pill.remove();
      });
      
      // Ensure active class is applied even after any DOM manipulation
      requestAnimationFrame(() => {
        pill.classList.add('active');
        
        // Double check styling after the browser has rendered
        if (window.getComputedStyle(pill).backgroundColor !== 'rgb(0, 150, 136)') {
          // If not our accent color, force it
          pill.style.backgroundColor = '#009688';
          pill.style.color = '#ffffff';
        }
      });
      
      container.appendChild(pill);
    },
    
    clearAllFilters() {
      // Reset all filter selects
      document.querySelectorAll('.cg-filter-select').forEach(select => {
        select.value = '';
      });
      
      // Clear search
      document.getElementById('property-search').value = '';
      
      // Reset filter object
      for (let key in this.state.filters) {
        if (key === 'search' || key.includes('Min') || key.includes('Max')) {
          this.state.filters[key] = null;
        } else if (key === 'isLandOnly') {
          this.state.filters[key] = false;
        } else {
          this.state.filters[key] = '';
        }
      }
      
      // Clear active filters display
      document.getElementById('active-filters').innerHTML = '';
      
      // Reset quick filters - set "All Properties" as active
      this.resetQuickFilters('all');
      
      // Apply cleared filters
      this.filterProperties();
      
      // Show success toast
      this.showToast('Filters cleared', 'All filters have been reset.', 'success');
    },
    
    applyQuickFilter(filterType) {
      // Clear existing filters
      this.clearAllFilters();
      
      // First, manually set the active class on the appropriate quick filter button
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-filter') === filterType) {
          btn.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          btn.style.backgroundColor = '#009688'; // --accent-color
          btn.style.borderColor = '#009688'; // --accent-color
          btn.style.color = '#ffffff'; // --white
          btn.style.fontWeight = '600';
          btn.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
        }
      });
      
      // Apply specific quick filter
      switch (filterType) {
        case 'available':
          this.state.filters.status = 'cg_available';
          break;
        case 'house-and-land':
          // Set to check for 'house' value in hs_listing_type
          this.state.filters.listingType = 'house';
          break;
        case 'land-only':
          // Set to check for 'cg_land' value in hs_listing_type
          this.state.filters.listingType = 'cg_land';
          break;
        case 'registered':
          this.state.filters.registrationDate = 'registered';
          break;
        case 'all':
        default:
          // All filters are already cleared
          break;
      }
      
      // Update active filters and filter properties
      this.updateActiveFilters();
      this.filterProperties();
      
      // Use requestAnimationFrame to make sure the style is applied after browser rendering
      requestAnimationFrame(() => {
        document.querySelectorAll('.cg-quick-filter').forEach(btn => {
          if (btn.getAttribute('data-filter') === filterType) {
            btn.classList.add('active');
          }
        });
      });
    },
    
    populateFilterOptions() {
      // Get unique values for each filter
      const projects = new Set();
      const statuses = new Set();
      const landShapes = new Set();
      const aspects = new Set();
      const listingTypes = new Set();
      const titleTypes = new Set();
      const neighborhoods = new Set();
      const suburbs = new Set();
      const storeys = new Set();
      
      this.state.allProperties.forEach(property => {
        const props = property.properties || {};
        
        // Add project if available
        if (props.cg_project) {
          projects.add(props.cg_project);
        }
        
        // Add status if available
        if (props.cg_status) {
          statuses.add(props.cg_status);
        }
        
        // Add land shape (formerly type) if available
        if (props.cg_land_type) {
          landShapes.add(props.cg_land_type);
        }
        
        // Add aspect if available
        if (props.cg_aspect) {
          aspects.add(props.cg_aspect);
        }
        
        // Add listing type if available
        if (props.hs_listing_type) {
          listingTypes.add(props.hs_listing_type);
        }
        
        // Add title type if available - note: we handle this explicitly in the UI now
        // with the correct internal values cg_torrens and cg_community
        
        // Add neighborhood if available
        if (props.hs_neighborhood) {
          neighborhoods.add(props.hs_neighborhood);
        }
        
        // Add suburb if available
        if (props.hs_city) {
          suburbs.add(props.hs_city);
        }
        
        // Add storeys if available
        if (props.cg_storeys) {
          storeys.add(props.cg_storeys);
        }
      });
      
      // Populate project filter
      this.populateSelect('project-filter', projects);
      
      // Populate suburb filter
      this.populateSelect('suburb-filter', suburbs);
      
      // Populate neighborhood filter
      this.populateSelect('neighborhood-filter', neighborhoods);
      
      // Populate listing type filter
      this.populateSelect('listing-type-filter', listingTypes);
      
      // Populate status filter
      this.populateSelect('status-filter', statuses);
      
      // Populate land shape filter
      this.populateSelect('land-shape-filter', landShapes);
      
      // Populate aspect filter (keeping the defaults)
      this.populateSelect('aspect-filter', aspects, true);
      
      // We don't populate the Title Type filter as it now has fixed options
      // cg_torrens and cg_community with display values Torrens and Community
    },
    
    populateSelect(selectId, optionsSet, keepDefaults = false) {
      const select = document.getElementById(selectId);
      if (!select) return;
      
      // Keep the first option (e.g., "All Projects")
      const firstOption = select.options[0];
      
      if (!keepDefaults) {
        select.innerHTML = '';
        select.appendChild(firstOption);
      } else {
        // Keep existing options (for predefined selections like title types)
        const existingOptions = Array.from(select.options);
        const existingValues = existingOptions.map(opt => opt.value);
        
        // Filter out values that already exist in the dropdown
        optionsSet = Array.from(optionsSet).filter(value => !existingValues.includes(value));
      }
      
      // Add options to select
      Array.from(optionsSet).sort().forEach(value => {
        const option = document.createElement('option');
        option.value = value;
        
        // Use special formatting for listing types
        if (selectId === 'listing-type-filter') {
          option.textContent = this.formatListingType(value);
        } else {
          option.textContent = this.formatFieldName(value);
        }
        
        select.appendChild(option);
      });
    },
    
    loadSampleData() {
      const sampleData = this.getSampleProperties();
      this.state.allProperties = sampleData;
      this.populateFilterOptions();
      this.filterProperties();
      
      // Add sample data notice
      const existingNotice = document.querySelector('.cg-sample-data-notice');
      if (!existingNotice) {
        const notice = document.createElement('div');
        notice.className = 'cg-sample-data-notice';
        notice.innerHTML = '<i class="fas fa-info-circle"></i> Showing sample property data for NSW suburbs. Live data is currently unavailable.';
        document.querySelector('.container').prepend(notice);
      }
      
      // Show success toast
      this.showToast('Sample Data Loaded', 'Using sample property listings for demonstration.', 'info');
    },
    
    // Get sample properties for NSW suburbs
    getSampleProperties() {
      // Return 12 sample properties with NSW suburbs
      const listingTypes = ['House & Land Package', 'Land Only', 'Townhouse', 'Apartment'];
      const aspects = ['North', 'South', 'East', 'West', 'North East', 'North West', 'South East', 'South West'];
      const titleTypes = ['cg_torrens', 'cg_community', 'cg_torrens', 'cg_torrens'];
      const neighborhoods = ['Valley View', 'Riverside', 'Highland Hills', 'Ocean Breeze'];
      const suburbs = ['Austral', 'Kellyville', 'Leppington', 'Oakville', 'Pitt Town', 'Rouse Hill', 'Vineyard'];
      const streets = [
        '10 Smith Street', 
        '42 Beach Road', 
        '78 Main Street', 
        '15 Park Avenue',
        '25 Harbor View',
        '33 Mountain Drive',
        '55 Sunset Boulevard',
        '18 Riverview Lane',
        '63 Ocean Drive',
        '27 Hillside Crescent',
        '39 Valley Road',
        '84 Lakeside Drive'
      ];
      
      return Array(12).fill().map((_, index) => ({
        id: `sample-${index + 1}`,
        properties: {
          hs_listing_type: listingTypes[index % 4],
          cg_project: ['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4],
          cg_stage: `${Math.floor(index / 4) + 1}`,
          cg_dp_lot: `${index + 101}`,
          cg_mp_lot: `${index + 501}`,
          cg_status: ['cg_available', 'cg_hold', 'cg_under_offer', 'cg_exclusive'][index % 4],
          cg_listed_package_price: (500000 + (index * 50000)).toString(),
          hs_price: (450000 + (index * 45000)).toString(),
          hs_lot_size: (350 + (index * 50)).toString(),
          cg_total_build_size: (180 + (index * 20)).toString(),
          hs_bedrooms: (3 + (index % 3)).toString(),
          hs_bathrooms: (2 + (index % 3)).toString(),
          cg_car: (index % 3 + 1).toString(),
          cg_house_type: ['Single Story', 'Double Story', 'Townhouse', 'Duplex'][index % 4],
          cg_land_type: ['Corner', 'Standard', 'Premium', 'Waterfront'][index % 4],
          cg_facade: ['Modern', 'Contemporary', 'Traditional', 'Hampton'][index % 4],
          cg_aspect: aspects[index % 8],
          cg_title: titleTypes[index % 4],
          cg_frontage: (10 + (index % 15)).toString(),
          cg_depth: (25 + (index % 20)).toString(),
          cg_registration_date: new Date(2024, 5 + (index % 12), 15 + (index % 10)).toISOString().split('T')[0],
          cg_storeys: (1 + (index % 3)).toString(),
          hs_neighborhood: neighborhoods[index % 4],
          hs_city: suburbs[index % suburbs.length],
          // NSW-specific address
          hs_address_1: `${streets[index % streets.length]}, ${suburbs[index % suburbs.length]}`,
          // Added fields for residential lots enhancement
          cg_zoning: 'Low Density Residential',
          cg_school_zone: ['North High School', 'South Primary School', 'West Heights School', 'East Valley School'][index % 4],
          // Added the cg_land field for Land Only properties (for every other property)
          cg_land: index % 2 === 0 ? 'true' : '', 
          // Generate coordinates for sample data using project coordinates if available
          hs_latitude: PROJECT_COORDINATES[['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4]]?.lat + (Math.sin(index) * 0.0005) || 
                     (SUBURB_CENTERS[suburbs[index % suburbs.length]].lat + (Math.random() - 0.5) * 0.01),
          hs_longitude: PROJECT_COORDINATES[['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4]]?.lng + (Math.cos(index) * 0.0005) || 
                      (SUBURB_CENTERS[suburbs[index % suburbs.length]].lng + (Math.random() - 0.5) * 0.01)
        }
      }));
    },
    
    // ========================
    // Favorites & Compare
    // ========================
    toggleFavorite(propertyId, button) {
      const isFavorite = this.state.favorites.includes(propertyId);
      
      if (isFavorite) {
        // Remove from favorites
        this.state.favorites = this.state.favorites.filter(id => id !== propertyId);
        button.classList.remove('active');
        button.querySelector('i').className = 'far fa-heart';
        this.showToast('Removed from favorites', 'Property removed from your favorites.', 'info');
      } else {
        // Add to favorites
        this.state.favorites.push(propertyId);
        button.classList.add('active');
        button.querySelector('i').className = 'fas fa-heart';
        this.showToast('Added to favorites', 'Property saved to your favorites.', 'success');
      }
      
      // Save to localStorage
      localStorage.setItem('cg-favorites', JSON.stringify(this.state.favorites));
    },
    
    toggleCompare(propertyId, button) {
      // Find the property in the full list
      const property = this.state.allProperties.find(p => p.id === propertyId);
      if (!property) return;
      
      const isInCompare = this.state.compareProperties.some(p => p.id === propertyId);
      
      if (isInCompare) {
        // Remove from compare
        this.state.compareProperties = this.state.compareProperties.filter(p => p.id !== propertyId);
        button.classList.remove('active');
        this.showToast('Removed from comparison', 'Property removed from comparison list.', 'info');
      } else {
        // Check if we already have 4 properties in compare
        if (this.state.compareProperties.length >= 4) {
          this.showToast('Maximum reached', 'You can compare up to 4 properties at once.', 'warning');
          return;
        }
        
        // Add to compare
        this.state.compareProperties.push(property);
        button.classList.add('active');
        this.showToast('Added to comparison', 'Property added to comparison list.', 'success');
      }
      
      // Update compare drawer
      this.updateCompareDrawer();
    },
    
    initCompareDrawer() {
      const drawer = document.getElementById('compare-drawer');
      const closeBtn = document.getElementById('compare-close');
      const compareBtn = document.getElementById('compare-btn');
      
      // Close the compare drawer
      closeBtn.addEventListener('click', () => {
        drawer.classList.remove('active');
      });
      
      // Open the compare page
      compareBtn.addEventListener('click', () => {
        if (this.state.compareProperties.length < 2) return;
        
        // In a real implementation, we would navigate to a compare page
        // For now, just show a toast
        this.showToast('Feature in Development', 'The comparison page is coming soon!', 'info');
      });
    },
    
    updateCompareDrawer() {
      const drawer = document.getElementById('compare-drawer');
      const compareCount = document.getElementById('compare-count');
      const compareItems = document.getElementById('compare-items');
      const compareBtn = document.getElementById('compare-btn');
      
      // Update the count
      compareCount.textContent = this.state.compareProperties.length;
      
      // Enable/disable the compare button
      if (this.state.compareProperties.length >= 2) {
        compareBtn.removeAttribute('disabled');
      } else {
        compareBtn.setAttribute('disabled', 'disabled');
      }
      
      // Update the items
      compareItems.innerHTML = '';
      
      this.state.compareProperties.forEach(property => {
        const props = property.properties || {};
        const id = property.id || '';
        
        // Get property details
        const title = this.formatListingType(props.hs_listing_type || '');
        const lotSize = props.hs_lot_size || '';
        const bedrooms = props.hs_bedrooms || '';
        const bathrooms = props.hs_bathrooms || '';
        
        // Get price
        let price = props.cg_listed_package_price || props.hs_price || 
                   props.cg_build_list_price || props.cg_land_release_price || '';
        price = this.formatPrice(price);
        
        // Create item element
        const item = document.createElement('div');
        item.className = 'cg-compare-item';
        item.innerHTML = `
          <button type="button" class="cg-compare-remove" data-id="${id}"></button>
          <div class="cg-compare-details">
            <div class="cg-compare-name">${title}</div>
            <div class="cg-compare-price">${price}</div>
            <div class="cg-compare-specs">
              ${lotSize ? `${lotSize}m  ` : ''}${bedrooms ? `${bedrooms} bed  ` : ''}${bathrooms ? `${bathrooms} bath` : ''}
            </div>
          </div>
        `;
        
        // Add item to container
        compareItems.appendChild(item);
        
        // Add remove event listener
        item.querySelector('.cg-compare-remove').addEventListener('click', (e) => {
          const propertyId = e.currentTarget.getAttribute('data-id');
          
          // Remove from compare list
          this.state.compareProperties = this.state.compareProperties.filter(p => p.id !== propertyId);
          
          // Update the UI
          this.updateCompareDrawer();
          
          // Update compare button on property card
          const compareBtn = document.querySelector(`.cg-compare-badge[data-id="${propertyId}"]`);
          if (compareBtn) {
            compareBtn.classList.remove('active');
          }
          
          // Show toast
          this.showToast('Removed from comparison', 'Property removed from comparison list.', 'info');
        });
      });
      
      // Show/hide drawer based on whether we have properties to compare
      if (this.state.compareProperties.length > 0) {
        drawer.classList.add('active');
      } else {
        drawer.classList.remove('active');
      }
    },
    
    // ========================
    // Quick View
    // ========================
    initQuickView() {
      const modal = document.getElementById('quick-view-modal');
      const closeBtn = document.getElementById('modal-close');
      const closeBtnFooter = document.getElementById('modal-close-btn');
      
      // Close modal when the X button is clicked
      closeBtn.addEventListener('click', () => {
        modal.classList.remove('active');
      });
      
      // Close modal when the Close button is clicked
      closeBtnFooter.addEventListener('click', () => {
        modal.classList.remove('active');
      });
      
      // Close modal when clicking outside the content
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('active');
        }
      });
      
      // Close modal when pressing Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
          modal.classList.remove('active');
        }
      });
    },
    
    openQuickView(propertyId) {
      // Find the property in the full list
      const property = this.state.allProperties.find(p => p.id === propertyId);
      if (!property) return;
      
      const props = property.properties || {};
      
      // Update modal title and content
      document.getElementById('modal-title').textContent = this.formatListingType(props.hs_listing_type || '');
      
      // TODO: Add more detailed property information here
      
      // Set the view details button URL
      document.getElementById('modal-view-details').onclick = () => {
        window.location.href = `property-detail?id=${propertyId}`;
      };
      
      // Show the modal
      document.getElementById('quick-view-modal').classList.add('active');
    },
    
    // ========================
    // Toast System
    // ========================
    initToastSystem() {
      // Nothing to initialize here, just creating the structure
    },
    
    showToast(title, message, type = 'info', duration = 3000) {
      const container = document.getElementById('toast-container');
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `cg-toast cg-toast-${type}`;
      
      // Set toast content
      toast.innerHTML = `
        <div class="cg-toast-icon">
          <i class="fas fa-${this.getToastIcon(type)}"></i>
        </div>
        <div class="cg-toast-content">
          <div class="cg-toast-title">${title}</div>
          <div class="cg-toast-message">${message}</div>
        </div>
        <button class="cg-toast-close"></button>
      `;
      
      // Add toast to container
      container.appendChild(toast);
      
      // Add close event listener
      toast.querySelector('.cg-toast-close').addEventListener('click', () => {
        this.closeToast(toast);
      });
      
      // Automatically remove toast after duration
      setTimeout(() => {
        if (toast.parentNode === container) {
          this.closeToast(toast);
        }
      }, duration);
    },
    
    closeToast(toast) {
      toast.classList.add('exit');
      
      // Remove from DOM after animation completes
      toast.addEventListener('animationend', () => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      });
    },
    
    getToastIcon(type) {
      switch (type) {
        case 'success':
          return 'check';
        case 'error':
          return 'times';
        case 'warning':
          return 'exclamation';
        case 'info':
        default:
          return 'info';
      }
    },
    
    // ========================
    // Utility Functions
    // ========================
    log(message) {
      console.log(`[CastleGroup] ${message}`);
      
      if (CONFIG.debugMode) {
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
          const div = document.createElement('div');
          div.textContent = message;
          debugInfo.appendChild(div);
          debugInfo.scrollTop = debugInfo.scrollHeight;
        }
      }
    },
    
    handleSearchSticky() {
      const searchWrapper = document.getElementById('cg-search-wrapper');
      if (!searchWrapper) return;
      
      if (window.scrollY > 100) {
        searchWrapper.classList.add('cg-search-sticky');
      } else {
        searchWrapper.classList.remove('cg-search-sticky');
      }
    }
  };
  
  // Initialize the app
  CastleApp.init();
});
</script>
<script>
  // Simple user state management
  function saveUserData(data) {
    localStorage.setItem('cg-user', JSON.stringify(data));
  }
  
  function getUserData() {
    try {
      const data = localStorage.getItem('cg-user');
      return data ? JSON.parse(data) : null;
    } catch (e) {
      console.error('Error reading user data:', e);
      return null;
    }
  }
  
  // Function to show the listings
  function showListings() {
    document.getElementById('auth-overlay').style.display = 'none';
    document.getElementById('listings-container').style.display = 'block';
  }
  
  // Check if user is already authenticated
  function checkAuthentication() {
    const userData = getUserData();
    if (userData && userData.authenticated) {
      showListings();
    }
  }
  
  // Handle HubSpot form submission
  window.addEventListener('message', function(event) {
    // Check if it's a form submission message from HubSpot
    if (event.data && (
      (typeof event.data === 'string' && (event.data.includes('hsFormCallback') || event.data.includes('formSubmitted'))) ||
      (event.data.type === 'hsFormCallback' && event.data.eventName === 'onFormSubmitted')
    )) {
      console.log('Form submission detected');
      
      // Get the form data if possible
      let email = '';
      try {
        const hubspotForm = document.getElementById('hubspot-form');
        const iframeDocument = hubspotForm.contentDocument || hubspotForm.contentWindow.document;
        const emailInput = iframeDocument.querySelector('input[name="email"]');
        if (emailInput) {
          email = emailInput.value;
        }
      } catch (e) {
        console.error('Could not extract email from form:', e);
      }
      
      // Save authentication state
      const userData = getUserData() || {};
      userData.email = email || userData.email || '';
      userData.authenticated = true;
      userData.needsVerification = true;
      saveUserData(userData);
      
      // Show the confirmation message
      document.getElementById('hubspot-form').style.display = 'none';
      document.getElementById('confirmation-message').style.display = 'block';
    }
  });
  
  // Setup the access now button
  document.getElementById('access-now-btn').addEventListener('click', function() {
    showListings();
  });
  
  // Check authentication status on page load
  document.addEventListener('DOMContentLoaded', function() {
    checkAuthentication();
  });
  
  // Add tracking for favorites
  function trackPropertyInterest(propertyTitle, propertyId, interactionType = 'favorite') {
    const userData = getUserData() || {
      listings_of_interest: [],
      projects_of_interest: []
    };
    
    if (interactionType === 'unfavorite') {
      // Remove from listings of interest
      userData.listings_of_interest = (userData.listings_of_interest || []).filter(
        item => item !== propertyTitle
      );
    } else {
      // Add to listings if not already present
      if (!userData.listings_of_interest) {
        userData.listings_of_interest = [];
      }
      
      if (!userData.listings_of_interest.includes(propertyTitle)) {
        userData.listings_of_interest.push(propertyTitle);
      }
    }
    
    // Save updated user data
    saveUserData(userData);
  }
  
  // Hook into CastleApp if it exists
  if (typeof window.CastleApp !== 'undefined') {
    // Hook into favorite toggling if available
    if (typeof CastleApp.toggleFavorite === 'function') {
      const originalToggleFavorite = CastleApp.toggleFavorite;
      CastleApp.toggleFavorite = function(propertyId, button) {
        // Get current state
        const wasAlreadyFavorite = this.state.favorites.includes(propertyId);
        
        // Call original function
        originalToggleFavorite.call(this, propertyId, button);
        
        // Check new state
        const isNowFavorite = this.state.favorites.includes(propertyId);
        
        // Find the property
        const property = this.state.allProperties.find(p => p.id === propertyId) || {};
        const propertyTitle = property.title || property.name || `Property ${propertyId}`;
        
        // Track the interest
        if (isNowFavorite && !wasAlreadyFavorite) {
          trackPropertyInterest(propertyTitle, propertyId, 'favorite');
        } else if (!isNowFavorite && wasAlreadyFavorite) {
          trackPropertyInterest(propertyTitle, propertyId, 'unfavorite');
        }
      };
    }
  }
</script>
</body>
</html>