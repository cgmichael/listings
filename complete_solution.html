<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Property Listings</title>
  
  <!-- HubSpot Tracking Code -->
  <script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/24160521.js"></script>
  
  <!-- HubSpot Forms API -->
  <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap">
  <!-- Mapbox GL JS for map integration -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-color: #bf9959;
      --secondary-color: #ff6b4a;
      --accent-color: #009688;
      --accent-light: #b2dfdb;
      --accent-dark: #134F5C;
      --light-bg: #ffffff;
      --white: #ffffff;
      --dark-text: #1e293b;
      --medium-text: #334155;
      --light-text: #64748b;
      --border-color: #e2e8f0;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.07), 0 1px 3px rgba(0,0,0,0.08);
      --shadow-lg: 0 10px 15px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.05);
      --transition-normal: all 0.3s ease;
      --transition-fast: all 0.2s ease;
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --spacing-xl: 32px;
    }
    
    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      color: var(--dark-text);
      line-height: 1.6;
      background-color: var(--light-bg);
      font-size: 16px;
    }
    
    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: var(--spacing-xl) var(--spacing-md);
    }
    
    /* HubSpot Form Styles */
    .hubspot-form-wrapper {
      background-color: #f8f8f8;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .hubspot-form-wrapper h3 {
      margin-bottom: 15px;
      font-size: 18px;
      color: #333;
    }
    
    /* Authentication Overlay */
    .auth-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.95);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .auth-container {
      background-color: white;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      max-width: 600px;
      width: 100%;
      text-align: center;
    }
    
    .auth-container h2 {
      margin-bottom: 20px;
      color: #333;
    }
    
    .auth-container p {
      margin-bottom: 25px;
      line-height: 1.6;
      color: #666;
    }
    
    /* Hide listings container until authenticated */
    .hidden-until-auth {
      display: none;
    }
    
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Montserrat', sans-serif;
      color: var(--dark-text);
      font-weight: 600;
      line-height: 1.3;
    }
    
    a {
      color: var(--primary-color);
      text-decoration: none;
      transition: var(--transition-fast);
    }
    
    a:hover {
      color: var(--accent-color);
    }
    
    button {
      cursor: pointer;
      font-family: 'Roboto', sans-serif;
    }
    
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }
    
    /* Header and Castle Group branding */
    .cg-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-logo {
      width: 240px;
      height: auto;
      max-width: 100%;
    }
    
    .cg-tagline {
      font-family: 'Montserrat', sans-serif;
      font-size: 14px;
      color: var(--light-text);
      font-style: italic;
    }
    
    .cg-page-title {
      font-size: 2.5rem;
      margin-bottom: var(--spacing-lg);
      color: var(--primary-color);
    }
    
    .cg-section-title {
      font-size: 1.25rem;
      margin-bottom: var(--spacing-md);
      color: var(--dark-text);
    }
    
    /* Top search bar and filters */
    .cg-search-wrapper {
      position: sticky;
      top: 0;
      z-index: 100;
      background-color: var(--white);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
      transition: var(--transition-normal);
    }
    
    .cg-search-sticky {
      box-shadow: var(--shadow-lg);
    }
    
    .cg-quick-search {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }
    
    .cg-search-input-wrapper {
      position: relative;
      flex-grow: 1;
    }
    
    .cg-search-input {
      width: 100%;
      padding: 12px 16px 12px 42px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      font-size: 16px;
      transition: var(--transition-fast);
    }
    
    .cg-search-input:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--light-text);
      pointer-events: none;
    }
    
    .cg-search-btn {
      background-color: var(--secondary-color);
      color: var(--white);
      border: none;
      border-radius: var(--radius-md);
      padding: 12px 24px;
      font-weight: 500;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      transition: var(--transition-fast);
    }
    
    .cg-search-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-quick-filters {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-md);
    }
    
    .cg-quick-filter {
      background-color: var(--white);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 6px 16px;
      font-size: 14px;
      font-weight: 500;
      color: var(--medium-text);
      transition: var(--transition-fast);
    }
    
    .cg-quick-filter:hover {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-quick-filter.active,
    button.cg-quick-filter.active {
      background-color: var(--accent-color) !important;
      border-color: var(--accent-color) !important;
      color: var(--white) !important;
      font-weight: 600 !important;
      box-shadow: var(--shadow-sm) !important;
    }
    
    /* Filter panel */
    .cg-filter-panel {
      background-color: var(--white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-filter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-filter-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--dark-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-filter-toggle {
      background: none;
      border: none;
      color: var(--accent-color);
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      transition: var(--transition-fast);
    }
    
    .cg-filter-toggle:hover {
      color: var(--accent-dark);
    }
    
    .cg-filter-toggle.active {
      color: var(--accent-dark);
      background-color: var(--accent-light);
      padding: 6px 12px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
    }
    
    .cg-filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--spacing-lg);
    }
    
    .cg-filter-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }
    
    .cg-filter-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    .cg-filter-select {
      appearance: none;
      background-color: var(--white);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 10px 36px 10px 16px;
      font-size: 16px;
      color: var(--dark-text);
      transition: var(--transition-fast);
      width: 100%;
    }
    
    .cg-filter-select:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-filter-buttons {
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      margin-top: var(--spacing-xl);
    }
    
    .cg-btn-clear {
      background-color: var(--light-bg);
      color: var(--medium-text);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-btn-clear:hover {
      background-color: var(--border-color);
    }
    
    .cg-btn-apply {
      background-color: var(--primary-color);
      color: var(--white);
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-btn-apply:hover {
      background-color: var(--accent-color);
    }
    
    /* Active Filters */
    .cg-active-filters {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-lg);
    }
    
    .cg-filter-pill {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--accent-light);
      border-radius: 20px;
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 500;
      color: var(--accent-dark);
      transition: var(--transition-fast);
      cursor: pointer;
    }
    
    .cg-filter-pill.active,
    .cg-filter-pill.selected,
    div.cg-filter-pill.active {
      background-color: var(--accent-color) !important;
      color: var(--white) !important;
      box-shadow: var(--shadow-sm) !important;
      border-color: var(--accent-color) !important;
    }
    
    .cg-filter-pill-label {
      font-weight: 600;
      margin-right: 4px;
    }
    
    .cg-filter-pill-remove {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      background-color: var(--accent-dark);
      color: var(--white);
      border-radius: 50%;
      font-size: 10px;
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-filter-pill-remove:hover {
      background-color: var(--dark-text);
    }
    
    /* View toggle and sorting */
    .cg-view-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-view-toggle {
      display: flex;
      gap: 1px;
      background-color: var(--border-color);
      border-radius: var(--radius-md);
      padding: 2px;
    }
    
    .cg-view-btn {
      background: none;
      border: none;
      padding: 8px 16px;
      font-size: 15px;
      font-weight: 500;
      color: var(--medium-text);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      border-radius: var(--radius-sm);
      transition: var(--transition-fast);
    }
    
    .cg-view-btn.active {
      background-color: var(--white);
      color: var(--primary-color);
      box-shadow: var(--shadow-sm);
    }
    
    .cg-sort-controls {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }
    
    .cg-sort-label {
      font-size: 15px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    .cg-sort-select {
      appearance: none;
      background-color: var(--white);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 8px 36px 8px 16px;
      font-size: 15px;
      color: var(--dark-text);
      min-width: 180px;
      transition: var(--transition-fast);
    }
    
    .cg-sort-select:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.2);
    }
    
    .cg-sort-direction {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      background-color: var(--white);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 8px 16px;
      font-size: 15px;
      color: var(--medium-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-sort-direction:hover {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-sort-direction i {
      color: var(--accent-color);
    }
    
    /* Property Grid */
    .cg-properties-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-xl);
    }
    
    /* Property Card */
    .cg-property-card {
      background-color: var(--white);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      transition: var(--transition-normal);
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    
    .cg-property-card:hover {
      transform: translateY(-8px);
      box-shadow: var(--shadow-lg);
    }
    
    .cg-property-link {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      text-decoration: none;
      color: inherit;
    }
    
    .cg-property-header {
      padding: var(--spacing-md);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    }
    
    .cg-property-status {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .cg-status-available {
      background-color: #10b981;
      color: white;
    }
    
    .cg-status-under-offer {
      background-color: #f59e0b;
      color: white;
    }
    
    .cg-status-hold {
      background-color: #fbbf24;
      color: #1e293b;
    }
    
    .cg-status-exclusive {
      background-color: #8b5cf6;
      color: white;
    }
    
    .cg-property-price {
      font-size: 18px;
      font-weight: 700;
      color: var(--dark-text);
    }
    
    .cg-property-content {
      padding: var(--spacing-lg);
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    
    .cg-property-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: var(--spacing-sm);
      color: var(--primary-color);
    }
    
    .cg-property-location {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      color: var(--medium-text);
      font-size: 15px;
    }
    
    .cg-property-location i {
      color: var(--accent-color);
    }
    
    .cg-property-meta {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      font-size: 14px;
      color: var(--medium-text);
    }
    
    .cg-meta-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-meta-item i {
      color: var(--accent-color);
      width: 16px;
      text-align: center;
    }
    
    .cg-meta-label {
      font-weight: 500;
      margin-right: 4px;
    }
    
    .cg-registration-date {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      padding: 6px 12px;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      background-color: #e6fffa;
      color: #0d9488;
    }
    
    .cg-title-type-badge {
      position: absolute;
      top: 60px;
      right: 0;
      background-color: var(--secondary-color);
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 4px 12px;
      border-top-left-radius: var(--radius-md);
      border-bottom-left-radius: var(--radius-md);
      z-index: 2;
    }
    
    .cg-new-badge {
      position: absolute;
      top: 16px;
      right: 16px;
      background-color: #10b981;
      color: white;
      font-size: 12px;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 16px;
      z-index: 2;
    }
    
    .cg-property-specs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--spacing-md);
      padding: var(--spacing-md) 0;
      margin: var(--spacing-md) 0;
      border-top: 1px solid var(--border-color);
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-spec-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    
    .cg-spec-icon {
      color: var(--accent-color);
      margin-bottom: 4px;
      font-size: 20px;
    }
    
    .cg-spec-value {
      font-weight: 600;
      font-size: 18px;
      color: var(--dark-text);
      margin-bottom: 2px;
    }
    
    .cg-spec-label {
      font-size: 13px;
      color: var(--light-text);
    }
    
    .cg-property-details {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-lg);
    }
    
    .cg-detail-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 14px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-detail-row:last-child {
      border-bottom: none;
    }
    
    .cg-detail-label {
      font-weight: 500;
      color: var(--light-text);
    }
    
    .cg-detail-value {
      font-weight: 600;
      color: var(--dark-text);
    }
    
    .cg-property-cta {
      margin-top: auto;
      background-color: var(--primary-color);
      color: white;
      text-align: center;
      padding: 12px;
      border-radius: var(--radius-md);
      font-weight: 600;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .cg-property-cta:hover {
      background-color: var(--accent-color);
    }
    
    .cg-lot-size-badge {
      display: inline-block;
      padding: 4px 8px;
      background-color: #e6fffa;
      color: #0d9488;
      border-radius: var(--radius-sm);
      font-size: 12px;
      font-weight: 600;
      margin-top: 6px;
    }
    
    .cg-zoning-info {
      margin-top: var(--spacing-md);
      padding: var(--spacing-md);
      background-color: #f0f9ff;
      border-radius: var(--radius-md);
      font-size: 14px;
    }
    
    .cg-school-zone {
      display: inline-block;
      margin-top: 5px;
      padding: 3px 8px;
      background-color: #dbeafe;
      color: #3b82f6;
      border-radius: var(--radius-sm);
      font-size: 12px;
    }
    
    /* Map View */
    .cg-map-container {
      position: relative;
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-property-map {
      height: 650px;
      width: 100%;
    }
    
    .cg-map-controls {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .cg-map-btn {
      background-color: white;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      padding: 8px 12px;
      font-size: 14px;
      font-weight: 500;
      box-shadow: var(--shadow-sm);
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-map-btn:hover {
      background-color: var(--light-bg);
    }
    
    .cg-map-btn.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }
    
    .cg-map-preview {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 320px;
      background-color: white;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      z-index: 10;
      overflow: hidden;
      transform: translateY(0);
      transition: transform 0.3s ease;
    }
    
    .cg-preview-hidden {
      transform: translateY(calc(100% + 24px));
    }
    
    .cg-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background-color: var(--light-bg);
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-preview-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--dark-text);
      margin: 0;
    }
    
    .cg-preview-close {
      background: none;
      border: none;
      font-size: 20px;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-preview-close:hover {
      color: var(--dark-text);
    }
    
    .cg-preview-content {
      padding: 16px;
    }
    
    .cg-preview-status {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    
    .cg-preview-price {
      font-size: 20px;
      font-weight: 700;
      color: var(--dark-text);
      margin-bottom: 12px;
    }
    
    .cg-preview-details {
      font-size: 14px;
      color: var(--medium-text);
      margin-bottom: 16px;
    }
    
    .cg-preview-zoning {
      padding: 12px;
      background-color: #f0f9ff;
      border-radius: var(--radius-md);
      font-size: 13px;
      color: var(--medium-text);
      margin-bottom: 16px;
    }
    
    .cg-preview-btn {
      width: 100%;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 12px;
      font-size: 15px;
      font-weight: 600;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .cg-preview-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-map-marker {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    
    .cg-map-marker:hover, .cg-map-marker.active {
      transform: scale(1.3);
      box-shadow: 0 3px 6px rgba(0,0,0,0.4);
      z-index: 10 !important;
    }
    
    .cg-marker-available {
      background-color: #10b981;
    }
    
    .cg-marker-under-offer {
      background-color: #f59e0b;
    }
    
    .cg-marker-hold {
      background-color: #fbbf24;
    }
    
    .cg-marker-exclusive {
      background-color: #8b5cf6;
    }
    
    .cg-map-disclaimer {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 12px;
      max-width: 300px;
      z-index: 5;
      box-shadow: var(--shadow-sm);
      color: var(--medium-text);
    }
    
    .mapboxgl-popup-content {
      padding: 0;
      border-radius: var(--radius-md);
      overflow: hidden;
      box-shadow: var(--shadow-lg);
    }
    
    .mapboxgl-popup-close-button {
      font-size: 18px;
      color: var(--light-text);
      padding: 6px;
      right: 6px;
      top: 6px;
    }
    
    .cg-popup-content {
      padding: 12px;
    }
    
    .cg-popup-title {
      font-weight: 600;
      margin-bottom: 5px;
      color: var(--dark-text);
      font-size: 14px;
    }
    
    .cg-popup-price {
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 8px;
      font-size: 15px;
    }
    
    .cg-popup-details {
      font-size: 12px;
      margin-bottom: 8px;
      color: var(--medium-text);
    }
    
    .cg-popup-status {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 10px;
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    
    /* Loading State */
    .cg-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 0;
      text-align: center;
    }
    
    .cg-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(0, 150, 136, 0.2);
      border-radius: 50%;
      border-top-color: var(--accent-color);
      animation: cg-spin 1s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes cg-spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    .cg-loading-text {
      font-size: 18px;
      font-weight: 500;
      color: var(--medium-text);
    }
    
    /* Skeleton loading */
    .cg-skeleton {
      background-color: #e2e5e7;
      background-image: 
        linear-gradient(
          90deg, 
          rgba(255, 255, 255, 0), 
          rgba(255, 255, 255, 0.5),
          rgba(255, 255, 255, 0)
        );
      background-size: 200px 100%;
      background-repeat: no-repeat;
      background-position: left -40px top 0;
      animation: cg-shine 1.5s ease infinite;
      border-radius: var(--radius-sm);
    }
    
    @keyframes cg-shine {
      to {
        background-position: right -40px top 0;
      }
    }
    
    /* Error and No Results */
    .cg-error-container, .cg-no-results {
      text-align: center;
      padding: 40px 24px;
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-xl);
    }
    
    .cg-error-container {
      background-color: #fee2e2;
      border: 1px solid #fecaca;
    }
    
    .cg-no-results {
      background-color: var(--light-bg);
      border: 1px solid var(--border-color);
    }
    
    .cg-error-title, .cg-no-results-title {
      font-size: 24px;
      margin-bottom: var(--spacing-md);
    }
    
    .cg-error-title {
      color: #dc2626;
    }
    
    .cg-error-message, .cg-no-results-message {
      font-size: 16px;
      margin-bottom: var(--spacing-lg);
      color: var(--medium-text);
    }
    
    .cg-error-buttons {
      display: flex;
      justify-content: center;
      gap: var(--spacing-md);
    }
    
    .cg-error-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 16px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-error-btn:hover {
      background-color: var(--accent-color);
    }
    
    .cg-error-btn.secondary {
      background-color: white;
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
    }
    
    .cg-error-btn.secondary:hover {
      background-color: var(--light-bg);
    }
    
    /* Pagination */
    .cg-pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--spacing-sm);
      margin: var(--spacing-xl) 0;
    }
    
    .cg-pagination-btn {
      min-width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border-color);
      background-color: white;
      color: var(--medium-text);
      border-radius: var(--radius-md);
      font-size: 15px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-pagination-btn:hover:not(:disabled) {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }
    
    .cg-pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .cg-pagination-btn.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }
    
    .cg-pagination-ellipsis {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 40px;
      padding: 0 12px;
      color: var(--medium-text);
      font-weight: 500;
    }
    
    /* Results Count */
    .cg-results-count {
      margin-top: var(--spacing-md);
      font-size: 14px;
      color: var(--medium-text);
      text-align: center;
    }
    
    /* Sample Data Notice */
    .cg-sample-data-notice {
      background-color: var(--accent-light);
      border: 1px solid #b2dfdb;
      color: var(--accent-dark);
      padding: 12px 16px;
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
    }
    
    .cg-sample-data-notice i {
      font-size: 18px;
    }
    
    /* Quick View Modal */
    .cg-quick-view-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .cg-quick-view-modal.active {
      opacity: 1;
      visibility: visible;
    }
    
    .cg-modal-content {
      background-color: white;
      border-radius: var(--radius-lg);
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
      transform: translateY(20px);
      transition: transform 0.3s ease;
    }
    
    .cg-quick-view-modal.active .cg-modal-content {
      transform: translateY(0);
    }
    
    .cg-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .cg-modal-title {
      font-size: 22px;
      font-weight: 600;
      color: var(--dark-text);
      margin: 0;
    }
    
    .cg-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--light-text);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    
    .cg-modal-close:hover {
      color: var(--dark-text);
    }
    
    .cg-modal-body {
      padding: 24px;
    }
    
    .cg-modal-footer {
      padding: 16px 24px;
      display: flex;
      justify-content: flex-end;
      gap: var(--spacing-md);
      border-top: 1px solid var(--border-color);
    }
    
    .cg-modal-btn {
      padding: 10px 20px;
      border-radius: var(--radius-md);
      font-size: 16px;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .cg-modal-btn.primary {
      background-color: var(--primary-color);
      color: white;
      border: none;
    }
    
    .cg-modal-btn.primary:hover {
      background-color: var(--accent-color);
    }
    
    .cg-modal-btn.secondary {
      background-color: white;
      color: var(--medium-text);
      border: 1px solid var(--border-color);
    }
    
    .cg-modal-btn.secondary:hover {
      background-color: var(--light-bg);
    }
    
    /* Save Favorites Feature */
   /* Update the favorites button position to top-right instead of top-left */
/* Save Favorites Feature - Updated positioning */
.cg-save-favorite {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  right: 16px;
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}
/* Favorites Button Icon Styling */
.cg-save-favorite i {
  color: #d1d5db; /* Light gray for default state */
  font-size: 18px; /* Explicit size definition */
}

.cg-save-favorite:hover i {
  color: var(--primary-color); /* Gold/tan color on hover */
}

.cg-save-favorite.active i {
  color: var(--primary-color); /* Gold/tan for active state */
}

/* Enhanced button styling */
.cg-save-favorite.active {
  background-color: #fff; /* Maintain white background */
  border: 1px solid var(--primary-color); /* Add border in primary color */
}

.cg-save-favorite:hover {
  transform: scale(1.1); /* Subtle scale effect on hover */
  box-shadow: var(--shadow-lg); /* Enhanced shadow on hover */
}
/* Share Feature - Updated positioning */
.cg-share-property {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  right: 60px;
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}

/* Compare Properties badge - Updated positioning */
.cg-compare-badge {
  position: absolute;
  top: 70px; /* Position below the header with the price */
  left: 16px; /* Move to left side */
  background-color: white;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--shadow-md);
  cursor: pointer;
  z-index: 5;
  transition: var(--transition-fast);
}

/* Remove new badge from display */
.cg-new-badge {
  display: none;
}

/* Ensure property header has clear space */
.cg-property-header {
  padding: var(--spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
  position: relative;
  z-index: 4; /* Ensure header is above the badges */
}

/* Make sure price is clearly visible */
.cg-property-price {
  font-size: 18px;
  font-weight: 700;
  color: var(--dark-text);
  position: relative;
  z-index: 6; /* Higher than the badges */
}

/* Ensure property header elements (status, price) don't overlap with title */
.cg-property-header {
  padding: var(--spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border-color);
  background: linear-gradient(135deg, #f8f9fa, #e9ecef);
  margin-top: 0; /* Ensure no top margin */
}

/* Remove new badge styles entirely */
.cg-new-badge {
  display: none; /* Hide it completely */
}

/* Add more spacing to property title to prevent overlap */
.cg-property-title {
  font-size: 20px;
  font-weight: 700;
  margin-top: var(--spacing-md); /* Add top margin to push down from header */
  margin-bottom: var(--spacing-sm);
  color: var(--primary-color);
}
    /* Geocoding Status */
    .cg-geocoding-status {
      position: absolute;
      top: 16px;
      left: 16px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px 16px;
      border-radius: var(--radius-md);
      font-size: 14px;
      max-width: 300px;
      z-index: 5;
      box-shadow: var(--shadow-sm);
    }
    
    .cg-geocoding-progress {
      margin-top: 8px;
      height: 4px;
      width: 100%;
      background-color: var(--border-color);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .cg-geocoding-bar {
      height: 100%;
      background-color: #10b981;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    /* Compare Properties */
    .cg-compare-badge {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background-color: white;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      z-index: 5;
      transition: var(--transition-fast);
    }
    
    .cg-compare-badge:hover {
      transform: scale(1.1);
    }
    
    .cg-compare-badge i {
      font-size: 18px;
      color: var(--light-text);
      transition: var(--transition-fast);
    }
    
    .cg-compare-badge.active {
      background-color: var(--primary-color);
    }
    
    .cg-compare-badge.active i {
      color: white;
    }
    
    .cg-compare-drawer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: white;
      box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1);
      padding: 16px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 100;
    }
    
    .cg-compare-drawer.active {
      transform: translateY(0);
    }
    
    .cg-compare-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .cg-compare-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--dark-text);
    }
    
    .cg-compare-close {
      background: none;
      border: none;
      font-size: 20px;
      color: var(--light-text);
      cursor: pointer;
    }
    
    .cg-compare-items {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      padding-bottom: 8px;
    }
    
    .cg-compare-item {
      min-width: 200px;
      flex: 0 0 auto;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      overflow: hidden;
      position: relative;
    }
    
    .cg-compare-remove {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: white;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
      cursor: pointer;
      font-size: 12px;
      color: var(--light-text);
    }
    
    .cg-compare-details {
      padding: 10px;
    }
    
    .cg-compare-name {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--dark-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .cg-compare-price {
      font-size: 15px;
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 4px;
    }
    
    .cg-compare-specs {
      font-size: 12px;
      color: var(--medium-text);
    }
    
    .cg-compare-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 16px;
    }
    
    .cg-compare-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: var(--transition-fast);
    }
    
    .cg-compare-btn:hover {
      background-color: var(--accent-color);
    }
    
    /* Toast Notifications */
    .cg-toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 320px;
    }
    
    .cg-toast {
      background-color: white;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: cg-toast-in 0.3s ease forwards;
      transform: translateX(100%);
    }
    
    .cg-toast.exit {
      animation: cg-toast-out 0.3s ease forwards;
    }
    
    @keyframes cg-toast-in {
      to {
        transform: translateX(0);
      }
    }
    
    @keyframes cg-toast-out {
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    .cg-toast-icon {
      min-width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
    }
    
    .cg-toast-success .cg-toast-icon {
      background-color: #10b981;
    }
    
    .cg-toast-error .cg-toast-icon {
      background-color: #ef4444;
    }
    
    .cg-toast-warning .cg-toast-icon {
      background-color: #f59e0b;
    }
    
    .cg-toast-info .cg-toast-icon {
      background-color: #3b82f6;
    }
    
    .cg-toast-content {
      flex: 1;
    }
    
    .cg-toast-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 2px;
      color: var(--dark-text);
    }
    
    .cg-toast-message {
      font-size: 13px;
      color: var(--medium-text);
    }
    
    .cg-toast-close {
      background: none;
      border: none;
      font-size: 16px;
      color: var(--light-text);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 1024px) {
      .cg-properties-grid {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
      
      .cg-filter-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      
      .cg-property-map {
        height: 500px;
      }
    }
    
    @media (max-width: 768px) {
      .cg-properties-grid {
        grid-template-columns: 1fr;
      }
      
      .cg-quick-search {
        flex-direction: column;
      }
      
      .cg-view-controls {
        flex-direction: column;
        gap: var(--spacing-md);
        align-items: flex-start;
      }
      
      .cg-filter-grid {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
      }
      
      .cg-property-map {
        height: 400px;
      }
      
      .cg-map-preview {
        width: calc(100% - 48px);
      }
      
      .cg-filter-buttons {
        flex-direction: column;
      }
      
      .cg-pagination {
        flex-wrap: wrap;
      }
    }
    
    @media (max-width: 480px) {
      .cg-container {
        padding: var(--spacing-md) var(--spacing-sm);
      }
      
      .cg-search-wrapper {
        padding: var(--spacing-md) var(--spacing-sm);
      }
      
      .cg-filter-panel {
        padding: var(--spacing-md);
      }
      
      .cg-property-specs {
        gap: var(--spacing-sm);
      }
      
      .cg-spec-value {
        font-size: 16px;
      }
      
      .cg-spec-icon {
        font-size: 18px;
      }
      
      .cg-property-map {
        height: 350px;
      }
      
      .cg-modal-content {
        width: 95%;
      }
    }
    /* Auth Overlay Styles */
    .auth-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.97);
      backdrop-filter: blur(5px);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: var(--spacing-lg);
    }
    
    .auth-container {
      background-color: var(--white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      box-shadow: var(--shadow-lg);
      max-width: 550px;
      width: 100%;
      text-align: center;
      position: relative;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }
    
    .auth-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(to right, var(--primary-color), var(--accent-color));
    }
    
    .auth-container h2 {
      margin-bottom: var(--spacing-md);
      color: var(--primary-color);
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 24px;
    }
    
    .auth-container p {
      margin-bottom: var(--spacing-lg);
      line-height: 1.6;
      color: var(--medium-text);
      font-family: 'Roboto', sans-serif;
      font-size: 16px;
    }
    
    .form-group {
      margin-bottom: var(--spacing-lg);
      text-align: left;
    }
    
    .form-group label {
      display: block;
      margin-bottom: var(--spacing-sm);
      font-weight: 500;
      color: var(--dark-text);
      font-family: 'Montserrat', sans-serif;
      font-size: 15px;
    }
    
    .form-group input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      font-size: 16px;
      color: var(--dark-text);
      font-family: 'Roboto', sans-serif;
      transition: var(--transition-fast);
    }
    
    .form-group input:focus {
      border-color: var(--accent-color);
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 150, 136, 0.15);
    }
    
    .auth-btn, .login-btn, .submit-btn {
      background-color: var(--primary-color);
      color: var(--white);
      border: none;
      border-radius: var(--radius-md);
      padding: 12px 25px;
      font-size: 16px;
      font-weight: 500;
      font-family: 'Montserrat', sans-serif;
      cursor: pointer;
      transition: var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
    }
    
    .auth-btn:hover, .login-btn:hover, .submit-btn:hover {
      background-color: var(--accent-color);
      transform: translateY(-2px);
    }
    
    .auth-btn.primary {
      background-color: var(--accent-color);
    }
    
    .auth-btn.primary:hover {
      background-color: var(--accent-dark);
    }
    
    .auth-buttons {
      display: flex;
      justify-content: center;
      gap: var(--spacing-md);
      margin-top: var(--spacing-lg);
    }
    
    .login-text, .signup-text {
      margin-top: var(--spacing-lg);
      font-size: 15px;
      color: var(--light-text);
      font-family: 'Roboto', sans-serif;
    }
    
    .login-text a, .signup-text a {
      color: var(--accent-color);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition-fast);
    }
    
    .login-text a:hover, .signup-text a:hover {
      color: var(--primary-color);
      text-decoration: underline;
    }
    
    /* Hidden until authenticated */
    .hidden-until-auth {
      display: none;
    }
    
    /* Verification Success Message */
    .verification-success {
      position: fixed;
      top: 30px;
      right: 30px;
      background-color: #10b981;
      color: white;
      padding: 20px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      animation: slideIn 0.5s forwards;
      max-width: 350px;
    }
    
    .success-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    
    .success-content i {
      font-size: 40px;
      margin-bottom: var(--spacing-md);
      color: rgba(255, 255, 255, 0.9);
    }
    
    .success-content h3 {
      margin: 0 0 var(--spacing-sm) 0;
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
    }
    
    .success-content p {
      margin: 0;
      opacity: 0.9;
      font-family: 'Roboto', sans-serif;
      font-size: 15px;
      line-height: 1.5;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .email-highlight {
      font-weight: 600;
      color: var(--accent-color);
    }
    
    #verification-message, #not-registered-message {
      padding: var(--spacing-lg);
      border-radius: var(--radius-md);
      background-color: #f8f9fa;
      margin-top: var(--spacing-lg);
      text-align: center;
    }
    
    #verification-message i, #not-registered-message i {
      font-size: 48px;
      color: var(--accent-color);
      margin-bottom: var(--spacing-md);
    }
    
    .loading-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      color: var(--medium-text);
      margin: var(--spacing-md) 0;
    }
    
    .loading-indicator i {
      animation: spin 1.5s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .hubspot-form-wrapper {
      background-color: #f8f8f8;
      border-radius: var(--radius-md);
      padding: var(--spacing-lg);
      margin: var(--spacing-md) 0;
      box-shadow: var(--shadow-sm);
    }
  </style>
</head>
  <body>
  <!-- Auth Overlay -->
  <div id="auth-overlay" class="auth-overlay">
    <div class="auth-container">
      <!-- Auth Options -->
      <div id="auth-options">
        <h2>Access Property Listings</h2>
        <p>To view our exclusive property listings, please sign in or register.</p>
        
        <div class="auth-buttons">
          <button id="show-login-btn" class="auth-btn">
            <i class="fas fa-sign-in-alt"></i> Login
          </button>
          <button id="show-signup-btn" class="auth-btn primary">
            <i class="fas fa-user-plus"></i> Register
          </button>
        </div>
      </div>
      
      <!-- HubSpot Form for Registration -->
      <div id="hubspot-form-container" style="display: none;">
        <h2>Register to Access Listings</h2>
        <p>Complete the form below to register for access to our exclusive property listings.</p>
        
        <!-- HubSpot form will be embedded here -->
        <div id="hubspot-form-embed" class="hubspot-form-wrapper"></div>
        
        <!-- Fallback iframe if JS API fails -->
        <iframe 
          id="hubspot-iframe" 
          style="display: none; width: 100%; height: 500px; border: none;"
          src="https://share.hsforms.com/1oA8fZxSQRKelcRQtpTdzgwedudl?cg_needs_verification=true">
        </iframe>
        
        <p class="login-text">Already registered? <a href="#" id="login-link">Login here</a></p>
      </div>
      
      <!-- Login Form -->
      <div id="login-form" style="display: none;">
        <h2>Login to Access Listings</h2>
        <p>Enter your email to access our exclusive property listings</p>
        
        <form id="email-login-form">
          <div class="form-group">
            <label for="login-email">Email Address</label>
            <input type="email" id="login-email" name="email" required placeholder="Enter your email">
          </div>
          <button type="submit" id="access-listings-btn" class="login-btn">
            <i class="fas fa-unlock-alt"></i> Access Listings
          </button>
        </form>
        
        <div id="login-loading" class="loading-indicator" style="display: none;">
          <i class="fas fa-spinner"></i> Verifying your account...
        </div>
        
        <p class="signup-text">Don't have an account? <a href="#" id="signup-link">Register here</a></p>
      </div>
      
      <!-- Verification Message -->
      <div id="verification-message" style="display: none;">
        <i class="fas fa-envelope"></i>
        <h2>Email Verification Required</h2>
        <p>We've sent a verification email to <span id="verification-email" class="email-highlight"></span>.</p>
        <p>Please check your inbox and click on the verification link to access the listings.</p>
        <p>After verification, you can return to this page and login.</p>
        
        <button id="resend-verification" class="auth-btn">
          <i class="fas fa-paper-plane"></i> Resend Verification Email
        </button>
        
        <p class="login-text">Using a different email? <a href="#" id="return-login-link">Login here</a></p>
      </div>
      
      <!-- Not Registered Message -->
      <div id="not-registered-message" style="display: none;">
        <i class="fas fa-user-times"></i>
        <h2>Email Not Registered</h2>
        <p>This email is not registered in our system.</p>
        <p>Please register to access our property listings.</p>
        
        <button id="show-signup" class="auth-btn primary">
          <i class="fas fa-user-plus"></i> Register Now
        </button>
      </div>
    </div>
  </div>
  <!-- Authentication Overlay -->
  <div class="auth-overlay" id="auth-overlay">
    <div class="auth-container">
      <h2>Property Listings Access</h2>
      <p>Please register to view our exclusive property listings. Your information will help us provide you with personalized property recommendations.</p>
      
      <!-- Confirmation message (initially hidden) -->
      <div id="confirmation-message" style="display: none; background-color: #f1f9f1; border: 1px solid #dff0d8; padding: 15px; border-radius: 4px; margin: 20px 0; text-align: center;">
        <h3 style="color: #3c763d; margin-top: 0;">Thank you for getting in touch!</h3>
        <p style="color: #3c763d; margin-bottom: 5px;">We appreciate your enquiry.</p>
        <p style="color: #3c763d; margin-bottom: 5px;">One of our sales team will be in touch shortly. <strong>Please check your inbox for a verification link to access the listings.</strong></p>
        <p style="color: #3c763d; font-style: italic;">The verification email may take a few minutes to arrive. Please also check your spam folder.</p>
        <div id="verification-help" style="margin-top: 15px; padding: 10px; border: 1px dashed #5cb85c; text-align: left;">
          <p style="color: #666; margin-bottom: 10px;"><strong>Not receiving the verification email?</strong></p>
          <p style="color: #666; margin-bottom: 5px;">Try one of these options:</p>
          <ol style="color: #666; text-align: left; margin-left: 20px;">
            <li>Open the <a href="direct_submission.html" target="_blank" style="color: #5cb85c;">direct submission form</a> and enter your details</li>
            <li>Check that your email address is correct</li>
            <li>Check your spam/junk folder</li>
          </ol>
        </div>
      </div>
      
      <!-- HubSpot Form Display (API method) -->
      <div id="hubspot-form-embed"></div>
      
      <!-- Direct iframe embed (fallback) -->
      <iframe 
        id="hubspot-iframe" 
        src="https://share.hsforms.com/1oA8fZxSQRKelcRQtpTdzgwedudl?cg_needs_verification=Yes" 
        width="100%" 
        height="500" 
        frameborder="0"
        style="border: none; display: block;">
      </iframe>
      
      <!-- Continue button (shown after 5 seconds) -->
      <button id="continue-button" style="display: none; margin: 20px auto; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;">
        Continue to Listings
      </button>
      
      <!-- Manual form (shown after 15 seconds as ultimate fallback) -->
      <form id="manual-form" style="display: none; max-width: 400px; margin: 20px auto; text-align: left;">
        <div style="margin-bottom: 15px;">
          <label for="manual-email" style="display: block; margin-bottom: 5px; font-weight: bold;">Email Address *</label>
          <input type="email" id="manual-email" required style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div style="margin-bottom: 15px;">
          <label for="manual-firstname" style="display: block; margin-bottom: 5px; font-weight: bold;">First Name</label>
          <input type="text" id="manual-firstname" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <div style="margin-bottom: 15px;">
          <label for="manual-lastname" style="display: block; margin-bottom: 5px; font-weight: bold;">Last Name</label>
          <input type="text" id="manual-lastname" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        </div>
        <button type="submit" style="background-color: #ff5722; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px;">
          Submit and View Listings
        </button>
      </form>
    </div>
  </div>
  
  <div class="container hidden-until-auth" id="listings-container">
    
    <!-- Search Bar - Sticky -->
    <div class="cg-search-wrapper" id="cg-search-wrapper">
      <div class="cg-quick-search">
        <div class="cg-search-input-wrapper">
          <i class="fas fa-search cg-search-icon"></i>
          <input type="text" id="property-search" class="cg-search-input" placeholder="Search by location, project, lot number...">
        </div>
        <button id="search-button" class="cg-search-btn">
          <i class="fas fa-search"></i>
          Search
        </button>
      </div>
      
      <!-- Quick Filters -->
      <div class="cg-quick-filters">
        <button class="cg-quick-filter active" data-filter="all">All Properties</button>
        <button class="cg-quick-filter" data-filter="available">Available</button>
        <button class="cg-quick-filter" data-filter="house-and-land">House & Land</button>
        <button class="cg-quick-filter" data-filter="land-only">Land Only</button>
        <button class="cg-quick-filter" data-filter="registered">Registered</button>
        <!-- Removed "coming soon" button as requested -->
      </div>
    </div>
    
    <!-- Filter Panel -->
<div class="cg-filter-panel">
  <div class="cg-filter-header">
    <h2 class="cg-filter-title">
      <i class="fas fa-filter"></i>
      Filter Properties
    </h2>
    <button id="toggle-filters" class="cg-filter-toggle">
      <span class="toggle-text">Show All Filters</span>
      <i class="fas fa-chevron-down"></i>
    </button>
  </div>
  <!-- Filter Grid - Primary Filters Row -->
  <div class="cg-filter-grid">
    <div class="cg-filter-group">
      <label for="project-filter" class="cg-filter-label">Project</label>
      <select id="project-filter" class="cg-filter-select">
        <option value="">All Projects</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="suburb-filter" class="cg-filter-label">Suburb</label>
      <select id="suburb-filter" class="cg-filter-select">
        <option value="">All Suburbs</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="listing-type-filter" class="cg-filter-label">Listing Type</label>
      <select id="listing-type-filter" class="cg-filter-select">
        <option value="">All Listing Types</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
  </div>
  
  <!-- Secondary Filters Row -->
  <div class="cg-filter-grid" style="margin-top: var(--spacing-lg);">
    <div class="cg-filter-group">
      <label for="status-filter" class="cg-filter-label">Status</label>
      <select id="status-filter" class="cg-filter-select">
        <option value="">All Statuses</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="neighborhood-filter" class="cg-filter-label">Neighborhood</label>
      <select id="neighborhood-filter" class="cg-filter-select">
        <option value="">All Neighborhoods</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="registration-date-filter" class="cg-filter-label">Registration Date</label>
      <select id="registration-date-filter" class="cg-filter-select">
        <option value="">Any Date</option>
        <option value="next-3-months">Next 3 Months</option>
        <option value="next-6-months">Next 6 Months</option>
        <option value="this-year">This Year</option>
        <option value="next-year">Next Year</option>
        <option value="registered">Already Registered</option>
      </select>
    </div>
  </div>
  
  <!-- Advanced Filters - Initially Hidden -->
  <div id="advanced-filters" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="land-shape-filter" class="cg-filter-label">Land Shape</label>
      <select id="land-shape-filter" class="cg-filter-select">
        <option value="">All Land Shapes</option>
        <!-- Will be populated dynamically -->
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="aspect-filter" class="cg-filter-label">Aspect</label>
      <select id="aspect-filter" class="cg-filter-select">
        <option value="">All Aspects</option>
        <option value="North">North</option>
        <option value="South">South</option>
        <option value="East">East</option>
        <option value="West">West</option>
        <option value="North East">North East</option>
        <option value="North West">North West</option>
        <option value="South East">South East</option>
        <option value="South West">South West</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="title-type-filter" class="cg-filter-label">Title Type</label>
      <select id="title-type-filter" class="cg-filter-select">
        <option value="">All Title Types</option>
        <option value="cg_torrens">Torrens</option>
        <option value="cg_community">Community</option>
      </select>
    </div>
  </div>
  
  <!-- More Advanced Filters - Initially Hidden -->
  <div id="advanced-filters-2" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="land-size-filter" class="cg-filter-label">Land Size</label>
      <select id="land-size-filter" class="cg-filter-select">
        <option value="">Any Size</option>
        <option value="0-300">Under 300m</option>
        <option value="300-450">300m - 450m</option>
        <option value="450-600">450m - 600m</option>
        <option value="600-800">600m - 800m</option>
        <option value="800+">Over 800m</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="frontage-filter" class="cg-filter-label">Frontage (m)</label>
      <select id="frontage-filter" class="cg-filter-select">
        <option value="">Any Frontage</option>
        <option value="0-10">Under 10m</option>
        <option value="10-15">10m - 15m</option>
        <option value="15-20">15m - 20m</option>
        <option value="20+">Over 20m</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="price-filter" class="cg-filter-label">Price Range</label>
      <select id="price-filter" class="cg-filter-select">
        <option value="">Any Price</option>
        <option value="0-500000">Under $500,000</option>
        <option value="500000-750000">$500,000 - $750,000</option>
        <option value="750000-1000000">$750,000 - $1,000,000</option>
        <option value="1000000-1500000">$1,000,000 - $1,500,000</option>
        <option value="1500000+">$1,500,000+</option>
      </select>
    </div>
  </div>
  
  <!-- Property Specs Filters - Initially Hidden -->
  <div id="advanced-filters-3" class="cg-filter-grid" style="margin-top: var(--spacing-lg); display: none;">
    <div class="cg-filter-group">
      <label for="bedrooms-filter" class="cg-filter-label">Bedrooms</label>
      <select id="bedrooms-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
        <option value="5">5+</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="bathrooms-filter" class="cg-filter-label">Bathrooms</label>
      <select id="bathrooms-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
      </select>
    </div>
    
    <div class="cg-filter-group">
      <label for="car-spaces-filter" class="cg-filter-label">Car Spaces</label>
      <select id="car-spaces-filter" class="cg-filter-select">
        <option value="">Any</option>
        <option value="1">1+</option>
        <option value="2">2+</option>
        <option value="3">3+</option>
        <option value="4">4+</option>
      </select>
    </div>
  </div>
  
  <!-- Active Filters Pills -->
  <div id="active-filters" class="cg-active-filters">
    <!-- Will be populated dynamically -->
  </div>
  
  <!-- Filter Action Buttons -->
  <div id="filter-buttons" class="cg-filter-buttons" style="display: none;">
    <button id="clear-filters" class="cg-btn-clear">
      <i class="fas fa-times"></i> Clear All Filters
    </button>
    <button id="apply-filters" class="cg-btn-apply">
      <i class="fas fa-check"></i> Apply Filters
    </button>
  </div>
</div>
    
    <!-- View Toggle and Sorting Controls -->
    <div class="cg-view-controls">
      <div class="cg-view-toggle">
        <button id="grid-view-toggle" class="cg-view-btn active">
          <i class="fas fa-th-large"></i> Grid View
        </button>
        <button id="map-view-toggle" class="cg-view-btn">
          <i class="fas fa-map-marked-alt"></i> Map View
        </button>
      </div>
      
      <div class="cg-sort-controls">
        <div class="cg-sort-label">Sort By:</div>
        <select id="sort-by" class="cg-sort-select">
          <option value="default">Default</option>
          <option value="price-asc">Price (Low to High)</option>
          <option value="price-desc">Price (High to Low)</option>
          <option value="land-size-asc">Land Size (Small to Large)</option>
          <option value="land-size-desc">Land Size (Large to Small)</option>
          <option value="frontage-desc">Frontage (Largest First)</option>
          <option value="registration-date-asc">Registration (Soonest First)</option>
          <option value="bedrooms-desc">Bedrooms (Most First)</option>
          <option value="project">Project Name</option>
          <option value="newest">Newest First</option>
        </select>
        
        <div id="toggle-direction" class="cg-sort-direction">
          <i class="fas fa-sort-amount-down"></i>
          <span>Descending</span>
        </div>
      </div>
    </div>
    
    <!-- Results Count -->
    <div id="results-count" class="cg-results-count">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Map View Container -->
    <div id="map-view-container" class="cg-map-container" style="display: none;">
      <!-- Geocoding Status Indicator -->
      <div id="geocoding-status" class="cg-geocoding-status" style="display: none;">
        <div id="geocoding-message">Geocoding properties...</div>
        <div class="cg-geocoding-progress">
          <div id="geocoding-progress-bar" class="cg-geocoding-bar"></div>
        </div>
      </div>
      
      <!-- Map Controls -->
      <div class="cg-map-controls">
        <button id="map-streets" class="cg-map-btn active">
          <i class="fas fa-road"></i> Streets
        </button>
        <button id="map-satellite" class="cg-map-btn">
          <i class="fas fa-satellite"></i> Satellite
        </button>
        <button id="map-hybrid" class="cg-map-btn">
          <i class="fas fa-layer-group"></i> Hybrid
        </button>
      </div>
      
      <!-- Map Disclaimer -->
      <div id="map-disclaimer" class="cg-map-disclaimer">
        <strong>Note:</strong> All property locations shown are approximate and for reference purposes only. Locations are based on project coordinates and may not represent exact property boundaries.
      </div>
      
      <!-- Map Element -->
      <div id="property-map" class="cg-property-map"></div>
      
      <!-- Property Preview Panel -->
      <div id="map-property-preview" class="cg-map-preview cg-preview-hidden">
        <div class="cg-preview-header">
          <h3 id="preview-title" class="cg-preview-title">Property Title</h3>
          <button id="close-preview" class="cg-preview-close">&times;</button>
        </div>
        <div class="cg-preview-content">
          <div id="preview-status" class="cg-preview-status cg-status-available">Available</div>
          <p id="preview-price" class="cg-preview-price">$450,000</p>
          <p id="preview-details" class="cg-preview-details">450m  15m frontage  North</p>
          <div id="preview-zoning" class="cg-preview-zoning">
            <strong>Zoning:</strong> <span id="preview-zoning-value">Low Density Residential</span><br>
            <strong>School Zone:</strong> <span id="preview-school-zone" class="cg-school-zone">Local High School</span>
          </div>
          <button id="preview-view-btn" class="cg-preview-btn">
            <i class="fas fa-external-link-alt"></i> View Details
          </button>
        </div>
      </div>
    </div>
    
    <!-- Properties Container -->
    <div id="properties-container">
      <!-- Loading State (will be dynamically replaced) -->
      <div class="cg-loading">
        <div class="cg-spinner"></div>
        <p class="cg-loading-text">Loading properties...</p>
      </div>
    </div>
    
    <!-- Pagination -->
    <div id="pagination" class="cg-pagination" style="display: none;">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Quick View Modal -->
    <div id="quick-view-modal" class="cg-quick-view-modal">
      <div class="cg-modal-content">
        <div class="cg-modal-header">
          <h3 id="modal-title" class="cg-modal-title">Property Details</h3>
          <button id="modal-close" class="cg-modal-close">&times;</button>
        </div>
        <div id="modal-body" class="cg-modal-body">
          <!-- Modal content will be dynamically inserted -->
        </div>
        <div class="cg-modal-footer">
          <button id="modal-close-btn" class="cg-modal-btn secondary">Close</button>
          <button id="modal-view-details" class="cg-modal-btn primary">
            <i class="fas fa-external-link-alt"></i> View Full Details
          </button>
        </div>
      </div>
    </div>
    
    <!-- Saved Properties Compare Drawer -->
    <div id="compare-drawer" class="cg-compare-drawer">
      <div class="cg-compare-header">
        <h3 class="cg-compare-title">Compare Properties (<span id="compare-count">0</span>)</h3>
        <button id="compare-close" class="cg-compare-close">&times;</button>
      </div>
      <div id="compare-items" class="cg-compare-items">
        <!-- Will be populated dynamically -->
      </div>
      <div class="cg-compare-actions">
        <button id="compare-btn" class="cg-compare-btn" disabled>
          <i class="fas fa-chart-bar"></i> Compare Properties
        </button>
      </div>
    </div>
    
    <!-- Toast Notifications Container -->
    <div id="toast-container" class="cg-toast-container">
      <!-- Will be populated dynamically -->
    </div>
    
    <!-- Debug information (hidden by default) -->
    <div id="debug-info" style="display: none;"></div>
  </div>
  <script>
  // Castle Group Property Listings
document.addEventListener('DOMContentLoaded', function() {
  // ========================
  // Configuration & Constants
  // ========================
  const CONFIG = {
    apiEndpoint: 'https://eo6b0y2wbmrsq7l.m.pipedream.net',
    fallbackEndpoint: 'https://eo6b0y2wbmrsq7l.m.pipedream.net',
    useSampleAsFallback: false, // Set to false to always attempt real data loading
    forceSampleData: false, // NEVER use sample data
    preventSampleFallback: true, // Always prevent sample data fallback
    alwaysShowRealDebug: true, // Show debug info about real properties
    preferCachedReal: true, // Prefer cached real properties over sample properties
    mapboxApiEndpoint: 'https://eo9gqdeujnljhqh.m.pipedream.net/',
    propertiesPerPage: 9,
    geocodingThreshold: 1.0, // 1.0km proximity threshold
    defaultLocation: { lat: -33.8688, lng: 151.2093 }, // Sydney
    apiTimeout: 30000, // 30 seconds timeout for API calls
    pipedreamRetries: 3, // Increased number of retries for Pipedream API
    debugMode: true, // Force debug mode to always be enabled
    fallbackEndpoint: 'https://eo6b0y2wbmrsq7l.m.pipedream.net' // Secondary endpoint in case primary fails
  };
  
  const NSW_BOUNDS = {
    north: -28.15, // Northern border
    south: -37.50, // Southern border
    east: 153.64,  // Eastern border (coastline)
    west: 141.00   // Western border
  };
  
  // Default suburb centers for faster geocoding
  const SUBURB_CENTERS = {
    'Austral': { lat: -33.9501, lng: 150.8273 },
    'Kellyville': { lat: -33.7014, lng: 150.9487 },
    'Leppington': { lat: -33.9605, lng: 150.7836 },
    'Oakville': { lat: -33.6250, lng: 150.8544 },
    'Pitt Town': { lat: -33.5849, lng: 150.8594 },
    'Rouse Hill': { lat: -33.6818, lng: 150.9157 },
    'Vineyard': { lat: -33.6473, lng: 150.8399 },
    // Keep other suburbs as fallbacks
    'Sydney': { lat: -33.8688, lng: 151.2093 },
    'Parramatta': { lat: -33.8150, lng: 151.0011 },
    'Chatswood': { lat: -33.7986, lng: 151.1809 },
    'Bondi': { lat: -33.8920, lng: 151.2775 },
    'Manly': { lat: -33.7971, lng: 151.2844 },
    'Penrith': { lat: -33.7511, lng: 150.6942 }
  };
  
  // Project-specific coordinates for more accurate mapping
  const PROJECT_COORDINATES = {
    'Fifteenth Avenue': { lat: -33.91615699103137, lng: 150.80745524232896 },
    '505-535 Fifteenth Avenue': { lat: -33.91615699103137, lng: 150.80745524232896 },
    'Valley Rise': { lat: -33.960965, lng: 150.821498 },
    'Bloomfield': { lat: -33.935464, lng: 150.792713 },
    'River Oaks': { lat: -33.64437800332728, lng: 150.87371022590727 },
    'Riviere': { lat: -33.573160492410885, lng: 150.86985371241119 },
    'The Rouse Hill Estate': { lat: -33.67859665482809, lng: 150.88611618357965 },
    'One FairWay': { lat: -33.719811127758454, lng: 150.96226740715773 },
    'Park Avenue 2': { lat: -33.68860529650804, lng: 150.89938596823788 },
    'Park Avenue': { lat: -33.68820738573453, lng: 150.8959351134934 },
    // Additional projects with their coordinates
    'Meadowview': { lat: -33.695123, lng: 150.883546 },
    'Riverside Estates': { lat: -33.603482, lng: 150.891234 },
    'Highland Park': { lat: -33.712345, lng: 150.923456 },
    'Summit Ridge': { lat: -33.723456, lng: 150.912345 }
  };

  // ========================
  // State Management
  // ========================
  const CastleApp = {
    state: {
      allProperties: [],
      filteredProperties: [],
      currentPage: 1,
      currentSort: 'default',
      isDescending: true,
      map: null,
      mapInitialized: false,
      mapMarkers: [],
      currentMapBounds: null,
      selectedMarker: null,
      mapboxToken: null,
      tokenExpiry: 0,
      geocodingCache: {},
      geocodingQueue: [],
      isGeocodingInProgress: false,
      compareProperties: [],
      favorites: JSON.parse(localStorage.getItem('cg-favorites') || '[]'),
      filters: {
        search: '',
        project: '',
        suburb: '',
        neighborhood: '',
        listingType: '',
        status: '',
        landShape: '',
        aspect: '',
        titleType: '',
        registrationDate: '',
        storeys: '',
        isLandOnly: false, // Added for Land Only filter
        priceMin: null,
        priceMax: null,
        landSizeMin: null,
        landSizeMax: null,
        buildSizeMin: null,
        buildSizeMax: null,
        frontageMin: null,
        frontageMax: null,
        depthMin: null,
        depthMax: null,
        minBedrooms: null,
        minBathrooms: null,
        minCarSpaces: null
      }
    },
    
    // ========================
    // Initialization Functions
    // ========================
    init() {
      this.setupDebugMode();
      this.initializeUIInteractions();
      this.initializeFilters();
      
      // Use the robust loading method with retry and Pipedream error handling
      if (typeof this.loadPropertiesWithRetry === 'function') {
        this.loadPropertiesWithRetry();
      } else {
        // Fallback to regular load if the enhanced method is not available
        this.loadProperties();
      }
      
      this.initQuickView();
      this.initCompareDrawer();
      this.initToastSystem();
      
      // Sticky search on scroll
      window.addEventListener('scroll', this.handleSearchSticky);
    },
    
    setupDebugMode() {
      if (CONFIG.debugMode) {
        document.getElementById('debug-info').style.display = 'block';
      }
    },
    
    // ========================
    // Property Loading & Data Handling
    // ========================
    async loadProperties() {
      const container = document.getElementById('properties-container');
      
      // Track loading state explicitly
      this.state.isLoading = true;
      
      // Show loading state immediately
      if (container) {
        this.displaySkeletonLoaders();
      }
      
      // Add visual debug widget to track API call process
      const debugWidget = document.createElement('div');
      debugWidget.id = 'api-debug-widget';
      debugWidget.style.cssText = 'position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: #00ff00; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 9999; max-width: 300px; overflow: auto; max-height: 200px;';
      debugWidget.innerHTML = '<div> API Call Started...</div>';
      document.body.appendChild(debugWidget);
      
      const addDebugInfo = (message) => {
        const div = document.createElement('div');
        div.textContent = message;
        debugWidget.appendChild(div);
        debugWidget.scrollTop = debugWidget.scrollHeight;
        console.log(`Debug: ${message}`);
      };
      
      // Log authentication status for debugging
      const authStatus = localStorage.getItem('cg_auth_status') || 'unknown';
      this.log(`Authentication status: ${authStatus}`);
      
      // Use a timestamp to prevent caching
      const timestamp = new Date().getTime();
      const url = `${CONFIG.apiEndpoint}?_t=${timestamp}`;
      
      // Add debug info to console
      console.log(` Loading properties from Pipedream endpoint: ${url}`);
      console.log(` Using authentication status: ${authStatus}`);
      this.log(`Fetching properties from: ${url}`);
      addDebugInfo(` Fetching from: ${CONFIG.apiEndpoint}`);
      addDebugInfo(` Auth: ${authStatus}`);
      
      try {
        // Set a timeout to abort long-running requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.apiTimeout || 30000);
          
        // Add headers to prevent caching issues with Pipedream
        const response = await fetch(url, {
          signal: controller.signal,
          method: 'GET',
          headers: {
            'Cache-Control': 'no-cache, no-store',
            'Pragma': 'no-cache',
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        clearTimeout(timeoutId);
        addDebugInfo(` Response status: ${response.status}`);
        
        this.log(`Received response: ${response.status}`);
          
        // Check for network or server errors
        if (!response.ok) {
          this.log(`API error: ${response.status} ${response.statusText}`);
          addDebugInfo(` HTTP error: ${response.status}`);
          throw new Error(`Server returned ${response.status}`);
        }
        
        // Try to parse the JSON response
        let data;
        try {
          data = await response.json();
          addDebugInfo(` Data received: ${data.success ? 'Success' : 'Failure'}`);
          this.log(`Data parsed successfully, success: ${data.success || false}, results: ${data.results?.length || 0}`);
          
          // Store response data for inspection
          window._lastApiResponse = data;
          
          // Save to our special debug localStorage item to help diagnose issues
          try {
            localStorage.setItem('cg_last_api_response', JSON.stringify({
              timestamp: new Date().toISOString(),
              endpoint: url,
              status: response.status,
              success: data.success || false,
              resultsCount: data.results?.length || 0
            }));
          } catch (e) {
            console.error('Could not save API response debug info:', e);
          }
          
          // Set a timeout to abort long-running requests
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), CONFIG.apiTimeout || 30000);
          
          // Add headers to prevent caching issues with Pipedream
          const response = await fetch(url, {
            signal: controller.signal,
            method: 'GET',
            headers: {
              'Cache-Control': 'no-cache, no-store',
              'Pragma': 'no-cache',
              'Accept': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          clearTimeout(timeoutId);
          
          this.log(`Received response: ${response.status}`);
          
          // Check for network or server errors
          if (!response.ok) {
            this.log(`API error: ${response.status} ${response.statusText}`);
            throw new Error(`Server returned ${response.status}`);
          }
          
          // Try to parse the JSON response
          let data;
          try {
            data = await response.json();
            this.log(`Data parsed successfully, success: ${data.success}, results: ${data.results?.length || 0}`);
            
            // Validate response structure
            if (!data.success && !data.results) {
              throw new Error('Pipedream workflow returned invalid data structure');
            }
            
            // Save valid response to cache for future use
            if (data.results && data.results.length > 0) {
              try {
                localStorage.setItem('cg_cached_properties', JSON.stringify(data.results));
                localStorage.setItem('cg_cache_timestamp', Date.now().toString());
                this.log(`Saved ${data.results.length} properties to cache`);
              } catch (cacheError) {
                this.log(`Error saving to cache: ${cacheError.message}`);
              }
            }
        
        if (!data.success) {
          throw new Error(data.error || "Unknown API error");
        }
        
        if (!data.results || data.results.length === 0) {
          this.renderNoResults();
          return;
        }
        
        // Store all properties
        this.state.allProperties = data.results;
        
        // Save real properties to special cache to ensure real data is preserved
        try {
          localStorage.setItem('cg_real_properties_cache', JSON.stringify(data.results));
          localStorage.setItem('cg_real_properties_cache_time', Date.now());
          addDebugInfo(` Saved to real properties cache (${data.results.length} items)`);
        } catch (e) {
          console.error('Error saving to real properties cache:', e);
        }
        
        // Add debug info about properties we found
        const propertyDetails = data.results.map(p => 
          `${p.properties?.cg_project_name || 'Unnamed'} (${p.properties?.cg_status || 'unknown'})`
        ).slice(0, 3).join(', ');
        addDebugInfo(` First few: ${propertyDetails}${data.results.length > 3 ? '...' : ''}`);
        
        // Filter for only the specified statuses
        const includedStatuses = [
          "cg_exclusive",
          "cg_available",
          "cg_under_offer",
          "cg_hold"
        ];
        
        // Filter out any properties with status not in includedStatuses
        this.state.allProperties = this.state.allProperties.filter(property => {
          const status = property.properties?.cg_status;
          return status && includedStatuses.includes(status);
        });
        
        this.log(`After status filtering: ${this.state.allProperties.length} properties remain`);
        
        // Initialize filter dropdowns with available options
        this.populateFilterOptions();
        
        // Apply initial filtering (no filters active)
        this.filterProperties();
        
        // Log cache status if available
        if (data.cached) {
          this.log(`Using cached data (${data.cache_age} seconds old)`);
        }
        
      } catch (error) {
        this.log(`ERROR: ${error.message}`);
        
        // Clear loading state
        this.state.isLoading = false;
        
        // Determine error type
        let errorType = 'general';
        let errorMessage = error.message;
        
        if (error.name === 'AbortError') {
          errorType = 'timeout';
          errorMessage = 'Request timed out. The Pipedream workflow is taking too long to respond.';
        } else if (error.message.includes('JSON')) {
          errorType = 'data';
          errorMessage = 'The Pipedream workflow returned invalid data. Please check the workflow configuration.';
        } else if (error.message.includes('No properties')) {
          errorType = 'empty';
          errorMessage = 'The Pipedream workflow did not return any properties. Please check if the workflow is functioning correctly.';
        }
        
        this.log(`Error type: ${errorType}, Message: ${errorMessage}`);
        
        // PIPEDREAM FALLBACK: First try to load properties from localStorage if available
        try {
          const cachedProperties = localStorage.getItem('cg_cached_properties');
          if (cachedProperties) {
            const parsedProperties = JSON.parse(cachedProperties);
            if (Array.isArray(parsedProperties) && parsedProperties.length > 0) {
              this.log('FALLBACK: Using cached properties from localStorage');
              this.state.allProperties = parsedProperties;
              this.state.filteredProperties = [...parsedProperties];
              this.sortProperties();
              this.renderProperties();
              
              // Show a warning toast
              if (typeof this.showToast === 'function') {
                this.showToast('Using cached property data. Some information may be outdated.', 'warning');
              }
              
              return; // Exit early since we recovered
            }
          }
        } catch (cacheError) {
          this.log(`FALLBACK: Cache recovery failed: ${cacheError.message}`);
        }
        
        // Check for dev mode to show sample data
        if (CONFIG.debugMode && CONFIG.useSampleAsFallback) {
          this.log('DEBUG MODE: Using sample property data instead of showing error');
          this.loadSampleProperties();
          return; // Exit early since we're showing sample data
        }
        
        // Try to load real data with retry mechanism
        if (typeof this.loadPropertiesWithRetry === 'function') {
          this.log('Attempting to load real properties with retry mechanism');
          this.loadPropertiesWithRetry();
          return; // Exit and let the retry mechanism handle it
        }
        
        // If we got here, render the error
        this.renderError(errorMessage);
        
        // IMPORTANT: Show a recovery UI with options for the user
        this.showRecoveryOptions(errorType);
      }
    },
    
    // ========================
    // Filtering & Sorting
    // ========================
    filterProperties() {
      // Define included statuses
      const includedStatuses = [
        "cg_exclusive",
        "cg_available",
        "cg_under_offer",
        "cg_hold"
      ];
      
      // Add debug logging for all active filters
      if (CONFIG.debugMode) {
        const activeFilters = Object.entries(this.state.filters)
          .filter(([key, value]) => value && value !== '')
          .map(([key, value]) => `${key}: ${value}`)
          .join(', ');
        
        this.log(`Active filters: ${activeFilters || 'None'}`);
        
        // Log specific filters of interest
        if (this.state.filters.titleType) {
          const availableTitles = Array.from(new Set(
            this.state.allProperties
              .map(p => p.properties?.cg_title)
              .filter(Boolean)
          ));
          this.log(`Available title types: ${availableTitles.join(', ')}`);
        }
        
        if (this.state.filters.listingType) {
          const availableListingTypes = Array.from(new Set(
            this.state.allProperties
              .map(p => p.properties?.hs_listing_type)
              .filter(Boolean)
          ));
          this.log(`Available listing types: ${availableListingTypes.join(', ')}`);
        }
      }
      
      this.state.filteredProperties = this.state.allProperties.filter(property => {
        const props = property.properties || {};
        
        // First check: Only include properties with desired statuses
        if (!props.cg_status || !includedStatuses.includes(props.cg_status)) {
          return false;
        }
        
        // Land Only filter - check the cg_land field
        if (this.state.filters.isLandOnly) {
          // Keep only properties that have a value in cg_land field
          if (!props.cg_land) {
            return false;
          }
        }
        
        // Search filter - check multiple fields
        if (this.state.filters.search) {
          const searchFields = [
            props.hs_listing_type,
            props.cg_project,
            props.cg_stage,
            props.cg_dp_lot,
            props.cg_mp_lot,
            props.hs_address_1,
            props.hs_city,
            props.cg_house_type,
            props.cg_land_type,
            props.cg_aspect,
            props.cg_title,
            props.hs_neighborhood
          ];
          
          const searchText = searchFields.filter(field => field).join(' ').toLowerCase();
          if (!searchText.includes(this.state.filters.search)) {
            return false;
          }
        }
        
        // Project filter
        if (this.state.filters.project && props.cg_project !== this.state.filters.project) {
          return false;
        }
        
        // Suburb filter
        if (this.state.filters.suburb && props.hs_city !== this.state.filters.suburb) {
          return false;
        }
        
        // Neighborhood filter
        if (this.state.filters.neighborhood && props.hs_neighborhood !== this.state.filters.neighborhood) {
          return false;
        }
        
        // Listing Type filter - Using exact match for special values
if (this.state.filters.listingType) {
  // For House and Land Only, use exact matching with the internal values
  if (this.state.filters.listingType === 'house' || 
      this.state.filters.listingType === 'cg_land') {
    if (props.hs_listing_type !== this.state.filters.listingType) {
      return false;
    }
  } else {
    // For other listing types, continue using flexible matching for better UX
    const propListingType = (props.hs_listing_type || '').toLowerCase().trim();
    const filterListingType = this.state.filters.listingType.toLowerCase().trim();
    
    if (!propListingType.includes(filterListingType) && !filterListingType.includes(propListingType)) {
      return false;
    }
  }
}
        
        // Status filter
        if (this.state.filters.status && props.cg_status !== this.state.filters.status) {
          return false;
        }
        
        // Land Shape filter (formerly Land Type)
        if (this.state.filters.landShape && props.cg_land_type !== this.state.filters.landShape) {
          return false;
        }
        
        // Aspect filter
        if (this.state.filters.aspect && props.cg_aspect !== this.state.filters.aspect) {
          return false;
        }
        
        // Title type filter - Updated to use the internal values
        if (this.state.filters.titleType && props.cg_title) {
          // Direct match with internal HubSpot values (cg_torrens, cg_community)
          if (this.state.filters.titleType !== props.cg_title) {
            return false;
          }
        } else if (this.state.filters.titleType) {
          return false;
        }
        
        // Registration date filter
        if (this.state.filters.registrationDate) {
          if (this.state.filters.registrationDate === 'registered') {
            // Check if property is registered (has a registration date in the past)
            if (!props.cg_registration_date) {
              return false;
            }
            
            const regDate = new Date(props.cg_registration_date);
            const today = new Date();
            
            if (regDate > today) {
              return false;
            }
          } else {
            // For other registration date filters, implement specific logic
            // ...
          }
        }
        
        // Price range filter
        if (this.state.filters.priceMin || this.state.filters.priceMax) {
          const price = this.getPriceValue(props);
          
          if (this.state.filters.priceMin && price < this.state.filters.priceMin) {
            return false;
          }
          
          if (this.state.filters.priceMax && price > this.state.filters.priceMax) {
            return false;
          }
        }
        
        // Land size filter
        if (this.state.filters.landSizeMin || this.state.filters.landSizeMax) {
          const landSize = parseFloat(props.hs_lot_size || 0);
          
          if (this.state.filters.landSizeMin && landSize < this.state.filters.landSizeMin) {
            return false;
          }
          
          if (this.state.filters.landSizeMax && landSize > this.state.filters.landSizeMax) {
            return false;
          }
        }
        
        // Build size filter
        if (this.state.filters.buildSizeMin || this.state.filters.buildSizeMax) {
          const buildSize = parseFloat(props.cg_total_build_size || 0);
          
          if (this.state.filters.buildSizeMin && buildSize < this.state.filters.buildSizeMin) {
            return false;
          }
          
          if (this.state.filters.buildSizeMax && buildSize > this.state.filters.buildSizeMax) {
            return false;
          }
        }
        
        // Frontage filter
        if (this.state.filters.frontageMin || this.state.filters.frontageMax) {
          const frontage = parseFloat(props.cg_frontage || 0);
          
          if (this.state.filters.frontageMin && frontage < this.state.filters.frontageMin) {
            return false;
          }
          
          if (this.state.filters.frontageMax && frontage > this.state.filters.frontageMax) {
            return false;
          }
        }
        
        // Depth filter
        if (this.state.filters.depthMin || this.state.filters.depthMax) {
          const depth = parseFloat(props.cg_depth || 0);
          
          if (this.state.filters.depthMin && depth < this.state.filters.depthMin) {
            return false;
          }
          
          if (this.state.filters.depthMax && depth > this.state.filters.depthMax) {
            return false;
          }
        }
        
        // Bedroom filter
        if (this.state.filters.minBedrooms) {
          const bedrooms = parseInt(props.hs_bedrooms || 0);
          
          if (bedrooms < this.state.filters.minBedrooms) {
            return false;
          }
        }
        
        // Bathroom filter
        if (this.state.filters.minBathrooms) {
          const bathrooms = parseInt(props.hs_bathrooms || 0);
          
          if (bathrooms < this.state.filters.minBathrooms) {
            return false;
          }
        }
        
        // Car spaces filter
        if (this.state.filters.minCarSpaces) {
          const carSpaces = parseInt(props.cg_car || 0);
          
          if (carSpaces < this.state.filters.minCarSpaces) {
            return false;
          }
        }
        
        return true;
      });
      
      // Reset to first page when filters change
      this.state.currentPage = 1;
      
      // Apply sorting
      this.sortProperties();
      
      // Render the filtered properties
      this.renderProperties();
      
      // Update pagination
      this.updatePagination();
      
      // Update results count
      this.updateResultsCount();
      
      // Update map markers if map is initialized and visible
      if (this.state.mapInitialized && document.getElementById('map-view-container').style.display !== 'none') {
        this.renderPropertyMarkers();
      }
      
      this.log(`Filtered to ${this.state.filteredProperties.length} properties`);
    },
    
    sortProperties() {
      if (!this.state.filteredProperties.length) return;
      
      // Define sort types and their functions
      const sortFunctions = {
        'default': (a, b) => 0, // No specific sort, use default API order
        'price-asc': (a, b) => {
          const priceA = this.getPriceValue(a.properties);
          const priceB = this.getPriceValue(b.properties);
          return this.state.isDescending ? priceB - priceA : priceA - priceB;
        },
        'price-desc': (a, b) => {
          const priceA = this.getPriceValue(a.properties);
          const priceB = this.getPriceValue(b.properties);
          return this.state.isDescending ? priceA - priceB : priceB - priceA;
        },
        'land-size-asc': (a, b) => {
          const sizeA = parseFloat(a.properties?.hs_lot_size || 0);
          const sizeB = parseFloat(b.properties?.hs_lot_size || 0);
          return this.state.isDescending ? sizeB - sizeA : sizeA - sizeB;
        },
        'land-size-desc': (a, b) => {
          const sizeA = parseFloat(a.properties?.hs_lot_size || 0);
          const sizeB = parseFloat(b.properties?.hs_lot_size || 0);
          return this.state.isDescending ? sizeA - sizeB : sizeB - sizeA;
        },
        'frontage-desc': (a, b) => {
          const frontageA = parseFloat(a.properties?.cg_frontage || 0);
          const frontageB = parseFloat(b.properties?.cg_frontage || 0);
          return this.state.isDescending ? frontageA - frontageB : frontageB - frontageA;
        },
        'registration-date-asc': (a, b) => {
          const dateA = a.properties?.cg_registration_date ? new Date(a.properties.cg_registration_date) : new Date(9999, 11, 31);
          const dateB = b.properties?.cg_registration_date ? new Date(b.properties.cg_registration_date) : new Date(9999, 11, 31);
          return this.state.isDescending ? dateB - dateA : dateA - dateB;
        },
        'bedrooms-desc': (a, b) => {
          const bedroomsA = parseInt(a.properties?.hs_bedrooms || 0);
          const bedroomsB = parseInt(b.properties?.hs_bedrooms || 0);
          return this.state.isDescending ? bedroomsA - bedroomsB : bedroomsB - bedroomsA;
        },
        'project': (a, b) => {
          const projectA = a.properties?.cg_project || '';
          const projectB = b.properties?.cg_project || '';
          const compare = projectA.localeCompare(projectB);
          return this.state.isDescending ? -compare : compare;
        },
        'newest': (a, b) => {
          // For demo, using ID as proxy for "newest" since we don't have created date
          const idA = parseInt(a.id || 0);
          const idB = parseInt(b.id || 0);
          return this.state.isDescending ? idB - idA : idA - idB;
        }
      };
      
      // Apply the selected sort function
      const sortFunction = sortFunctions[this.state.currentSort] || sortFunctions['default'];
      this.state.filteredProperties.sort(sortFunction);
      
      // Reset to first page when sort changes
      this.state.currentPage = 1;
    },
    
    getPriceValue(props) {
      if (!props) return 0;
      
      const price = parseFloat(props.hs_price || 
                  props.cg_listed_package_price || 
                  props.cg_build_list_price || 
                  props.cg_land_release_price || 0);
      return price;
    },
    
    // ========================
    // UI Rendering
    // ========================
    renderProperties() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      // Calculate page properties
      const startIndex = (this.state.currentPage - 1) * CONFIG.propertiesPerPage;
      const endIndex = startIndex + CONFIG.propertiesPerPage;
      const paginatedProperties = this.state.filteredProperties.slice(startIndex, endIndex);
      
      if (this.state.filteredProperties.length === 0) {
        this.renderNoResults();
        return;
      }
      
      let html = '<div class="cg-properties-grid">';
      
      // Add each property card
      paginatedProperties.forEach(property => {
        const props = property.properties || {};
        const id = property.id || '';
        
        // Get all details with proper null handling
        const rawListingType = props.hs_listing_type || props.cg_listing_type || '';
        const title = this.formatListingType(rawListingType);
        const project = props.cg_project || '';
        const stage = props.cg_stage || '';
        const dpLot = props.cg_dp_lot || '';
        const mpLot = props.cg_mp_lot || '';
        const suburb = props.hs_city || '';
        const neighborhood = props.hs_neighborhood || '';
        
        // Get address for property card
        const address = props.hs_address_1 || '';
        
        // Get formatted status and CSS class
        const statusRaw = props.cg_status || '';
        const status = this.formatFieldName(statusRaw);
        const statusClass = this.getStatusClass(statusRaw);
        
        const bedrooms = props.hs_bedrooms || '';
        const bathrooms = props.hs_bathrooms || '';
        const carSpaces = props.cg_car || '';
        const aspect = props.cg_aspect || 'N/A';
        const titleType = props.cg_title || '';
        const frontage = props.cg_frontage || '';
        const depth = props.cg_depth || '';
        const registrationDate = props.cg_registration_date || '';
        
        // Get price from various fields - prioritize cg_listed_package_price
        let price = props.cg_listed_package_price || props.hs_price || 
                   props.cg_build_list_price || props.cg_land_release_price || '';
        
        // Get more details
        const buildSize = props.cg_total_build_size || '';
        const lotSize = props.hs_lot_size || '';
        const landShape = this.formatFieldName(props.cg_land_type || '');
        const houseType = this.formatFieldName(props.cg_house_type || '');
        
        // Check if it's a new listing (for demo purposes, random)
        const isNew = Math.random() > 0.8; // 20% chance to be marked as new
        
        // Check if property is in favorites
        const isFavorite = this.state.favorites.includes(id);
        
        // Check if property is in compare list
        const isInCompare = this.state.compareProperties.some(p => p.id === id);
        
        // Check if it's a land listing - using cg_land field now
        const isLandOnly = props.cg_land ? true : false;
        
        // Display suburb as NSW
        const displaySuburb = suburb ? `${suburb}, NSW` : 'NSW';
        
        // Format title type display name from internal value
        let displayTitleType = '';
        if (titleType === 'cg_torrens') {
          displayTitleType = 'Torrens';
        } else if (titleType === 'cg_community') {
          displayTitleType = 'Community';
        } else {
          displayTitleType = titleType;
        }
        
        html += `
  <div class="cg-property-card" data-id="${id}">
    <a href="property-detail?id=${id}" class="cg-property-link">
      <!-- Removed the 'new' badge -->
      ${displayTitleType ? `<div class="cg-title-type-badge">${displayTitleType}</div>` : ''}
      
      <!-- Positioned favorites button at top-right instead of top-left -->
      <button type="button" class="cg-save-favorite ${isFavorite ? 'active' : ''}" 
              data-id="${id}" aria-label="Save to favorites">
        <i class="${isFavorite ? 'fas' : 'far'} fa-heart"></i>
      </button>
      
      <button type="button" class="cg-compare-badge ${isInCompare ? 'active' : ''}" 
              data-id="${id}" aria-label="Add to compare">
        <i class="fas fa-balance-scale"></i>
      </button>
      
      <div class="cg-property-header">
        <div class="cg-property-status cg-status-${statusClass}">${status}</div>
        <div class="cg-property-price">${this.formatPrice(price)}</div>
      </div>
      
      <div class="cg-property-content">
        <h3 class="cg-property-title">${title}</h3>
                
                <!-- Display address if available -->
                ${address ? `
                <div class="cg-property-location">
                  <i class="fas fa-map-marker-alt"></i>
                  ${address}${suburb ? `, ${suburb}, NSW` : ', NSW'}
                </div>` : ''}
                
                <div class="cg-property-meta">
                  ${project ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-project-diagram"></i>
                    <span><span class="cg-meta-label">Project:</span> ${this.formatFieldName(project)}</span>
                  </div>` : ''}
                  
                  ${stage ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-layer-group"></i>
                    <span><span class="cg-meta-label">Stage:</span> ${this.formatFieldName(stage)}</span>
                  </div>` : ''}
                  
                  ${dpLot ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-map"></i>
                    <span><span class="cg-meta-label">DP Lot:</span> ${dpLot}</span>
                  </div>` : ''}
                  
                  ${mpLot ? `
                  <div class="cg-meta-item">
                    <i class="fas fa-map-signs"></i>
                    <span><span class="cg-meta-label">MP Lot:</span> ${mpLot}</span>
                  </div>` : ''}
                </div>
                
                ${suburb && !address ? `
                <div class="cg-meta-item">
                  <i class="fas fa-city"></i>
                  <span><span class="cg-meta-label">Suburb:</span> ${displaySuburb}</span>
                </div>` : ''}
                
                ${neighborhood ? `
                <div class="cg-meta-item">
                  <i class="fas fa-building"></i>
                  <span><span class="cg-meta-label">Neighborhood:</span> ${neighborhood}</span>
                </div>` : ''}
                
                ${registrationDate ? `
                <div class="cg-registration-date">
                  <i class="fas fa-calendar-check"></i>
                  Registration: ${this.formatDate(registrationDate)}
                </div>` : ''}
                
                <!-- Add lot size badge -->
                <div class="cg-lot-size-badge">Low Density Residential</div>
                
                <div class="cg-property-specs">
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-ruler-combined"></i>
                    <div class="cg-spec-value">${lotSize || 'N/A'}</div>
                    <div class="cg-spec-label">Land m</div>
                  </div>
                  
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-compass"></i>
                    <div class="cg-spec-value">${aspect || 'N/A'}</div>
                    <div class="cg-spec-label">Aspect</div>
                  </div>
                  
                  <div class="cg-spec-item">
                    <i class="cg-spec-icon fas fa-arrows-alt-h"></i>
                    <div class="cg-spec-value">${frontage || 'N/A'}</div>
                    <div class="cg-spec-label">Frontage m</div>
                  </div>
                </div>
                
                <div class="cg-property-details">
                  ${displayTitleType ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Title Type:</div>
                    <div class="cg-detail-value">${displayTitleType}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && bedrooms ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Bedrooms:</div>
                    <div class="cg-detail-value">${bedrooms}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && bathrooms ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Bathrooms:</div>
                    <div class="cg-detail-value">${bathrooms}</div>
                  </div>` : ''}
                  
                  ${!isLandOnly && carSpaces ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Car Spaces:</div>
                    <div class="cg-detail-value">${carSpaces}</div>
                  </div>` : ''}
                  
                  ${frontage ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Frontage:</div>
                    <div class="cg-detail-value">${frontage}m</div>
                  </div>` : ''}
                  
                  ${depth ? `
                  <div class="cg-detail-row">
                    <div class="cg-detail-label">Depth:</div>
                    <div class="cg-detail-value">${depth}m</div>
                  </div>` : ''}
                </div>
                
                <div class="cg-property-cta">
                  <i class="fas fa-external-link-alt"></i> View Details
                </div>
              </div>
            </a>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      
      // Add event listeners to favorite and compare buttons
      document.querySelectorAll('.cg-save-favorite').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const propertyId = btn.getAttribute('data-id');
          this.toggleFavorite(propertyId, btn);
        });
      });
      
      document.querySelectorAll('.cg-compare-badge').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const propertyId = btn.getAttribute('data-id');
          this.toggleCompare(propertyId, btn);
        });
      });
      
      this.log(`Rendered ${paginatedProperties.length} properties for page ${this.state.currentPage}`);
    },
    
    renderNoResults() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      container.innerHTML = `
        <div class="cg-no-results">
          <h3 class="cg-no-results-title">No Properties Found</h3>
          <p class="cg-no-results-message">No properties match your current filters. Try adjusting your search criteria.</p>
          <button id="clear-all-filters" class="cg-btn-apply">Clear All Filters</button>
        </div>
      `;
      
      // Add event listener to the clear filters button
      document.getElementById('clear-all-filters').addEventListener('click', () => {
        this.clearAllFilters();
      });
    },
    
    renderError(errorMessage) {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      container.innerHTML = `
        <div class="cg-error-container">
          <h3 class="cg-error-title">Error Loading Properties</h3>
          <p class="cg-error-message">${errorMessage}</p>
          <div class="cg-error-buttons">
            <button id="btn-try-again" class="cg-error-btn">Try Again</button>
            <button id="btn-load-sample" class="cg-error-btn secondary">View Sample Properties</button>
          </div>
        </div>
      `;
      
      // Add event listeners for buttons
      const tryAgainBtn = document.getElementById('btn-try-again');
      if (tryAgainBtn) {
        tryAgainBtn.addEventListener('click', () => {
          this.loadProperties();
        });
      }
      
      // Add event listener for load sample button
      document.getElementById('btn-load-sample').addEventListener('click', () => {
        this.loadSampleProperties();
      });
    },
    
    // Show recovery options for Pipedream workflow issues
    showRecoveryOptions(errorType) {
      this.log(`Showing recovery options for error type: ${errorType}`);
      
      // Create a more detailed error message container
      const errorContainer = document.createElement('div');
      errorContainer.id = 'pipedream-error-container';
      errorContainer.style.position = 'fixed';
      errorContainer.style.top = '50%';
      errorContainer.style.left = '50%';
      errorContainer.style.transform = 'translate(-50%, -50%)';
      errorContainer.style.backgroundColor = 'white';
      errorContainer.style.padding = '30px';
      errorContainer.style.borderRadius = '8px';
      errorContainer.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
      errorContainer.style.zIndex = '10000';
      errorContainer.style.maxWidth = '500px';
      errorContainer.style.width = '90%';
      errorContainer.style.textAlign = 'center';
      
      // Special handling for Pipedream-specific errors
      if (errorType === 'pipedream') {
        const pipeContent = `
          <div style="font-size: 24px; font-weight: bold; color: #d32f2f; margin-bottom: 15px;">Pipedream Workflow Error</div>
          <div style="font-size: 16px; color: #666; margin-bottom: 20px; line-height: 1.5;">
            There was a problem loading property listings from the Pipedream workflow.
          </div>
          <div style="font-size: 14px; color: #333; margin-bottom: 25px; line-height: 1.5; text-align: left; background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow: auto; max-height: 200px;">
            <strong>Workflow Details:</strong><br>
            - The Pipedream workflow fetches properties from HubSpot via API<br>
            - Current endpoint: ${CONFIG.apiEndpoint}<br>
            - The workflow is configured to return property listings in JSON format<br>
            <br>
            <strong>Possible Issues:</strong><br>
            - The workflow may have reached its execution limit<br>
            - The HubSpot API may be temporarily unavailable<br>
            - The workflow configuration may need to be updated<br>
            - There may be authentication issues with the HubSpot API key
          </div>
          <div style="display: flex; justify-content: center; gap: 15px;">
            <button id="view-sample-data-btn" style="background-color: #0078d4; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">View Sample Properties</button>
            <button id="retry-connection-btn" style="background-color: #f0f0f0; color: #333; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">Try Again</button>
          </div>
        `;
        
        errorContainer.innerHTML = pipeContent;
        document.body.appendChild(errorContainer);
        
        // Add event listeners for buttons
        document.getElementById('view-sample-data-btn').addEventListener('click', () => {
          errorContainer.remove();
          this.loadSampleProperties();
        });
        
        document.getElementById('retry-connection-btn').addEventListener('click', () => {
          errorContainer.remove();
          if (typeof this.loadPropertiesWithRetry === 'function') {
            this.loadPropertiesWithRetry();
          } else {
            this.loadProperties();
          }
        });
        
        return;
      }
      
      // For other error types, create content based on error type
      let title, description;
      
      switch (errorType) {
        case 'timeout':
          title = 'Pipedream Workflow Timeout';
          description = 'The property data API is taking too long to respond. This could be due to Pipedream rate limits or workflow execution issues.';
          break;
        case 'data':
          title = 'Invalid Data Format';
          description = 'The Pipedream workflow is returning data in an unexpected format. The workflow may need to be updated.';
          break;
        case 'empty':
          title = 'No Properties Returned';
          description = 'The Pipedream workflow did not return any property listings. This could be due to workflow configuration issues.';
          break;
        default:
          title = 'Property Loading Error';
          description = 'There was a problem loading property listings from the Pipedream workflow.';
      }
      
      // Set the content
      errorContainer.innerHTML = `
        <div style="font-size: 24px; font-weight: bold; color: #d32f2f; margin-bottom: 15px;">${title}</div>
        <div style="font-size: 16px; color: #666; margin-bottom: 20px; line-height: 1.5;">
          ${description}
        </div>
        <div style="font-size: 14px; color: #666; margin-bottom: 25px; line-height: 1.5;">
          <strong>Possible solutions:</strong>
          <ul style="text-align: left; margin-top: 10px;">
            <li>Check if the Pipedream workflow is running properly</li>
            <li>Verify API endpoints in the configuration</li>
            <li>Check for rate limiting issues with Pipedream</li>
            <li>Ensure the workflow returns data in the expected format</li>
          </ul>
        </div>
        <div style="display: flex; justify-content: center; gap: 15px;">
          <button id="retry-api-btn" style="background-color: #0078d4; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">Try Again</button>
          <button id="show-sample-btn" style="background-color: #f0f0f0; color: #333; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">Show Sample Properties</button>
        </div>
        <div style="margin-top: 20px; font-size: 14px; color: #999;">
          Endpoint: ${CONFIG.apiEndpoint}
        </div>
      `;
      
      // Add to the document
      document.body.appendChild(errorContainer);
      
      // Add event listeners
      document.getElementById('retry-api-btn').addEventListener('click', () => {
        errorContainer.remove();
        this.loadProperties();
      });
      
      document.getElementById('show-sample-btn').addEventListener('click', () => {
        errorContainer.remove();
        this.loadSampleProperties();
      });
    },
    
    // Enhanced sample properties loader that works with original
    loadSampleProperties() {
      this.log('Loading sample properties as fallback');
      console.warn(' SAMPLE DATA: Real properties from API are not being loaded');
      
      // Check if we have previously successfully loaded real properties in localStorage
      const cachedRealProperties = localStorage.getItem('cg_real_properties_cache');
      if (cachedRealProperties && !CONFIG.forceSampleData) {
        try {
          const parsedCache = JSON.parse(cachedRealProperties);
          if (parsedCache && Array.isArray(parsedCache) && parsedCache.length > 0) {
            console.log(' Found cached real properties - using these instead of samples');
            this.state.allProperties = parsedCache;
            this.state.filteredProperties = [...parsedCache];
            this.populateFilterOptions();
            this.filterProperties();
            this.renderProperties();
            
            // Show a notice that cached data is being used
            this.showToast('Using Cached Data', 'Displaying previously loaded properties from cache.', 'info');
            return;
          }
        } catch (e) {
          console.error('Error loading cached real properties:', e);
        }
      }
      
      // Clear loading state
      this.state.isLoading = false;
      
      // Remove any existing error containers
      const errorContainer = document.getElementById('pipedream-error-container');
      if (errorContainer) {
        errorContainer.remove();
      }
      
      // Check if we can use the existing sample data method
      if (typeof this.getSampleProperties === 'function') {
        this.log('Using existing getSampleProperties method');
        
        // Use existing sample data method
        try {
          // Create a results object that matches the API response format
          const sampleData = this.getSampleProperties();
          const resultsObject = {
            success: true,
            results: sampleData,
            cached: true,
            cache_age: 0
          };
          
          // Update the state with sample properties
          this.state.allProperties = sampleData;
          this.state.filteredProperties = [...sampleData];
          
          // Apply filters and render
          this.populateFilterOptions();
          this.filterProperties();
          
          // Show existing sample data notice
          const existingNotice = document.querySelector('.cg-sample-data-notice');
          if (!existingNotice) {
            const notice = document.createElement('div');
            notice.className = 'cg-sample-data-notice';
            notice.innerHTML = '<i class="fas fa-info-circle"></i> Showing sample property data for NSW suburbs. The Pipedream workflow is currently unavailable.';
            const container = document.querySelector('.container');
            if (container) {
              container.prepend(notice);
            }
          }
          
          // Show toast message
          this.showToast('Sample Data Loaded', 'info');
          
          return; // Exit early because we used the existing method
        } catch (error) {
          this.log(`Error using existing sample data: ${error.message}`);
          // Continue to fallback implementation
        }
      }
      
      // Fallback implementation if the original method fails
      this.log('Using fallback sample properties');
      
      // Create sample property data
      const sampleProperties = [];
      
      // Create sample properties with realistic data structure
      for (let i = 1; i <= 12; i++) {
        sampleProperties.push({
          id: `sample-${i}`,
          properties: {
            cg_title: `Lot ${100 + i}`,
            cg_project: i % 3 === 0 ? 'Parkview Estate' : i % 3 === 1 ? 'Riverside Heights' : 'Green Valley',
            cg_stage: `Stage ${Math.ceil(i/4)}`,
            cg_dp_lot: `${100 + i}`,
            cg_description: `Sample property description for demonstration purposes. This is a fallback property shown when the Pipedream workflow fails.`,
            cg_status: i % 4 === 0 ? 'cg_under_offer' : 'cg_available',
            cg_price: 450000 + (i * 25000),
            hs_city: i % 2 === 0 ? 'Sydney' : 'Melbourne',
            hs_neighborhood: i % 2 === 0 ? 'North Shore' : 'Eastern Suburbs',
            cg_land_area: 350 + (i * 25),
            cg_dimensions: `${14 + (i % 4)}m x ${25 + (i % 3)}m`
          }
        });
      }
      
      // Create a results object that matches the API response format
      const resultsObject = {
        success: true,
        results: sampleProperties,
        cached: true,
        cache_age: 0
      };
      
      // Update the state with sample properties
      this.state.allProperties = resultsObject.results;
      
      // Apply filtering to match the expected workflow
      const includedStatuses = [
        "cg_exclusive",
        "cg_available", 
        "cg_under_offer",
        "cg_hold"
      ];
      
      // Filter out any properties with status not in includedStatuses
      this.state.allProperties = this.state.allProperties.filter(property => {
        const status = property.properties?.cg_status;
        return status && includedStatuses.includes(status);
      });
      
      this.state.filteredProperties = [...this.state.allProperties];
      
      // Reset all filters and sort
      this.populateFilterOptions();
      this.sortProperties();
      this.renderProperties();
      
      // Show a clear message to the user
      const container = document.getElementById('properties-container');
      if (container) {
        const sampleMessage = document.createElement('div');
        sampleMessage.className = 'cg-sample-notice';
        sampleMessage.style.backgroundColor = '#e3f2fd';
        sampleMessage.style.color = '#0d47a1';
        sampleMessage.style.padding = '15px';
        sampleMessage.style.marginBottom = '20px';
        sampleMessage.style.borderRadius = '4px';
        sampleMessage.style.textAlign = 'center';
        sampleMessage.style.fontWeight = 'bold';
        
        sampleMessage.innerHTML = `
          <div> SAMPLE DATA - FOR DEMONSTRATION ONLY </div>
          <div style="font-size: 14px; font-weight: normal; margin-top: 8px;">
            These are sample properties shown because the Pipedream workflow is not responding correctly.
            <br>Contact the site administrator to resolve the API issue.
          </div>
        `;
        
        container.insertBefore(sampleMessage, container.firstChild);
      }
      
      // Store the sample properties in localStorage
      try {
        localStorage.setItem('cg_cached_properties', JSON.stringify(sampleProperties));
        this.log('Saved sample properties to localStorage for future fallback use');
      } catch (error) {
        this.log(`Error saving sample properties to localStorage: ${error.message}`);
      }
      
      // Show toast notification
      if (typeof this.showToast === 'function') {
        this.showToast('Showing sample properties due to API issues', 'info');
      }
    },
    
    // Enhanced loading method with retry and Pipedream error handling
    async loadPropertiesWithRetry() {
      console.log(' Executing enhanced loadPropertiesWithRetry method');
      
      // Set up retry counter
      let retryCount = 0;
      const maxRetries = CONFIG.pipedreamRetries || 3; // Increased max retries
      
      // Cache check to see if we have recent data
      const cachedDataString = localStorage.getItem('cg_cached_properties');
      let cachedData = null;
      
      if (cachedDataString) {
        try {
          const parsedCache = JSON.parse(cachedDataString);
          const cacheTimestamp = localStorage.getItem('cg_cache_timestamp');
          const cacheAge = cacheTimestamp ? (Date.now() - parseInt(cacheTimestamp)) / 1000 / 60 : 999;
          
          // Only use cache if it's less than 30 minutes old
          if (cacheAge < 30 && Array.isArray(parsedCache) && parsedCache.length > 0) {
            cachedData = parsedCache;
            this.log(`Found valid cache (${cacheAge.toFixed(2)} minutes old) with ${cachedData.length} properties`);
          } else {
            this.log(`Cache exists but is too old (${cacheAge.toFixed(2)} minutes) or invalid`);
          }
        } catch (cacheError) {
          this.log(`Error parsing cache: ${cacheError.message}`);
        }
      }
      
      // Begin retry loop
      while (retryCount <= maxRetries) {
        try {
          this.log(`Attempt ${retryCount + 1}/${maxRetries + 1} to load properties`);
          
          // Try to load properties using the normal method
          await this.loadProperties();
          
          // If we get here, loading was successful
          return;
        } catch (error) {
          this.log(`Attempt ${retryCount + 1} failed: ${error.message}`);
          retryCount++;
          
          // If we have more retries, wait a bit and try again
          if (retryCount <= maxRetries) {
            this.log(`Retrying in ${retryCount} seconds...`);
            await new Promise(resolve => setTimeout(resolve, retryCount * 1000));
          } else {
            this.log('All retry attempts failed');
            
            // If we have cached data, use it
            if (cachedData) {
              this.log(`Using cached data as fallback with ${cachedData.length} properties`);
              
              // Store cached properties
              this.state.allProperties = cachedData;
              this.state.filteredProperties = [...cachedData];
              
              // Apply filtering
              this.populateFilterOptions();
              this.filterProperties();
              
              // Mark loading as complete
              this.state.isLoading = false;
              
              // Show notice about using cached data
              const container = document.getElementById('properties-container');
              if (container) {
                const cacheMessage = document.createElement('div');
                cacheMessage.className = 'cg-cache-notice';
                cacheMessage.style.backgroundColor = '#fff3cd';
                cacheMessage.style.color = '#856404';
                cacheMessage.style.padding = '15px';
                cacheMessage.style.marginBottom = '20px';
                cacheMessage.style.borderRadius = '4px';
                cacheMessage.style.textAlign = 'center';
                cacheMessage.innerHTML = `
                  <strong> USING CACHED DATA</strong><br>
                  <span style="font-size: 14px;">
                    The Pipedream workflow is currently unavailable. Showing cached property data.
                    Some information may be outdated.
                  </span>
                `;
                container.insertBefore(cacheMessage, container.firstChild);
              }
              
              // Show a toast
              this.showToast('Using cached property data', 'warning');
              
              return;
            }
            
            // Use sample data as a last resort
            this.log('No cache available, showing sample data as last resort');
            this.loadSampleProperties();
          }
        }
      }
    },
    
    displaySkeletonLoaders() {
      const container = document.getElementById('properties-container');
      if (!container) return;
      
      let html = '<div class="cg-properties-grid">';
      
      // Create 6 skeleton loaders
      for (let i = 0; i < 6; i++) {
        html += `
          <div class="cg-property-card">
            <div class="cg-property-header">
              <div class="cg-skeleton" style="width: 30%; height: 24px;"></div>
              <div class="cg-skeleton" style="width: 40%; height: 24px;"></div>
            </div>
            
            <div class="cg-property-content">
              <div class="cg-skeleton" style="width: 80%; height: 28px; margin-bottom: 12px;"></div>
              <div class="cg-skeleton" style="width: 60%; height: 18px; margin-bottom: 16px;"></div>
              
              <div class="cg-property-specs">
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
                <div class="cg-skeleton" style="width: 80%; height: 40px;"></div>
              </div>
              
              <div class="cg-property-details">
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
                <div class="cg-skeleton" style="width: 100%; height: 16px; margin: 8px 0;"></div>
              </div>
              
              <div class="cg-skeleton" style="width: 100%; height: 40px; margin-top: 20px;"></div>
            </div>
          </div>
        `;
      }
      
      html += '</div>';
      container.innerHTML = html;
    },
    
    updateResultsCount() {
      const container = document.getElementById('results-count');
      if (!container) return;
      
      if (this.state.filteredProperties.length === 0) {
        container.textContent = 'No properties match your current filters.';
      } else if (this.state.filteredProperties.length === 1) {
        container.textContent = '1 property found';
      } else {
        container.textContent = `${this.state.filteredProperties.length} properties found`;
      }
    },
    
    updatePagination() {
      const paginationContainer = document.getElementById('pagination');
      if (!paginationContainer) return;
      
      const totalPages = Math.ceil(this.state.filteredProperties.length / CONFIG.propertiesPerPage);
      
      // If only one page or no results, hide pagination
      if (totalPages <= 1) {
        paginationContainer.style.display = 'none';
        return;
      }
      
      paginationContainer.style.display = 'flex';
      let paginationHtml = '';
      
      // Previous button
      paginationHtml += `
        <button class="cg-pagination-btn prev-btn" ${this.state.currentPage === 1 ? 'disabled' : ''}>
          <i class="fas fa-chevron-left"></i>
        </button>
      `;
      
      // Page numbers
      const maxDisplayedPages = 5;
      let startPage = Math.max(1, this.state.currentPage - Math.floor(maxDisplayedPages / 2));
      let endPage = Math.min(totalPages, startPage + maxDisplayedPages - 1);
      
      // Adjust start page if end page is at maximum
      if (endPage === totalPages) {
        startPage = Math.max(1, endPage - maxDisplayedPages + 1);
      }
      
      // First page
      if (startPage > 1) {
        paginationHtml += `<button class="cg-pagination-btn" data-page="1">1</button>`;
        if (startPage > 2) {
          paginationHtml += `<span class="cg-pagination-ellipsis">...</span>`;
        }
      }
      
      // Page numbers
      for (let i = startPage; i <= endPage; i++) {
        paginationHtml += `
          <button class="cg-pagination-btn ${i === this.state.currentPage ? 'active' : ''}" data-page="${i}">
            ${i}
          </button>
        `;
      }
      
      // Last page
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          paginationHtml += `<span class="cg-pagination-ellipsis">...</span>`;
        }
        paginationHtml += `<button class="cg-pagination-btn" data-page="${totalPages}">${totalPages}</button>`;
      }
      
      // Next button
      paginationHtml += `
        <button class="cg-pagination-btn next-btn" ${this.state.currentPage === totalPages ? 'disabled' : ''}>
          <i class="fas fa-chevron-right"></i>
        </button>
      `;
      
      paginationContainer.innerHTML = paginationHtml;
      
      // Add event listeners to pagination buttons
      document.querySelectorAll('.cg-pagination-btn').forEach(button => {
        button.addEventListener('click', () => {
          if (button.hasAttribute('disabled')) return;
          
          if (button.classList.contains('prev-btn')) {
            if (this.state.currentPage > 1) {
              this.state.currentPage--;
              this.renderProperties();
              this.updatePagination();
            }
          } else if (button.classList.contains('next-btn')) {
            if (this.state.currentPage < totalPages) {
              this.state.currentPage++;
              this.renderProperties();
              this.updatePagination();
            }
          } else {
            const page = parseInt(button.getAttribute('data-page'));
            if (page !== this.state.currentPage) {
              this.state.currentPage = page;
              this.renderProperties();
              this.updatePagination();
            }
          }
          
          // Scroll to top of properties container
          document.getElementById('properties-container').scrollIntoView({ behavior: 'smooth' });
        });
      });
    },
    
    // ========================
    // Mapbox Integration
    // ========================
    async initializeMapView() {
      if (this.state.mapInitialized) return true;
      
      try {
        // Show loading indicator for the map
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          mapContainer.innerHTML = '<div class="cg-loading"><div class="cg-spinner"></div><p class="cg-loading-text">Loading map...</p></div>';
        }
        
        // Get token - now with async/await pattern
        try {
          this.state.mapboxToken = await this.getMapboxToken();
        } catch (tokenError) {
          this.log(`Token error: ${tokenError.message}, will attempt initialization anyway`);
        }
        
        if (!this.state.mapboxToken) {
          throw new Error("No valid Mapbox token available");
        }
        
        // Initialize map with proper error handling
        mapboxgl.accessToken = this.state.mapboxToken;
        
        // Check if mapboxgl is available
        if (!mapboxgl) {
          throw new Error("Mapbox GL JS library not loaded");
        }
        
        // Initialize map centered on Greater Sydney region
        this.state.map = new mapboxgl.Map({
          container: 'property-map',
          style: 'mapbox://styles/mapbox/streets-v11',
          center: [150.9000, -33.7500], // Center on Western Sydney where most suburbs are
          zoom: 9.5,
          attributionControl: true
        });
        
        // Add navigation controls
        this.state.map.addControl(new mapboxgl.NavigationControl(), 'top-left');
        
        // Add event handlers for map style controls
        document.getElementById('map-streets').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/streets-v11');
        });
        
        document.getElementById('map-satellite').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/satellite-v9');
        });
        
        document.getElementById('map-hybrid').addEventListener('click', (e) => {
          document.querySelectorAll('.cg-map-btn').forEach(btn => btn.classList.remove('active'));
          e.currentTarget.classList.add('active');
          this.state.map.setStyle('mapbox://styles/mapbox/satellite-streets-v11');
        });
        
        // Map property preview panel events
        document.getElementById('close-preview').addEventListener('click', () => {
          document.getElementById('map-property-preview').classList.add('cg-preview-hidden');
          
          // Reset previously selected marker if exists
          if (this.state.selectedMarker) {
            this.state.selectedMarker.getElement().style.width = '16px';
            this.state.selectedMarker.getElement().style.height = '16px';
            this.state.selectedMarker.getElement().style.zIndex = '1';
          }
          
          this.state.selectedMarker = null;
        });
        
        // When map loads, populate markers with proper error handling
        this.state.map.on('load', () => {
          try {
            // Make disclaimer always visible
            document.getElementById('map-disclaimer').style.display = 'block';
            
            // Process all properties - let renderPropertyMarkers handle the priority
            this.renderPropertyMarkers();
            this.state.mapInitialized = true;
            
            // Add bounds changed event to update visible properties
            this.state.map.on('moveend', () => {
              this.state.currentMapBounds = this.state.map.getBounds();
            });
            
            this.log("Map initialized successfully");
          } catch (markersError) {
            this.log(`Error rendering property markers: ${markersError.message}`);
            // Continue with map initialization even if markers fail
            this.state.mapInitialized = true;
          }
        });
        
        // Add error event handler
        this.state.map.on('error', (e) => {
          this.log(`Mapbox error: ${e.error ? e.error.message : 'Unknown error'}`);
        });
        
        return true;
      } catch (error) {
        this.log(`Error initializing map: ${error.message}`);
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          mapContainer.innerHTML = '<div class="cg-map-error">Unable to load map. Please try again later.</div>';
        }
        return false;
      }
    },
    
    renderPropertyMarkers() {
      // Clear existing markers
      this.clearMapMarkers();
      
      // If no properties, return
      if (!this.state.filteredProperties.length) {
        return;
      }
      
      // Create bounds object to fit all markers
      const bounds = new mapboxgl.LngLatBounds();
      let validMarkers = 0;
      
      // Process project properties with DIRECT coordinate forcing
      const projectProperties = this.state.filteredProperties.filter(p => 
        p.properties && p.properties.cg_project && PROJECT_COORDINATES[p.properties.cg_project]
      );
      
      // Process all project properties first with FORCED coordinates
      projectProperties.forEach(property => {
        try {
          const props = property.properties;
          const project = props.cg_project;
          
          // Get project center coordinates - this is now ALWAYS used
          const projectCenter = PROJECT_COORDINATES[project];
          
          // Generate a very small deterministic offset (max 50m)
          const offset = this.getControlledProjectOffset(property, projectCenter);
          
          // ALWAYS update property coordinates to forced values
          props.hs_latitude = (projectCenter.lat + offset.lat).toString();
          props.hs_longitude = (projectCenter.lng + offset.lng).toString();
          props._geocoding_source = 'project-forced';
          
          // Create marker with the strictly enforced coordinates
          const marker = this.createMarkerWithCoordinates(property, 
                                                projectCenter.lat + offset.lat, 
                                                projectCenter.lng + offset.lng);
          if (marker) {
            this.state.mapMarkers.push(marker);
            bounds.extend(marker.getLngLat());
            validMarkers++;
          }
        } catch (error) {
          this.log(`Error creating project marker for property ${property.id}: ${error.message}`);
        }
      });
      
      // Process remaining non-project properties normally
      const otherProperties = this.state.filteredProperties.filter(p => 
        !p.properties || 
        !p.properties.cg_project || 
        !PROJECT_COORDINATES[p.properties.cg_project]
      );
      
      // Regular handling for non-project properties
      let pendingGeocoding = 0;
      otherProperties.forEach(property => {
        try {
          const props = property.properties;
          
          // If we already have geocoded coordinates, create marker directly
          if (props?.hs_latitude && props?.hs_longitude) {
            const lat = parseFloat(props.hs_latitude);
            const lng = parseFloat(props.hs_longitude);
            
            if (!isNaN(lat) && !isNaN(lng) && this.isWithinNSWBounds(lat, lng)) {
              // Create marker directly
              const marker = this.createMarkerWithCoordinates(property, lat, lng);
              if (marker) {
                this.state.mapMarkers.push(marker);
                bounds.extend(marker.getLngLat());
                validMarkers++;
              }
              return;
            }
          }
          
          // Queue for geocoding
          pendingGeocoding++;
          this.queuePropertyForGeocoding(property, (coordinates) => {
            const marker = this.createMarkerWithCoordinates(property, coordinates.lat, coordinates.lng);
            if (marker) {
              this.state.mapMarkers.push(marker);
              bounds.extend(marker.getLngLat());
            }
          });
        } catch (error) {
          this.log(`Error creating non-project marker for property ${property.id}: ${error.message}`);
        }
      });
      
      // Update geocoding status message
      const statusElement = document.getElementById('geocoding-message');
      if (statusElement && pendingGeocoding > 0) {
        statusElement.textContent = `Geocoding ${pendingGeocoding} properties...`;
        document.getElementById('geocoding-status').style.display = 'block';
      } else if (statusElement) {
        document.getElementById('geocoding-status').style.display = 'none';
      }
      
      // If we have valid markers, fit map to bounds
      if (validMarkers > 0) {
        this.state.map.fitBounds(bounds, {
          padding: 50,
          maxZoom: 15
        });
        this.state.currentMapBounds = bounds;
        this.log(`Created ${validMarkers} property markers on map with ${pendingGeocoding} pending geocoding`);
      } else if (pendingGeocoding === 0) {
        this.log('No valid property markers could be created');
        
        // Show no results message on the map
        const mapContainer = document.getElementById('property-map');
        if (mapContainer) {
          const noResultsElement = document.createElement('div');
          noResultsElement.className = 'cg-map-error';
          noResultsElement.textContent = 'No properties could be located on the map. Try adjusting your filters or check back later.';
          mapContainer.appendChild(noResultsElement);
        }
      }
    },
    
    createMarkerWithCoordinates(property, lat, lng) {
      if (!this.state.map || isNaN(lat) || isNaN(lng)) return null;
      
      const props = property.properties || {};
      
      // If this is a forced project marker, don't modify coordinates
      if (props._geocoding_source === 'project-forced') {
        // Create marker directly with the forced coordinates
        const statusClass = this.getMarkerClass(props.cg_status || '');
        const el = document.createElement('div');
        el.className = `cg-map-marker ${statusClass}`;
        
        const marker = new mapboxgl.Marker(el)
          .setLngLat([lng, lat])
          .addTo(this.state.map);
        
        el.addEventListener('click', () => {
          this.showPropertyPreview(property, marker);
        });
        
        return marker;
      }
      
      // Get project if available for proximity validation
      const project = props.cg_project || '';
      const projectCenter = project && PROJECT_COORDINATES[project] ? 
        PROJECT_COORDINATES[project] : null;
      
      // FIXED: Always ensure coordinates are close to project if project is available
      if (projectCenter) {
        // Skip proximity check and ALWAYS use project coordinates with controlled offset
        const offset = this.getControlledProjectOffset(property, projectCenter);
        lat = projectCenter.lat + offset.lat;
        lng = projectCenter.lng + offset.lng;
        
        // Update property coordinates for consistency
        props.hs_latitude = lat.toString();
        props.hs_longitude = lng.toString();
        props._geocoding_source = 'project-marker-forced';
      }
      // Non-project properties can still use their coordinates with validation
      else {
        // Final verification that coordinates are within NSW
        if (!this.isWithinNSWBounds(lat, lng)) {
          // Fallback to suburb if needed
          if (props.hs_city && SUBURB_CENTERS[props.hs_city]) {
            const suburb = props.hs_city;
            const offset = this.generateDeterministicOffset(property, 0.0005);
            lat = SUBURB_CENTERS[suburb].lat + offset.lat;
            lng = SUBURB_CENTERS[suburb].lng + offset.lng;
            props._geocoding_source = 'suburb-marker-fallback';
            this.log(`Coordinates outside NSW bounds, using suburb fallback for ${suburb}`);
          } else {
            // Default to Sydney area
            const offset = this.generateDeterministicOffset(property, 0.003);
            lat = CONFIG.defaultLocation.lat + offset.lat;
            lng = CONFIG.defaultLocation.lng + offset.lng;
            props._geocoding_source = 'default-marker-fallback';
            this.log(`Coordinates outside NSW bounds, using Sydney fallback`);
          }
        }
      }
      
      // Update property coordinates
      props.hs_latitude = lat.toString();
      props.hs_longitude = lng.toString();
      
      // Get property status for marker color
      const status = props.cg_status || '';
      const statusClass = this.getMarkerClass(status);
      
      // Create marker element
      const el = document.createElement('div');
      el.className = `cg-map-marker ${statusClass}`;
      
      // Create marker
      const marker = new mapboxgl.Marker(el)
        .setLngLat([lng, lat])
        .addTo(this.state.map);
      
      // Add click event to marker
      el.addEventListener('click', () => {
        this.showPropertyPreview(property, marker);
      });
      
      return marker;
    },
    
    showPropertyPreview(property, marker) {
      const props = property.properties || {};
      const id = property.id || '';
      
      // Reset previously selected marker if exists
      if (this.state.selectedMarker) {
        this.state.selectedMarker.getElement().style.width = '16px';
        this.state.selectedMarker.getElement().style.height = '16px';
        this.state.selectedMarker.getElement().style.zIndex = '1';
      }
      
      // Update selected marker
      this.state.selectedMarker = marker;
      marker.getElement().style.width = '20px';
      marker.getElement().style.height = '20px';
      marker.getElement().style.zIndex = '10';
      
      // Get property details
      const title = this.formatListingType(props.hs_listing_type || '');
      const status = this.formatFieldName(props.cg_status || '');
      const statusClass = this.getStatusClass(props.cg_status || '');
      
      // Get price from various fields
      let price = props.cg_listed_package_price || props.hs_price || 
                 props.cg_build_list_price || props.cg_land_release_price || '';
      price = this.formatPrice(price);
      
      // Get property details for preview
      const lotSize = props.hs_lot_size ? `${props.hs_lot_size}m` : '';
      const frontage = props.cg_frontage ? `${props.cg_frontage}m frontage` : '';
      const aspect = props.cg_aspect || '';
      
      // Include address in preview if available
      const address = props.hs_address_1 || '';
      const suburb = props.hs_city || '';
      let locationText = '';
      
      if (address) {
        locationText += address;
      }
      if (suburb) {
        locationText += (locationText ? ', ' : '') + suburb;
      }
      
      // Build details string
      let detailsText = '';
      if (lotSize) detailsText += lotSize;
      if (frontage) detailsText += detailsText ? `  ${frontage}` : frontage;
      if (aspect) detailsText += detailsText ? `  ${aspect}` : aspect;
      
      // Update preview panel
      document.getElementById('preview-title').textContent = title;
      if (locationText) {
        document.getElementById('preview-title').textContent += ` - ${locationText}`;
      }
      
      document.getElementById('preview-status').textContent = status;
      document.getElementById('preview-status').className = `cg-preview-status cg-status-${statusClass}`;
      document.getElementById('preview-price').textContent = price;
      document.getElementById('preview-details').textContent = detailsText;
      
      // Set zoning info
      document.getElementById('preview-zoning-value').textContent = props.cg_zoning || 'Low Density Residential';
      document.getElementById('preview-school-zone').textContent = props.cg_school_zone || 'Local School Zone';
      
      // Update view details button
      document.getElementById('preview-view-btn').onclick = () => {
        window.location.href = `property-detail?id=${id}`;
      };
      
      // Show preview panel
      document.getElementById('map-property-preview').classList.remove('cg-preview-hidden');
    },
    
    clearMapMarkers() {
      this.state.mapMarkers.forEach(marker => marker.remove());
      this.state.mapMarkers = [];
    },
    // ========================
    // Geocoding Functions
    // ========================
    async getMapboxToken() {
      try {
        // Show token loading indicator if needed
        this.log("Fetching map credentials...");
        
        // Cache mechanism - check if we have a valid token already
        if (this.state.mapboxToken && this.state.tokenExpiry > Date.now()) {
          this.log("Using cached map token");
          return this.state.mapboxToken;
        }
        
        // Call the credentials endpoint
        const response = await fetch(CONFIG.mapboxApiEndpoint);
        
        if (!response.ok) {
          throw new Error(`Failed to get map credentials: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.success || !data.token) {
          throw new Error("Invalid credential response");
        }
        
        // Store token and expiry
        this.state.mapboxToken = data.token;
        this.state.tokenExpiry = data.expires || (Date.now() + (4 * 60 * 1000)); // 4 minutes from now as fallback
        
        this.log("Map credentials successfully retrieved");
        return this.state.mapboxToken;
      } catch (error) {
        this.log(`Error retrieving map token: ${error.message}`);
        // Fallback to default token for emergency cases only
        return 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4M29iazA2Z2gycXA4N2pmbDZmangifQ.-g_vE53SD2WrJ6tFX7QHmA';
      }
    },
    
    async geocodeAddress(property) {
      if (!property || !property.properties) {
        return { ...CONFIG.defaultLocation, source: 'default-no-property' };
      }
      
      const props = property.properties;
      const address = props.hs_address_1 || '';
      const suburb = props.hs_city || '';
      const project = props.cg_project || '';
      
      // Create a cache key from address, suburb, and project
      const cacheKey = `${address || ''}_${suburb || ''}_${project || ''}_${props.id || ''}`.toLowerCase().trim();
      
      // Check if we already have cached coordinates
      if (this.state.geocodingCache[cacheKey]) {
        return this.state.geocodingCache[cacheKey];
      }
      
      // Get project coordinates if available
      const projectCenter = project && PROJECT_COORDINATES[project] ? 
        PROJECT_COORDINATES[project] : null;
      
      // FIXED: Always prioritize project coordinates if available
      if (projectCenter) {
        // Create a deterministic offset for visual distribution
        const offset = this.getControlledProjectOffset(property, projectCenter);
        
        // CHANGE: Skip checking existing coordinates and always use project coordinates
        // This is the key change to enforce proximity
        const projectResult = {
          lat: projectCenter.lat + offset.lat,
          lng: projectCenter.lng + offset.lng,
          source: 'project-with-offset'
        };
        
        this.log(`Using project coordinates for "${project}" with deterministic offset`);
        this.state.geocodingCache[cacheKey] = projectResult;
        return projectResult;
      }
      
      // If no project is available, continue with standard geocoding
      
      // Try existing coordinates if available and valid
      if (props.hs_latitude && props.hs_longitude) {
        const lat = parseFloat(props.hs_latitude);
        const lng = parseFloat(props.hs_longitude);
        
        if (!isNaN(lat) && !isNaN(lng) && this.isWithinNSWBounds(lat, lng)) {
          const result = { lat, lng, source: 'existing-no-validation' };
          this.state.geocodingCache[cacheKey] = result;
          return result;
        }
      }
      
      // Try geocoding address if available
      if (address) {
        try {
          // Ensure we have a mapbox token
          if (!this.state.mapboxToken) {
            this.state.mapboxToken = await this.getMapboxToken();
          }
          
          // Build search query combining address and suburb
          const query = this.formatAddress(address, suburb);
          const encodedQuery = encodeURIComponent(query);
          
          // Make request to Mapbox Geocoding API
          const response = await fetch(
            `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedQuery}.json?access_token=${this.state.mapboxToken}&limit=1&country=au&region=au.nsw`
          );
          
          if (!response.ok) {
            throw new Error(`Geocoding failed: ${response.status}`);
          }
          
          const data = await response.json();
          
          // If we have results, check the coordinates
          if (data.features && data.features.length > 0) {
            const coordinates = data.features[0].center; // [lng, lat]
            const geocodedResult = {
              lng: coordinates[0],
              lat: coordinates[1],
              source: 'address-geocoded'
            };
            
            // Validate coordinates are in NSW
            if (this.isWithinNSWBounds(geocodedResult.lat, geocodedResult.lng)) {
              // Address geocoding is valid
              this.state.geocodingCache[cacheKey] = geocodedResult;
              return geocodedResult;
            }
          }
        } catch (error) {
          this.log(`Address geocoding error: ${error.message}`);
        }
      }
      
      // Suburb center if available
      if (suburb && SUBURB_CENTERS[suburb]) {
        const suburbCenter = SUBURB_CENTERS[suburb];
        const offset = this.generateDeterministicOffset(property, 0.0005);
        
        // Add deterministic offset for visual distribution
        const suburbResult = {
          lat: suburbCenter.lat + offset.lat,
          lng: suburbCenter.lng + offset.lng,
          source: 'suburb-with-offset'
        };
        
        this.log(`Using suburb center for "${suburb}" with deterministic offset`);
        this.state.geocodingCache[cacheKey] = suburbResult;
        return suburbResult;
      }
      
      // FALLBACK: Create a deterministic location in the Sydney area
      const offset = this.generateDeterministicOffset(property, 0.003);
      const fallbackResult = {
        lat: CONFIG.defaultLocation.lat + offset.lat,
        lng: CONFIG.defaultLocation.lng + offset.lng,
        source: 'sydney-fallback'
      };
      
      this.log(`Using fallback coordinates for unlocatable property`);
      this.state.geocodingCache[cacheKey] = fallbackResult;
      return fallbackResult;
    },
    
    async processGeocodingQueue() {
      if (this.state.isGeocodingInProgress || this.state.geocodingQueue.length === 0) {
        return;
      }
      
      this.state.isGeocodingInProgress = true;
      
      // Show geocoding status
      const statusContainer = document.getElementById('geocoding-status');
      const progressBar = document.getElementById('geocoding-progress-bar');
      const messageElement = document.getElementById('geocoding-message');
      
      if (statusContainer) statusContainer.style.display = 'block';
      
      const totalItems = this.state.geocodingQueue.length;
      let processedItems = 0;
      
      try {
        // Process items one by one with a small delay
        while (this.state.geocodingQueue.length > 0) {
          const item = this.state.geocodingQueue.shift();
          
          try {
            // Get coordinates using enhanced geocoding
            const coordinates = await this.geocodeAddress(item.property);
            
            // Update property with coordinates
            if (item.property && item.property.properties) {
              item.property.properties.hs_latitude = coordinates.lat.toString();
              item.property.properties.hs_longitude = coordinates.lng.toString();
              
              // Store geocoding source and details for debugging
              if (coordinates.source) {
                item.property.properties._geocoding_source = coordinates.source;
                
                // If we had to use project instead of address, store the distance for debugging
                if (coordinates.originalDistance) {
                  item.property.properties._distance_from_project = coordinates.originalDistance.toFixed(2) + "km";
                }
              }
            }
            
            // Call callback if provided
            if (item.callback) {
              item.callback(coordinates);
            }
          } catch (error) {
            this.log(`Error geocoding item: ${error.message}`);
          }
          
          // Update progress
          processedItems++;
          if (progressBar) {
            progressBar.style.width = `${(processedItems / totalItems) * 100}%`;
          }
          
          if (messageElement) {
            messageElement.textContent = `Geocoding properties... ${processedItems}/${totalItems}`;
          }
          
          // Add small delay to avoid hitting API rate limits
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } finally {
        this.state.isGeocodingInProgress = false;
        
        // Hide geocoding status after a delay
        setTimeout(() => {
          if (statusContainer) statusContainer.style.display = 'none';
        }, 1000);
        
        // Render markers if map is active
        if (this.state.mapInitialized && document.getElementById('map-view-container').style.display !== 'none') {
          this.renderPropertyMarkers();
        }
      }
    },
    
    queuePropertyForGeocoding(property, callback) {
      if (!property || !property.properties) return;
      
      // Add to geocoding queue with property information
      this.state.geocodingQueue.push({
        property,
        callback
      });
      
      // Start processing queue if not already in progress
      if (!this.state.isGeocodingInProgress) {
        this.processGeocodingQueue();
      }
    },
    
    // ========================
    // Helper Functions
    // ========================
    getControlledProjectOffset(property, projectCenter) {
      const props = property.properties || {};
      const id = property.id || '';
      const lot = props.cg_dp_lot || props.cg_mp_lot || '';
      
      // Create deterministic but tiny offset based on lot number
      const offsetMultiplier = 0.00005; // ~5-50 meters
      const seed = (parseInt(id.replace(/\D/g, '') || '0') + 
                  parseInt(lot.replace(/\D/g, '') || '0')) % 1000;
      
      // Create controlled circular pattern around project center
      const angle = (seed / 1000) * (Math.PI * 2); // 0-2 range
      const distance = Math.min(0.00001 + (seed % 10) * 0.000005, offsetMultiplier);
      
      return {
        lat: Math.sin(angle) * distance,
        lng: Math.cos(angle) * distance
      };
    },
    
    generateDeterministicOffset(property, baseMultiplier = 0.0001) {
      const props = property.properties || {};
      
      // Create a string to hash from property details
      const hashSource = [
        props.id || '',
        props.hs_address_1 || '',
        props.cg_dp_lot || '',
        props.cg_mp_lot || ''
      ].join('_');
      
      // Create a hash value
      const hashValue = this.hashString(hashSource);
      
      // Generate sin/cos values for the hash to get a position on a circle
      const angle = hashValue * 2 * Math.PI; // Convert to radians (0-2)
      
      // Calculate distance from center with a cap to avoid too large offsets
      const distance = Math.min(
        0.00005 + (Math.abs(Math.sin(hashValue * 5)) * baseMultiplier),
        baseMultiplier * 0.7
      );
      
      // Calculate offset using polar coordinates
      return {
        lat: Math.sin(angle) * distance,
        lng: Math.cos(angle) * distance
      };
    },
    
    hashString(str) {
      let hash = 0;
      if (!str || str.length === 0) return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return hash / 100000; // Scale to a reasonable number for use with trig functions
    },
    
    formatAddress(address, suburb) {
      if (!address && !suburb) return '';
      
      let formattedAddress = '';
      
      // Format address if available
      if (address) {
        formattedAddress = address.trim().replace(/,\s*$/, '');
        
        // Add suburb if not already included
        if (!formattedAddress.match(/,/) && !formattedAddress.match(/NSW/i)) {
          formattedAddress += suburb ? `, ${suburb}` : '';
        }
      } else if (suburb) {
        formattedAddress = suburb;
      }
      
      // Ensure NSW, Australia is added
      if (!formattedAddress.match(/NSW/i)) {
        formattedAddress += ', NSW';
      }
      if (!formattedAddress.match(/Australia/i)) {
        formattedAddress += ', Australia';
      }
      
      return formattedAddress;
    },
    
    calculateDistance(point1, point2) {
      if (!point1 || !point2) return Infinity;
      
      const R = 6371; // Earth's radius in km
      const dLat = (point2.lat - point1.lat) * Math.PI / 180;
      const dLng = (point2.lng - point1.lng) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c; // Distance in km
      
      return distance;
    },
    
    isWithinProjectProximity(coordinates, projectCoordinates, thresholdKm = CONFIG.geocodingThreshold) {
      if (!coordinates || !projectCoordinates) return false;
      
      const distance = this.calculateDistance(coordinates, projectCoordinates);
      return distance <= thresholdKm;
    },
    
    isWithinNSWBounds(lat, lng) {
      return (
        lat >= NSW_BOUNDS.south &&
        lat <= NSW_BOUNDS.north &&
        lng >= NSW_BOUNDS.west &&
        lng <= NSW_BOUNDS.east
      );
    },
    
    getMarkerClass(status) {
      if (!status) return 'available';
      
      const statusMap = {
        'cg_available': 'available',
        'cg_under_offer': 'under-offer',
        'cg_hold': 'hold',
        'cg_exclusive': 'exclusive'
      };
      
      return statusMap[status] || 'available';
    },
    
    getStatusClass(status) {
      if (!status) return 'available';
      
      const statusMap = {
        'cg_available': 'available',
        'cg_under_offer': 'under-offer',
        'cg_hold': 'hold',
        'cg_exclusive': 'exclusive'
      };
      
      return statusMap[status] || '';
    },
    
    formatFieldName(fieldName) {
      if (!fieldName) return '';
      return String(fieldName).replace(/^(cg_|hs_)/, '')
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    },
    
    formatListingType(listingType) {
      if (!listingType) return 'Property';
      
      // Convert to string and lowercase for consistent comparison
      const rawType = String(listingType).toLowerCase();
      
      // Remove prefixes like cg_ or hs_
      const cleanType = rawType.replace(/^(cg_|hs_)/, '');
      
      // Handle specific cases
      if (cleanType === 'land') {
        return 'Land';
      }
      
      if (cleanType === 'house' || cleanType.includes('house_and_land') || cleanType.includes('house-and-land')) {
        return 'House and Land';
      }
      
      if (cleanType === 'townhouse') {
        return 'Townhouse';
      }
      
      if (cleanType === 'apartment') {
        return 'Apartment';
      }
      
      // Default case: capitalize first letter of each word
      return cleanType
        .split(/[_\s-]/)  // Split on underscore, space, or hyphen
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    },
    
    formatPrice(price) {
      if (!price) return 'Contact for pricing';
      const numericPrice = String(price).replace(/[^\d.]/g, '');
      if (!numericPrice) return 'Contact for pricing';
      return '$' + parseFloat(numericPrice).toLocaleString();
    },
    
    formatDate(dateValue) {
      if (!dateValue) return 'Not specified';
      
      // Handle different date formats
      let date;
      
      // If it's a timestamp
      if (!isNaN(dateValue)) {
        date = new Date(parseInt(dateValue));
      } else {
        // Try to parse as ISO date
        date = new Date(dateValue);
      }
      
      // Check if date is valid
      if (isNaN(date.getTime())) {
        return dateValue; // Return original if not parseable
      }
      
      // Format the date
      const options = { year: 'numeric', month: 'short', day: 'numeric' };
      return date.toLocaleDateString('en-AU', options);
    },
    
    formatNumber(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    },
    
    // ========================
    // UI Interaction Setup
    // ========================
    initializeUIInteractions() {
      // Toggle filters visibility
      const toggleFiltersBtn = document.getElementById('toggle-filters');
      const toggleText = toggleFiltersBtn.querySelector('.toggle-text');
      const toggleIcon = toggleFiltersBtn.querySelector('i');
      const advancedFilters = [
        document.getElementById('advanced-filters'),
        document.getElementById('advanced-filters-2'),
        document.getElementById('advanced-filters-3')
      ];
      
      // Function to update filter display based on screen size
      const updateFilterDisplay = (filtersVisible) => {
        if (!filtersVisible) return; // Only update if filters are visible
        
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const displayType = isMobile ? 'flex' : 'grid';
        
        advancedFilters.forEach(filterRow => {
          if (filterRow && filterRow.style.display !== 'none') {
            filterRow.style.display = displayType;
          }
        });
      };
      
      // Handle window resize events
      window.addEventListener('resize', () => {
        const filtersVisible = advancedFilters[0].style.display !== 'none';
        updateFilterDisplay(filtersVisible);
      });
      
      toggleFiltersBtn.addEventListener('click', function() {
        const isVisible = advancedFilters[0].style.display !== 'none';
        
        // Check screen width to determine correct display type
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const newDisplay = isVisible ? 'none' : (isMobile ? 'flex' : 'grid');
        
        // Toggle button active state
        if (isVisible) {
          toggleFiltersBtn.classList.remove('active');
        } else {
          toggleFiltersBtn.classList.add('active');
        }
        
        // Toggle all advanced filter rows together
        advancedFilters.forEach(filterRow => {
          if (filterRow) filterRow.style.display = newDisplay;
        });
        
        toggleText.textContent = isVisible ? 'Show All Filters' : 'Hide Filters';
        toggleIcon.className = isVisible ? 'fas fa-chevron-down' : 'fas fa-chevron-up';
      });
      
      // Apply filters button
      document.getElementById('apply-filters').addEventListener('click', () => {
        this.filterProperties();
      });
      
      // Clear filters button
      document.getElementById('clear-filters').addEventListener('click', () => {
        this.clearAllFilters();
      });
      
      // Search button
      document.getElementById('search-button').addEventListener('click', () => {
        const searchInput = document.getElementById('property-search');
        this.state.filters.search = searchInput.value.toLowerCase();
        this.updateActiveFilters();
        this.filterProperties();
      });
      
      // Search input enter key
      document.getElementById('property-search').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          this.state.filters.search = e.target.value.toLowerCase();
          this.updateActiveFilters();
          this.filterProperties();
        }
      });
      
      // Sort selection change
      document.getElementById('sort-by').addEventListener('change', (e) => {
        this.state.currentSort = e.target.value;
        this.sortProperties();
        this.renderProperties();
      });
      
      // Sort direction toggle
      document.getElementById('toggle-direction').addEventListener('click', (e) => {
        this.state.isDescending = !this.state.isDescending;
        
        // Update UI
        const icon = e.currentTarget.querySelector('i');
        const text = e.currentTarget.querySelector('span');
        
        if (this.state.isDescending) {
          icon.className = 'fas fa-sort-amount-down';
          text.textContent = 'Descending';
        } else {
          icon.className = 'fas fa-sort-amount-up';
          text.textContent = 'Ascending';
        }
        
        this.sortProperties();
        this.renderProperties();
      });
      
      // Quick filter buttons
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.addEventListener('click', (e) => {
          // Remove active class from all quick filters and reset their styles
          document.querySelectorAll('.cg-quick-filter').forEach(b => {
            b.classList.remove('active');
            b.style.backgroundColor = '';
            b.style.borderColor = '';
            b.style.color = '';
            b.style.fontWeight = '';
            b.style.boxShadow = '';
          });
          
          // Add active class to clicked button
          e.currentTarget.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          e.currentTarget.style.backgroundColor = '#009688'; // --accent-color
          e.currentTarget.style.borderColor = '#009688'; // --accent-color
          e.currentTarget.style.color = '#ffffff'; // --white
          e.currentTarget.style.fontWeight = '600';
          e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
          
          // Apply the quick filter
          const filterType = e.currentTarget.getAttribute('data-filter');
          this.applyQuickFilter(filterType);
        });
      });
      
      // Toggle between grid and map views
      const gridViewToggle = document.getElementById('grid-view-toggle');
      const mapViewToggle = document.getElementById('map-view-toggle');
      const propertiesContainer = document.getElementById('properties-container');
      const mapViewContainer = document.getElementById('map-view-container');
      
      gridViewToggle.addEventListener('click', () => {
        gridViewToggle.classList.add('active');
        mapViewToggle.classList.remove('active');
        propertiesContainer.style.display = 'block';
        mapViewContainer.style.display = 'none';
      });
      
      mapViewToggle.addEventListener('click', async () => {
        // Switch to map view immediately to show loading state
        mapViewToggle.classList.add('active');
        gridViewToggle.classList.remove('active');
        propertiesContainer.style.display = 'none';
        mapViewContainer.style.display = 'block';
        
        // Initialize map if not already done
        if (!this.state.mapInitialized) {
          try {
            // Use await since initializeMapView is async
            const success = await this.initializeMapView();
            if (success) {
              this.log("Map initialized successfully");
            } else {
              this.log("Map initialization failed");
            }
          } catch (error) {
            this.log(`Error during map initialization: ${error.message}`);
          }
        } else {
          // If the map was previously initialized but needs a refresh
          try {
            this.renderPropertyMarkers();
            
            // Trigger a resize event to ensure map renders correctly
            if (this.state.map) {
              this.state.map.resize();
            }
          } catch (error) {
            this.log(`Error refreshing map: ${error.message}`);
          }
        }
      });
    },
    
    initializeFilters() {
      // Simple select filters
      const simpleFilters = [
        {id: 'project-filter', key: 'project'},
        {id: 'suburb-filter', key: 'suburb'},
        {id: 'neighborhood-filter', key: 'neighborhood'},
        {id: 'listing-type-filter', key: 'listingType'},
        {id: 'status-filter', key: 'status'},
        {id: 'land-shape-filter', key: 'landShape'},
        {id: 'aspect-filter', key: 'aspect'},
        {id: 'title-type-filter', key: 'titleType'},
        {id: 'registration-date-filter', key: 'registrationDate'},
        {id: 'storeys-filter', key: 'storeys'},
        {id: 'car-spaces-filter', key: 'minCarSpaces'}
      ];
      
      simpleFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            if (filter.key === 'minCarSpaces') {
              this.state.filters[filter.key] = e.target.value ? parseInt(e.target.value) : null;
            } else {
              this.state.filters[filter.key] = e.target.value;
            }
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Range filters
      const rangeFilters = [
        {id: 'price-filter', minKey: 'priceMin', maxKey: 'priceMax', label: 'Price'},
        {id: 'land-size-filter', minKey: 'landSizeMin', maxKey: 'landSizeMax', label: 'Land Size'},
        {id: 'build-size-filter', minKey: 'buildSizeMin', maxKey: 'buildSizeMax', label: 'Build Size'},
        {id: 'frontage-filter', minKey: 'frontageMin', maxKey: 'frontageMax', label: 'Frontage'},
        {id: 'depth-filter', minKey: 'depthMin', maxKey: 'depthMax', label: 'Depth'}
      ];
      
      rangeFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            const range = e.target.value.split('-');
            this.state.filters[filter.minKey] = range[0] ? parseInt(range[0]) : null;
            this.state.filters[filter.maxKey] = range[1] ? parseInt(range[1]) : null;
            if (range[0] && range[0].endsWith('+')) {
              this.state.filters[filter.minKey] = parseInt(range[0]);
              this.state.filters[filter.maxKey] = null;
            }
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Minimum value filters
      const minFilters = [
        {id: 'bedrooms-filter', key: 'minBedrooms', label: 'Bedrooms'},
        {id: 'bathrooms-filter', key: 'minBathrooms', label: 'Bathrooms'}
      ];
      
      minFilters.forEach(filter => {
        const element = document.getElementById(filter.id);
        if (element) {
          element.addEventListener('change', (e) => {
            this.state.filters[filter.key] = e.target.value ? parseInt(e.target.value) : null;
            this.updateActiveFilters();
            this.filterProperties();
          });
        }
      });
      
      // Search input with debounce for typing
      const searchInput = document.getElementById('property-search');
      if (searchInput) {
        let debounceTimeout;
        searchInput.addEventListener('input', (e) => {
          clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(() => {
            this.state.filters.search = e.target.value.toLowerCase();
            this.updateActiveFilters();
            this.filterProperties();
          }, 300); // 300ms debounce
        });
      }
    },
    
    updateActiveFilters() {
      const container = document.getElementById('active-filters');
      if (!container) return;
      
      // Clear existing filters
      container.innerHTML = '';
      
      // Helper to get select option text
      const getSelectOptionText = (selectId, value) => {
        const select = document.getElementById(selectId);
        if (!select) return value;
        
        const option = Array.from(select.options).find(opt => opt.value === value);
        return option ? option.textContent : (selectId === 'listing-type-filter' ? this.formatListingType(value) : this.formatFieldName(value));
      };
      
      // Check if we have any active filters
      let hasActiveFilters = false;
      
      // Add active filter pills
      if (this.state.filters.search) {
        this.addFilterPill(container, 'Search', `"${this.state.filters.search}"`, () => {
          this.state.filters.search = '';
          document.getElementById('property-search').value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.project) {
        this.addFilterPill(container, 'Project', getSelectOptionText('project-filter', this.state.filters.project), () => {
          this.state.filters.project = '';
          const element = document.getElementById('project-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.suburb) {
        this.addFilterPill(container, 'Suburb', getSelectOptionText('suburb-filter', this.state.filters.suburb), () => {
          this.state.filters.suburb = '';
          const element = document.getElementById('suburb-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.neighborhood) {
        this.addFilterPill(container, 'Neighborhood', getSelectOptionText('neighborhood-filter', this.state.filters.neighborhood), () => {
          this.state.filters.neighborhood = '';
          const element = document.getElementById('neighborhood-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      if (this.state.filters.listingType) {
        this.addFilterPill(container, 'Listing Type', getSelectOptionText('listing-type-filter', this.state.filters.listingType), () => {
          this.state.filters.listingType = '';
          const element = document.getElementById('listing-type-filter');
          if (element) element.value = '';
          
          // Reset the quick filter buttons when removing a listing type filter
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Only filter pill if active
      if (this.state.filters.isLandOnly) {
        this.addFilterPill(container, 'Type', 'Land Only', () => {
          this.state.filters.isLandOnly = false;
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Title Type filter pill showing the display value (Torrens/Community)
      if (this.state.filters.titleType) {
        let displayValue = this.state.filters.titleType;
        if (this.state.filters.titleType === 'cg_torrens') {
          displayValue = 'Torrens';
        } else if (this.state.filters.titleType === 'cg_community') {
          displayValue = 'Community';
        }
        
        this.addFilterPill(container, 'Title Type', displayValue, () => {
          this.state.filters.titleType = '';
          const element = document.getElementById('title-type-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Status filter pill (from Available quick filter)
      if (this.state.filters.status) {
        let displayValue = 'Available';
        if (this.state.filters.status === 'cg_available') {
          displayValue = 'Available';
        } else {
          displayValue = this.formatFieldName(this.state.filters.status);
        }
        
        this.addFilterPill(container, 'Status', displayValue, () => {
          this.state.filters.status = '';
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Registration Date filter pill (from Registered quick filter)
      if (this.state.filters.registrationDate) {
        let displayValue = 'Registered';
        if (this.state.filters.registrationDate === 'registered') {
          displayValue = 'Registered';
        } else {
          displayValue = this.formatFieldName(this.state.filters.registrationDate);
        }
        
        this.addFilterPill(container, 'Registration', displayValue, () => {
          this.state.filters.registrationDate = '';
          
          // Reset the quick filter buttons - set "All Properties" as active
          this.resetQuickFilters('all');
          
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Shape filter pill
      if (this.state.filters.landShape) {
        this.addFilterPill(container, 'Land Shape', getSelectOptionText('land-shape-filter', this.state.filters.landShape), () => {
          this.state.filters.landShape = '';
          const element = document.getElementById('land-shape-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Aspect filter pill
      if (this.state.filters.aspect) {
        this.addFilterPill(container, 'Aspect', getSelectOptionText('aspect-filter', this.state.filters.aspect), () => {
          this.state.filters.aspect = '';
          const element = document.getElementById('aspect-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Price Range filter pill
      if (this.state.filters.priceMin || this.state.filters.priceMax) {
        let displayValue = '';
        if (this.state.filters.priceMin && this.state.filters.priceMax) {
          displayValue = `${parseFloat(this.state.filters.priceMin).toLocaleString()} - ${parseFloat(this.state.filters.priceMax).toLocaleString()}`;
        } else if (this.state.filters.priceMin) {
          displayValue = `${parseFloat(this.state.filters.priceMin).toLocaleString()}+`;
        } else if (this.state.filters.priceMax) {
          displayValue = `Up to ${parseFloat(this.state.filters.priceMax).toLocaleString()}`;
        }
        
        this.addFilterPill(container, 'Price', displayValue, () => {
          this.state.filters.priceMin = null;
          this.state.filters.priceMax = null;
          const element = document.getElementById('price-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Bedrooms filter pill
      if (this.state.filters.minBedrooms) {
        this.addFilterPill(container, 'Bedrooms', `${this.state.filters.minBedrooms}+`, () => {
          this.state.filters.minBedrooms = null;
          const element = document.getElementById('bedrooms-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Bathrooms filter pill
      if (this.state.filters.minBathrooms) {
        this.addFilterPill(container, 'Bathrooms', `${this.state.filters.minBathrooms}+`, () => {
          this.state.filters.minBathrooms = null;
          const element = document.getElementById('bathrooms-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Car Spaces filter pill
      if (this.state.filters.minCarSpaces) {
        this.addFilterPill(container, 'Car Spaces', `${this.state.filters.minCarSpaces}+`, () => {
          this.state.filters.minCarSpaces = null;
          const element = document.getElementById('car-spaces-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Land Size filter pill
      if (this.state.filters.landSizeMin || this.state.filters.landSizeMax) {
        let displayValue = '';
        if (this.state.filters.landSizeMin && this.state.filters.landSizeMax) {
          displayValue = `${this.state.filters.landSizeMin} - ${this.state.filters.landSizeMax}m`;
        } else if (this.state.filters.landSizeMin) {
          displayValue = `${this.state.filters.landSizeMin}m+`;
        } else if (this.state.filters.landSizeMax) {
          displayValue = `Up to ${this.state.filters.landSizeMax}m`;
        }
        
        this.addFilterPill(container, 'Land Size', displayValue, () => {
          this.state.filters.landSizeMin = null;
          this.state.filters.landSizeMax = null;
          const element = document.getElementById('land-size-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Build Size filter pill
      if (this.state.filters.buildSizeMin || this.state.filters.buildSizeMax) {
        let displayValue = '';
        if (this.state.filters.buildSizeMin && this.state.filters.buildSizeMax) {
          displayValue = `${this.state.filters.buildSizeMin} - ${this.state.filters.buildSizeMax}m`;
        } else if (this.state.filters.buildSizeMin) {
          displayValue = `${this.state.filters.buildSizeMin}m+`;
        } else if (this.state.filters.buildSizeMax) {
          displayValue = `Up to ${this.state.filters.buildSizeMax}m`;
        }
        
        this.addFilterPill(container, 'Build Size', displayValue, () => {
          this.state.filters.buildSizeMin = null;
          this.state.filters.buildSizeMax = null;
          const element = document.getElementById('build-size-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Frontage filter pill
      if (this.state.filters.frontageMin || this.state.filters.frontageMax) {
        let displayValue = '';
        if (this.state.filters.frontageMin && this.state.filters.frontageMax) {
          displayValue = `${this.state.filters.frontageMin} - ${this.state.filters.frontageMax}m`;
        } else if (this.state.filters.frontageMin) {
          displayValue = `${this.state.filters.frontageMin}m+`;
        } else if (this.state.filters.frontageMax) {
          displayValue = `Up to ${this.state.filters.frontageMax}m`;
        }
        
        this.addFilterPill(container, 'Frontage', displayValue, () => {
          this.state.filters.frontageMin = null;
          this.state.filters.frontageMax = null;
          const element = document.getElementById('frontage-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Add Depth filter pill
      if (this.state.filters.depthMin || this.state.filters.depthMax) {
        let displayValue = '';
        if (this.state.filters.depthMin && this.state.filters.depthMax) {
          displayValue = `${this.state.filters.depthMin} - ${this.state.filters.depthMax}m`;
        } else if (this.state.filters.depthMin) {
          displayValue = `${this.state.filters.depthMin}m+`;
        } else if (this.state.filters.depthMax) {
          displayValue = `Up to ${this.state.filters.depthMax}m`;
        }
        
        this.addFilterPill(container, 'Depth', displayValue, () => {
          this.state.filters.depthMin = null;
          this.state.filters.depthMax = null;
          const element = document.getElementById('depth-filter');
          if (element) element.value = '';
          this.filterProperties();
        });
        hasActiveFilters = true;
      }
      
      // Show/hide the filter buttons based on active filters
      document.getElementById('filter-buttons').style.display = hasActiveFilters ? 'flex' : 'none';
    },
    
    // Helper function to reset quick filter buttons
    resetQuickFilters(activeFilterType) {
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.classList.remove('active');
        
        // Reset all inline styles
        btn.style.backgroundColor = '';
        btn.style.borderColor = '';
        btn.style.color = '';
        btn.style.fontWeight = '';
        btn.style.boxShadow = '';
        
        // Apply active class and styles to the specified filter
        if (btn.getAttribute('data-filter') === activeFilterType) {
          btn.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          btn.style.backgroundColor = '#009688'; // --accent-color
          btn.style.borderColor = '#009688'; // --accent-color
          btn.style.color = '#ffffff'; // --white
          btn.style.fontWeight = '600';
          btn.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
        }
      });
    },
    
    addFilterPill(container, label, value, removeCallback) {
      // Create a pill with explicit styling to ensure it appears highlighted
      const pill = document.createElement('div');
      pill.className = 'cg-filter-pill active'; // Add active class by default
      
      // Apply inline styles as a fallback to ensure it's visually highlighted
      // Use the same accent color as defined in CSS variables
      pill.style.backgroundColor = '#009688'; // --accent-color
      pill.style.color = '#ffffff'; // --white
      pill.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
      pill.style.borderColor = '#009688'; // --accent-color
      
      pill.innerHTML = `
        <span><span class="cg-filter-pill-label">${label}:</span> ${value}</span>
        <i class="cg-filter-pill-remove fas fa-times"></i>
      `;
      
      // Store the data attributes for identification
      pill.dataset.filterLabel = label;
      pill.dataset.filterValue = value;
      
      // Enhanced remove callback to reset quick filters
      const enhancedRemoveCallback = () => {
        // Call the original callback
        removeCallback();
        
        // After a small delay, make sure the quick filters are properly updated
        setTimeout(() => {
          // Determine which filter should be active based on current filters
          let activeFilter = 'all';
          if (this.state.filters.status === 'cg_available') {
            activeFilter = 'available';
          } else if (this.state.filters.listingType === 'house') {
            activeFilter = 'house-and-land';
          } else if (this.state.filters.listingType === 'cg_land') {
            activeFilter = 'land-only';
          } else if (this.state.filters.registrationDate === 'registered') {
            activeFilter = 'registered';
          }
          
          // Reset quick filters to the appropriate active state
          this.resetQuickFilters(activeFilter);
        }, 0);
      };
      
      // Replace the original removeCallback with our enhanced version
      pill.querySelector('.cg-filter-pill-remove').addEventListener('click', function(e) {
        // Prevent event bubbling
        e.stopPropagation();
        
        // Call our enhanced callback
        enhancedRemoveCallback();
        
        // Remove this pill directly from the DOM
        pill.remove();
      });
      
      // Ensure active class is applied even after any DOM manipulation
      requestAnimationFrame(() => {
        pill.classList.add('active');
        
        // Double check styling after the browser has rendered
        if (window.getComputedStyle(pill).backgroundColor !== 'rgb(0, 150, 136)') {
          // If not our accent color, force it
          pill.style.backgroundColor = '#009688';
          pill.style.color = '#ffffff';
        }
      });
      
      container.appendChild(pill);
    },
    
    clearAllFilters() {
      // Reset all filter selects
      document.querySelectorAll('.cg-filter-select').forEach(select => {
        select.value = '';
      });
      
      // Clear search
      document.getElementById('property-search').value = '';
      
      // Reset filter object
      for (let key in this.state.filters) {
        if (key === 'search' || key.includes('Min') || key.includes('Max')) {
          this.state.filters[key] = null;
        } else if (key === 'isLandOnly') {
          this.state.filters[key] = false;
        } else {
          this.state.filters[key] = '';
        }
      }
      
      // Clear active filters display
      document.getElementById('active-filters').innerHTML = '';
      
      // Reset quick filters - set "All Properties" as active
      this.resetQuickFilters('all');
      
      // Apply cleared filters
      this.filterProperties();
      
      // Show success toast
      this.showToast('Filters cleared', 'All filters have been reset.', 'success');
    },
    
    applyQuickFilter(filterType) {
      // Clear existing filters
      this.clearAllFilters();
      
      // First, manually set the active class on the appropriate quick filter button
      document.querySelectorAll('.cg-quick-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-filter') === filterType) {
          btn.classList.add('active');
          
          // Force the style to be applied with inline styles as a fallback
          btn.style.backgroundColor = '#009688'; // --accent-color
          btn.style.borderColor = '#009688'; // --accent-color
          btn.style.color = '#ffffff'; // --white
          btn.style.fontWeight = '600';
          btn.style.boxShadow = '0 1px 3px rgba(0,0,0,0.05)'; // --shadow-sm
        }
      });
      
      // Apply specific quick filter
      switch (filterType) {
        case 'available':
          this.state.filters.status = 'cg_available';
          break;
        case 'house-and-land':
          // Set to check for 'house' value in hs_listing_type
          this.state.filters.listingType = 'house';
          break;
        case 'land-only':
          // Set to check for 'cg_land' value in hs_listing_type
          this.state.filters.listingType = 'cg_land';
          break;
        case 'registered':
          this.state.filters.registrationDate = 'registered';
          break;
        case 'all':
        default:
          // All filters are already cleared
          break;
      }
      
      // Update active filters and filter properties
      this.updateActiveFilters();
      this.filterProperties();
      
      // Use requestAnimationFrame to make sure the style is applied after browser rendering
      requestAnimationFrame(() => {
        document.querySelectorAll('.cg-quick-filter').forEach(btn => {
          if (btn.getAttribute('data-filter') === filterType) {
            btn.classList.add('active');
          }
        });
      });
    },
    
    populateFilterOptions() {
      // Get unique values for each filter
      const projects = new Set();
      const statuses = new Set();
      const landShapes = new Set();
      const aspects = new Set();
      const listingTypes = new Set();
      const titleTypes = new Set();
      const neighborhoods = new Set();
      const suburbs = new Set();
      const storeys = new Set();
      
      this.state.allProperties.forEach(property => {
        const props = property.properties || {};
        
        // Add project if available
        if (props.cg_project) {
          projects.add(props.cg_project);
        }
        
        // Add status if available
        if (props.cg_status) {
          statuses.add(props.cg_status);
        }
        
        // Add land shape (formerly type) if available
        if (props.cg_land_type) {
          landShapes.add(props.cg_land_type);
        }
        
        // Add aspect if available
        if (props.cg_aspect) {
          aspects.add(props.cg_aspect);
        }
        
        // Add listing type if available
        if (props.hs_listing_type) {
          listingTypes.add(props.hs_listing_type);
        }
        
        // Add title type if available - note: we handle this explicitly in the UI now
        // with the correct internal values cg_torrens and cg_community
        
        // Add neighborhood if available
        if (props.hs_neighborhood) {
          neighborhoods.add(props.hs_neighborhood);
        }
        
        // Add suburb if available
        if (props.hs_city) {
          suburbs.add(props.hs_city);
        }
        
        // Add storeys if available
        if (props.cg_storeys) {
          storeys.add(props.cg_storeys);
        }
      });
      
      // Populate project filter
      this.populateSelect('project-filter', projects);
      
      // Populate suburb filter
      this.populateSelect('suburb-filter', suburbs);
      
      // Populate neighborhood filter
      this.populateSelect('neighborhood-filter', neighborhoods);
      
      // Populate listing type filter
      this.populateSelect('listing-type-filter', listingTypes);
      
      // Populate status filter
      this.populateSelect('status-filter', statuses);
      
      // Populate land shape filter
      this.populateSelect('land-shape-filter', landShapes);
      
      // Populate aspect filter (keeping the defaults)
      this.populateSelect('aspect-filter', aspects, true);
      
      // We don't populate the Title Type filter as it now has fixed options
      // cg_torrens and cg_community with display values Torrens and Community
    },
    
    populateSelect(selectId, optionsSet, keepDefaults = false) {
      const select = document.getElementById(selectId);
      if (!select) return;
      
      // Keep the first option (e.g., "All Projects")
      const firstOption = select.options[0];
      
      if (!keepDefaults) {
        select.innerHTML = '';
        select.appendChild(firstOption);
      } else {
        // Keep existing options (for predefined selections like title types)
        const existingOptions = Array.from(select.options);
        const existingValues = existingOptions.map(opt => opt.value);
        
        // Filter out values that already exist in the dropdown
        optionsSet = Array.from(optionsSet).filter(value => !existingValues.includes(value));
      }
      
      // Add options to select
      Array.from(optionsSet).sort().forEach(value => {
        const option = document.createElement('option');
        option.value = value;
        
        // Use special formatting for listing types
        if (selectId === 'listing-type-filter') {
          option.textContent = this.formatListingType(value);
        } else {
          option.textContent = this.formatFieldName(value);
        }
        
        select.appendChild(option);
      });
    },
    
    loadSampleData() {
      const sampleData = this.getSampleProperties();
      this.state.allProperties = sampleData;
      this.populateFilterOptions();
      this.filterProperties();
      
      // Add sample data notice with enhanced visibility
      const existingNotice = document.querySelector('.cg-sample-data-notice');
      if (!existingNotice) {
        const notice = document.createElement('div');
        notice.className = 'cg-sample-data-notice';
        notice.style.cssText = 'background-color: #ffcc00; color: #000; padding: 15px; margin: 15px 0; border-radius: 5px; font-weight: bold; border: 2px solid #cc9900; text-align: center; position: sticky; top: 10px; z-index: 100;';
        notice.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ATTENTION: Showing SAMPLE property data only. Real API data is currently unavailable. <button id="retry-real-data" style="background: #006600; color: white; border: none; padding: 5px 10px; border-radius: 3px; margin-left: 10px; cursor: pointer;">Try Load Real Data</button>';
        
        document.querySelector('.container').prepend(notice);
        
        // Add event handler for the retry button after a short delay
        setTimeout(() => {
          const retryButton = document.getElementById('retry-real-data');
          if (retryButton) {
            retryButton.addEventListener('click', (e) => {
              e.preventDefault();
              // Clear cache and try loading again
              localStorage.removeItem('cg_properties_cache');
              localStorage.removeItem('cg_cached_properties');
              if (window.CastleApp && typeof window.CastleApp.loadPropertiesWithRetry === 'function') {
                window.CastleApp.loadPropertiesWithRetry();
              }
            });
          }
        }, 500);
      }
      
      // Show success toast
      this.showToast('Sample Data Loaded', 'Using sample property listings for demonstration.', 'info');
    },
    
    // Get sample properties for NSW suburbs
    getSampleProperties() {
      // Important - Log that we're using sample data instead of real properties
      console.warn(' WARNING: Using sample properties instead of real property data');
      console.log(' If you see this message when properties should be loaded from API, check the API response');
      
      // Try to load from localStorage first if we have cached real properties
      const cachedProperties = localStorage.getItem('cg_properties_cache');
      if (cachedProperties) {
        try {
          const parsedCache = JSON.parse(cachedProperties);
          if (parsedCache && Array.isArray(parsedCache) && parsedCache.length > 0) {
            console.log(' Using cached real properties from localStorage instead of samples');
            return parsedCache;
          }
        } catch (e) {
          console.error('Error parsing cached properties:', e);
        }
      }
      
      // Return 12 sample properties with NSW suburbs
      const listingTypes = ['House & Land Package', 'Land Only', 'Townhouse', 'Apartment'];
      const aspects = ['North', 'South', 'East', 'West', 'North East', 'North West', 'South East', 'South West'];
      const titleTypes = ['cg_torrens', 'cg_community', 'cg_torrens', 'cg_torrens'];
      const neighborhoods = ['Valley View', 'Riverside', 'Highland Hills', 'Ocean Breeze'];
      const suburbs = ['Austral', 'Kellyville', 'Leppington', 'Oakville', 'Pitt Town', 'Rouse Hill', 'Vineyard'];
      const streets = [
        '10 Smith Street', 
        '42 Beach Road', 
        '78 Main Street', 
        '15 Park Avenue',
        '25 Harbor View',
        '33 Mountain Drive',
        '55 Sunset Boulevard',
        '18 Riverview Lane',
        '63 Ocean Drive',
        '27 Hillside Crescent',
        '39 Valley Road',
        '84 Lakeside Drive'
      ];
      
      return Array(12).fill().map((_, index) => ({
        id: `sample-${index + 1}`,
        properties: {
          hs_listing_type: listingTypes[index % 4],
          cg_project: ['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4],
          cg_stage: `${Math.floor(index / 4) + 1}`,
          cg_dp_lot: `${index + 101}`,
          cg_mp_lot: `${index + 501}`,
          cg_status: ['cg_available', 'cg_hold', 'cg_under_offer', 'cg_exclusive'][index % 4],
          cg_listed_package_price: (500000 + (index * 50000)).toString(),
          hs_price: (450000 + (index * 45000)).toString(),
          hs_lot_size: (350 + (index * 50)).toString(),
          cg_total_build_size: (180 + (index * 20)).toString(),
          hs_bedrooms: (3 + (index % 3)).toString(),
          hs_bathrooms: (2 + (index % 3)).toString(),
          cg_car: (index % 3 + 1).toString(),
          cg_house_type: ['Single Story', 'Double Story', 'Townhouse', 'Duplex'][index % 4],
          cg_land_type: ['Corner', 'Standard', 'Premium', 'Waterfront'][index % 4],
          cg_facade: ['Modern', 'Contemporary', 'Traditional', 'Hampton'][index % 4],
          cg_aspect: aspects[index % 8],
          cg_title: titleTypes[index % 4],
          cg_frontage: (10 + (index % 15)).toString(),
          cg_depth: (25 + (index % 20)).toString(),
          cg_registration_date: new Date(2024, 5 + (index % 12), 15 + (index % 10)).toISOString().split('T')[0],
          cg_storeys: (1 + (index % 3)).toString(),
          hs_neighborhood: neighborhoods[index % 4],
          hs_city: suburbs[index % suburbs.length],
          // NSW-specific address
          hs_address_1: `${streets[index % streets.length]}, ${suburbs[index % suburbs.length]}`,
          // Added fields for residential lots enhancement
          cg_zoning: 'Low Density Residential',
          cg_school_zone: ['North High School', 'South Primary School', 'West Heights School', 'East Valley School'][index % 4],
          // Added the cg_land field for Land Only properties (for every other property)
          cg_land: index % 2 === 0 ? 'true' : '', 
          // Generate coordinates for sample data using project coordinates if available
          hs_latitude: PROJECT_COORDINATES[['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4]]?.lat + (Math.sin(index) * 0.0005) || 
                     (SUBURB_CENTERS[suburbs[index % suburbs.length]].lat + (Math.random() - 0.5) * 0.01),
          hs_longitude: PROJECT_COORDINATES[['Meadowview', 'Riverside Estates', 'Highland Park', 'Summit Ridge'][index % 4]]?.lng + (Math.cos(index) * 0.0005) || 
                      (SUBURB_CENTERS[suburbs[index % suburbs.length]].lng + (Math.random() - 0.5) * 0.01)
        }
      }));
    },
    
    // ========================
    // Favorites & Compare
    // ========================
    toggleFavorite(propertyId, button) {
      const isFavorite = this.state.favorites.includes(propertyId);
      
      if (isFavorite) {
        // Remove from favorites
        this.state.favorites = this.state.favorites.filter(id => id !== propertyId);
        button.classList.remove('active');
        button.querySelector('i').className = 'far fa-heart';
        this.showToast('Removed from favorites', 'Property removed from your favorites.', 'info');
      } else {
        // Add to favorites
        this.state.favorites.push(propertyId);
        button.classList.add('active');
        button.querySelector('i').className = 'fas fa-heart';
        this.showToast('Added to favorites', 'Property saved to your favorites.', 'success');
      }
      
      // Save to localStorage
      localStorage.setItem('cg-favorites', JSON.stringify(this.state.favorites));
    },
    
    toggleCompare(propertyId, button) {
      // Find the property in the full list
      const property = this.state.allProperties.find(p => p.id === propertyId);
      if (!property) return;
      
      const isInCompare = this.state.compareProperties.some(p => p.id === propertyId);
      
      if (isInCompare) {
        // Remove from compare
        this.state.compareProperties = this.state.compareProperties.filter(p => p.id !== propertyId);
        button.classList.remove('active');
        this.showToast('Removed from comparison', 'Property removed from comparison list.', 'info');
      } else {
        // Check if we already have 4 properties in compare
        if (this.state.compareProperties.length >= 4) {
          this.showToast('Maximum reached', 'You can compare up to 4 properties at once.', 'warning');
          return;
        }
        
        // Add to compare
        this.state.compareProperties.push(property);
        button.classList.add('active');
        this.showToast('Added to comparison', 'Property added to comparison list.', 'success');
      }
      
      // Update compare drawer
      this.updateCompareDrawer();
    },
    
    initCompareDrawer() {
      const drawer = document.getElementById('compare-drawer');
      const closeBtn = document.getElementById('compare-close');
      const compareBtn = document.getElementById('compare-btn');
      
      // Close the compare drawer
      closeBtn.addEventListener('click', () => {
        drawer.classList.remove('active');
      });
      
      // Open the compare page
      compareBtn.addEventListener('click', () => {
        if (this.state.compareProperties.length < 2) return;
        
        // In a real implementation, we would navigate to a compare page
        // For now, just show a toast
        this.showToast('Feature in Development', 'The comparison page is coming soon!', 'info');
      });
    },
    
    updateCompareDrawer() {
      const drawer = document.getElementById('compare-drawer');
      const compareCount = document.getElementById('compare-count');
      const compareItems = document.getElementById('compare-items');
      const compareBtn = document.getElementById('compare-btn');
      
      // Update the count
      compareCount.textContent = this.state.compareProperties.length;
      
      // Enable/disable the compare button
      if (this.state.compareProperties.length >= 2) {
        compareBtn.removeAttribute('disabled');
      } else {
        compareBtn.setAttribute('disabled', 'disabled');
      }
      
      // Update the items
      compareItems.innerHTML = '';
      
      this.state.compareProperties.forEach(property => {
        const props = property.properties || {};
        const id = property.id || '';
        
        // Get property details
        const title = this.formatListingType(props.hs_listing_type || '');
        const lotSize = props.hs_lot_size || '';
        const bedrooms = props.hs_bedrooms || '';
        const bathrooms = props.hs_bathrooms || '';
        
        // Get price
        let price = props.cg_listed_package_price || props.hs_price || 
                   props.cg_build_list_price || props.cg_land_release_price || '';
        price = this.formatPrice(price);
        
        // Create item element
        const item = document.createElement('div');
        item.className = 'cg-compare-item';
        item.innerHTML = `
          <button type="button" class="cg-compare-remove" data-id="${id}"></button>
          <div class="cg-compare-details">
            <div class="cg-compare-name">${title}</div>
            <div class="cg-compare-price">${price}</div>
            <div class="cg-compare-specs">
              ${lotSize ? `${lotSize}m  ` : ''}${bedrooms ? `${bedrooms} bed  ` : ''}${bathrooms ? `${bathrooms} bath` : ''}
            </div>
          </div>
        `;
        
        // Add item to container
        compareItems.appendChild(item);
        
        // Add remove event listener
        item.querySelector('.cg-compare-remove').addEventListener('click', (e) => {
          const propertyId = e.currentTarget.getAttribute('data-id');
          
          // Remove from compare list
          this.state.compareProperties = this.state.compareProperties.filter(p => p.id !== propertyId);
          
          // Update the UI
          this.updateCompareDrawer();
          
          // Update compare button on property card
          const compareBtn = document.querySelector(`.cg-compare-badge[data-id="${propertyId}"]`);
          if (compareBtn) {
            compareBtn.classList.remove('active');
          }
          
          // Show toast
          this.showToast('Removed from comparison', 'Property removed from comparison list.', 'info');
        });
      });
      
      // Show/hide drawer based on whether we have properties to compare
      if (this.state.compareProperties.length > 0) {
        drawer.classList.add('active');
      } else {
        drawer.classList.remove('active');
      }
    },
    
    // ========================
    // Quick View
    // ========================
    initQuickView() {
      const modal = document.getElementById('quick-view-modal');
      const closeBtn = document.getElementById('modal-close');
      const closeBtnFooter = document.getElementById('modal-close-btn');
      
      // Close modal when the X button is clicked
      closeBtn.addEventListener('click', () => {
        modal.classList.remove('active');
      });
      
      // Close modal when the Close button is clicked
      closeBtnFooter.addEventListener('click', () => {
        modal.classList.remove('active');
      });
      
      // Close modal when clicking outside the content
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('active');
        }
      });
      
      // Close modal when pressing Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
          modal.classList.remove('active');
        }
      });
    },
    
    openQuickView(propertyId) {
      // Find the property in the full list
      const property = this.state.allProperties.find(p => p.id === propertyId);
      if (!property) return;
      
      const props = property.properties || {};
      
      // Update modal title and content
      document.getElementById('modal-title').textContent = this.formatListingType(props.hs_listing_type || '');
      
      // TODO: Add more detailed property information here
      
      // Set the view details button URL
      document.getElementById('modal-view-details').onclick = () => {
        window.location.href = `property-detail?id=${propertyId}`;
      };
      
      // Show the modal
      document.getElementById('quick-view-modal').classList.add('active');
    },
    
    // ========================
    // Toast System
    // ========================
    initToastSystem() {
      // Nothing to initialize here, just creating the structure
    },
    
    showToast(title, message, type = 'info', duration = 3000) {
      const container = document.getElementById('toast-container');
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `cg-toast cg-toast-${type}`;
      
      // Set toast content
      toast.innerHTML = `
        <div class="cg-toast-icon">
          <i class="fas fa-${this.getToastIcon(type)}"></i>
        </div>
        <div class="cg-toast-content">
          <div class="cg-toast-title">${title}</div>
          <div class="cg-toast-message">${message}</div>
        </div>
        <button class="cg-toast-close"></button>
      `;
      
      // Add toast to container
      container.appendChild(toast);
      
      // Add close event listener
      toast.querySelector('.cg-toast-close').addEventListener('click', () => {
        this.closeToast(toast);
      });
      
      // Automatically remove toast after duration
      setTimeout(() => {
        if (toast.parentNode === container) {
          this.closeToast(toast);
        }
      }, duration);
    },
    
    closeToast(toast) {
      toast.classList.add('exit');
      
      // Remove from DOM after animation completes
      toast.addEventListener('animationend', () => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      });
    },
    
    getToastIcon(type) {
      switch (type) {
        case 'success':
          return 'check';
        case 'error':
          return 'times';
        case 'warning':
          return 'exclamation';
        case 'info':
        default:
          return 'info';
      }
    },
    
    // ========================
    // Utility Functions
    // ========================
    log(message) {
      console.log(`[CastleGroup] ${message}`);
      
      if (CONFIG.debugMode) {
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
          const div = document.createElement('div');
          div.textContent = message;
          debugInfo.appendChild(div);
          debugInfo.scrollTop = debugInfo.scrollHeight;
        }
      }
    },
    
    handleSearchSticky() {
      const searchWrapper = document.getElementById('cg-search-wrapper');
      if (!searchWrapper) return;
      
      if (window.scrollY > 100) {
        searchWrapper.classList.add('cg-search-sticky');
      } else {
        searchWrapper.classList.remove('cg-search-sticky');
      }
    }
  };
  
  // Initialize the app
  CastleApp.init();
  
  // Add API Debug Button for diagnosing property loading issues
  setTimeout(() => {
    const debugButton = document.createElement('button');
    debugButton.id = 'cg-api-debug-button';
    debugButton.innerHTML = ' Debug Property Data';
    debugButton.style.cssText = 'position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: lime; border: none; border-radius: 4px; padding: 8px 12px; font-family: monospace; z-index: 999999; cursor: pointer;';
    document.body.appendChild(debugButton);
    
    debugButton.addEventListener('click', () => {
      const cachedRealProperties = localStorage.getItem('cg_real_properties_cache');
      const lastApiResponse = localStorage.getItem('cg_last_api_response');
      
      const debugInfo = document.createElement('div');
      debugInfo.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 800px; max-height: 80vh; overflow: auto; background: #111; color: #0f0; padding: 20px; border-radius: 8px; z-index: 9999999; font-family: monospace; white-space: pre; box-shadow: 0 0 20px rgba(0,0,0,0.5);';
      
      // Add action buttons
      const actionsDiv = document.createElement('div');
      actionsDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 15px;';
      
      const refreshButton = document.createElement('button');
      refreshButton.textContent = ' Force Refresh Properties';
      refreshButton.style.cssText = 'background: #006600; border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
      refreshButton.onclick = (e) => {
        e.stopPropagation();
        // Clear all cached properties
        localStorage.removeItem('cg_properties_cache');
        localStorage.removeItem('cg_cached_properties');
        // Keep real properties cache for comparison
        
        // Force reload properties
        if (window.CastleApp && typeof window.CastleApp.loadPropertiesWithRetry === 'function') {
          window.CastleApp.loadPropertiesWithRetry();
          debugInfo.textContent = 'Forcing property refresh... Please wait.';
          
          // Add a delay to close the debug panel
          setTimeout(() => {
            document.body.removeChild(debugInfo);
            document.removeEventListener('click', closeDebug);
          }, 2000);
        }
      };
      
      const clearCacheButton = document.createElement('button');
      clearCacheButton.textContent = ' Clear All Cache';
      clearCacheButton.style.cssText = 'background: #660000; border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer;';
      clearCacheButton.onclick = (e) => {
        e.stopPropagation();
        // Clear all property-related cache
        localStorage.removeItem('cg_properties_cache');
        localStorage.removeItem('cg_cached_properties');
        localStorage.removeItem('cg_real_properties_cache');
        localStorage.removeItem('cg_real_properties_cache_time');
        localStorage.removeItem('cg_properties_cache_time');
        localStorage.removeItem('cg_cache_timestamp');
        localStorage.removeItem('cg_last_api_response');
        
        debugInfo.textContent = 'All property cache cleared. Reload the page to fetch fresh data.';
        
        // Add a reload button
        const reloadButton = document.createElement('button');
        reloadButton.textContent = ' Reload Page Now';
        reloadButton.style.cssText = 'background: #000066; border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-top: 15px;';
        reloadButton.onclick = (e) => {
          e.stopPropagation();
          window.location.reload();
        };
        
        debugInfo.appendChild(document.createElement('br'));
        debugInfo.appendChild(reloadButton);
      };
      
      actionsDiv.appendChild(refreshButton);
      actionsDiv.appendChild(clearCacheButton);
      debugInfo.appendChild(actionsDiv);
      
      let content = '== PROPERTY LISTINGS DEBUG INFO ==\n\n';
      
      if (lastApiResponse) {
        content += '--- LAST API RESPONSE ---\n';
        try {
          const apiData = JSON.parse(lastApiResponse);
          content += JSON.stringify(apiData, null, 2);
        } catch (e) {
          content += 'Error parsing API response: ' + e.message;
        }
        content += '\n\n';
      } else {
        content += 'No API response data found\n\n';
      }
      
      content += '--- CACHED REAL PROPERTIES ---\n';
      if (cachedRealProperties) {
        try {
          const realProps = JSON.parse(cachedRealProperties);
          content += `Found ${realProps.length} real properties in cache\n`;
          content += 'First 3 properties:\n';
          realProps.slice(0, 3).forEach((prop, i) => {
            content += `\n[${i+1}] ${prop.properties?.cg_project_name || 'Unnamed'}\n`;
            content += `    Status: ${prop.properties?.cg_status || 'unknown'}\n`;
            content += `    ID: ${prop.id || 'unknown'}\n`;
          });
        } catch (e) {
          content += 'Error parsing cached properties: ' + e.message;
        }
      } else {
        content += 'No cached real properties found';
      }
      
      content += '\n\n--- CURRENT APP STATE ---\n';
      if (window.CastleApp && window.CastleApp.state) {
        const state = window.CastleApp.state;
        content += `Properties loaded: ${state.allProperties?.length || 0}\n`;
        content += `Filtered properties: ${state.filteredProperties?.length || 0}\n`;
        content += `Is loading: ${state.isLoading}\n`;
        
        // Check if we're showing sample data
        if (state.allProperties.length > 0) {
          const firstProp = state.allProperties[0];
          if (firstProp.id && firstProp.id.includes('sample')) {
            content += `\n WARNING: Currently displaying SAMPLE properties!\n`;
          } else {
            content += `\n Currently displaying REAL properties\n`;
          }
        }
      } else {
        content += 'App state not available';
      }
      
      content += '\n\n-- CLICK ANYWHERE TO CLOSE --';
      
      debugInfo.textContent = content;
      document.body.appendChild(debugInfo);
      
      // Close when clicking anywhere
      const closeDebug = (e) => {
        if (debugInfo.contains(e.target)) return; // Don't close if clicking inside
        document.body.removeChild(debugInfo);
        document.removeEventListener('click', closeDebug);
      };
      
      // Add delay to prevent immediate closing
      setTimeout(() => {
        document.addEventListener('click', closeDebug);
      }, 100);
    });
  }, 1000);
});
</script>
<!-- HubSpot Integration -->
<script>
// HubSpot Integration Script
// Configuration for HubSpot integration
const HUBSPOT_CONFIG = {
  enabled: true,
  portalId: '24160521',
  formId: 'a00f1f67-1490-44a7-a571-142da5377383',
  formUrl: 'https://share.hsforms.com/1oA8fZxSQRKelcRQtpTdzgwedudl'
};

// Project Mapping Function
function getProjectFromPropertyTitle(propertyTitle) {
  if (!propertyTitle) return 'General Enquiry';
  
  // Standardize the input
  const title = propertyTitle.toLowerCase().trim();
  
  // Mapping table of project names based on README.md requirements
  const projectMappings = {
    // Official project mappings
    'ashton gardens': 'Ashton Gardens',
    'bloomfield': 'Bloomfield',
    'botanica': 'Botanica',
    'garfield': 'Garfield Grange',
    'grange': 'Garfield Grange',
    'one fairway': 'One FairWay',
    'onefairway': 'One FairWay',
    'fairway': 'One FairWay',
    'paddington': 'Paddington Estate',
    'park avenue': 'Park Avenue',
    'parkave': 'Park Avenue',
    'park ave ii': 'Park Avenue II',
    'parkave2': 'Park Avenue II',
    'river oaks': 'River Oaks',
    'riviere': 'Rivire',
    'the grace': 'The Grace',
    'grace': 'The Grace',
    'rouse hill': 'The Rouse Hill Estate',
    'valley rise': 'Valley Rise',
    '30-32 advance': 'Advance St',
    'advance st': 'Advance St',
    'ed.ave': 'Ed.Ave (350 Edmondson Ave)',
    'edmondson': 'Ed.Ave (350 Edmondson Ave)',
    '172 guntawong': '172 Guntawong Rd',
    'guntawong': '172 Guntawong Rd',
    '627 windsor': '627 Windsor Rd',
    '567 windsor': '567 Windsor Rd',
    '505-535 fifteenth': '505-535 Fifteenth Ave',
    'fifteenth ave': '505-535 Fifteenth Ave',
    '155 boyd': '155 Boyd St',
    'boyd st': '155 Boyd St',
    'castle luxe': 'cg_castle_luxe',
    'luxe': 'cg_castle_luxe'
  };
  
  // Check for direct matches first
  for (const [key, value] of Object.entries(projectMappings)) {
    if (title.includes(key)) {
      return value;
    }
  }
  
  // Return General Enquiry as the default fallback
  return 'General Enquiry';
}

// Track user state in localStorage
function getUserData() {
  try {
    const userData = localStorage.getItem('cg-user');
    return userData ? JSON.parse(userData) : null;
  } catch (e) {
    console.error('Error reading user data:', e);
    return null;
  }
}

function saveUserData(data) {
  try {
    localStorage.setItem('cg-user', JSON.stringify(data));
  } catch (e) {
    console.error('Error saving user data:', e);
  }
}

// Function to track property interests
window.trackPropertyInterest = function(propertyTitle, propertyId, interactionType = 'favorite') {
  // Get current user data, create if doesn't exist
  let userData = getUserData() || { 
    listings_of_interest: [],
    projects_of_interest: []
  };
  
  // Determine project from property title
  const project = getProjectFromPropertyTitle(propertyTitle);
  
  // Track in localStorage
  if (interactionType === 'unfavorite') {
    // Remove from listings of interest
    userData.listings_of_interest = (userData.listings_of_interest || []).filter(
      item => item !== propertyTitle
    );
  } else {
    // Add to listings if not already present
    if (!userData.listings_of_interest) {
      userData.listings_of_interest = [];
    }
    
    if (!userData.listings_of_interest.includes(propertyTitle)) {
      userData.listings_of_interest.push(propertyTitle);
    }
    
    // For comparison, just track project
    if (interactionType === 'compare' && project) {
      if (!userData.projects_of_interest) {
        userData.projects_of_interest = [];
      }
      
      if (!userData.projects_of_interest.includes(project)) {
        userData.projects_of_interest.push(project);
      }
    }
  }
  
  // Save updated user data
  saveUserData(userData);
};

// Set up the visible HubSpot form and fallbacks
function createHubSpotForm() {
  const formContainer = document.getElementById('hubspot-form-embed');
  const iframe = document.getElementById('hubspot-iframe');
  const continueButton = document.getElementById('continue-button');
  const manualForm = document.getElementById('manual-form');
  
  if (!formContainer || !iframe || !continueButton || !manualForm) {
    console.error('Required DOM elements not found');
    return;
  }
  
  try {
    // Try to create HubSpot form using API
    if (typeof hbspt !== 'undefined') {
      console.log('Creating HubSpot form using hbspt API');
      
      // Hide the iframe since we'll use the API
      iframe.style.display = 'none';
      
      // Create the form in the designated container
      hbspt.forms.create({
        region: "na1",
        portalId: HUBSPOT_CONFIG.portalId,
        formId: HUBSPOT_CONFIG.formId,
        target: '#hubspot-form-embed',
        formData: {
          // Add default verification field
          cg_needs_verification: 'Yes'
        },
        onFormReady: function($form) {
          console.log('HubSpot form is ready');
        },
        onFormSubmit: function($form) {
          try {
            // Get the form data
            const email = $form.find('input[name="email"]').val();
            const firstName = $form.find('input[name="firstname"]').val();
            const lastName = $form.find('input[name="lastname"]').val();
            
            // Save to localStorage
            const userData = getUserData() || {};
            userData.email = email || '';
            userData.firstName = firstName || '';
            userData.lastName = lastName || '';
            userData.authenticated = true; // Mark as authenticated
            userData.needsVerification = true; // Mark as needing verification
            
            // Ensure we have the listings arrays
            if (!userData.listings_of_interest) {
              userData.listings_of_interest = [];
            }
            if (!userData.projects_of_interest) {
              userData.projects_of_interest = [];
            }
            
            saveUserData(userData);
            
            // Ensure the form has the cg_needs_verification field set
            try {
              // Find the cg_needs_verification field or create it
              let verificationField = $form.find('input[name="cg_needs_verification"]');
              if (!verificationField.length) {
                // Create hidden field for verification
                const hiddenField = document.createElement('input');
                hiddenField.type = 'hidden';
                hiddenField.name = 'cg_needs_verification';
                hiddenField.value = 'Yes';
                $form[0].appendChild(hiddenField);
              } else {
                // Set the value of the existing field
                verificationField.val('Yes');
              }
            } catch (e) {
              console.error('Error setting verification field:', e);
            }
            console.log('User data saved:', userData);
          } catch (e) {
            console.error('Error in onFormSubmit handler:', e);
          }
        },
        onFormSubmitted: function() {
          console.log('Form submission complete');
          // Mark user as authenticated and needing verification
          const userData = getUserData() || {};
          userData.authenticated = true;
          userData.needsVerification = true;
          saveUserData(userData);
          
          // Try to ensure the HubSpot workflow is triggered
          try {
            // Make a direct submission to ensure verification field is sent
            const hiddenFormContainer = document.createElement('div');
            hiddenFormContainer.id = 'hs-verification-form-' + Date.now();
            hiddenFormContainer.style.display = 'none';
            document.body.appendChild(hiddenFormContainer);
            
            hbspt.forms.create({
              portalId: HUBSPOT_CONFIG.portalId,
              formId: HUBSPOT_CONFIG.formId,
              target: '#' + hiddenFormContainer.id,
              formData: {
                email: userData.email || '',
                firstname: userData.firstName || '',
                lastname: userData.lastName || '',
                cg_needs_verification: 'Yes'
              },
              onFormSubmitted: function() {
                console.log('Verification form submitted');
                setTimeout(() => {
                  if (document.body.contains(hiddenFormContainer)) {
                    document.body.removeChild(hiddenFormContainer);
                  }
                }, 2000);
              }
            });
          } catch (e) {
            console.error('Error triggering verification:', e);
          }
          
          // Show the confirmation message
          document.getElementById('confirmation-message').style.display = 'block';
          
          // Hide the form elements
          formContainer.style.display = 'none';
          iframe.style.display = 'none';
          continueButton.style.display = 'none';
          manualForm.style.display = 'none';
          
          // Don't show listings immediately, tell them to check email for verification
          // The continue button will still appear as fallback in case they don't receive the email
          setTimeout(function() {
            continueButton.textContent = 'Access Listings Now';
            continueButton.style.display = 'block';
          }, 10000);
        }
      });
    } else {
      console.log('HubSpot forms API not available, using iframe fallback');
      // Keep the iframe visible (it's already in the HTML)
    }
    
    // Setup continue button
    continueButton.addEventListener('click', function() {
      // Mark user as authenticated
      const userData = getUserData() || {};
      userData.authenticated = true;
      saveUserData(userData);
      
      // Show listings
      showListings();
    });
    
    // Setup manual form submission
    manualForm.addEventListener('submit', function(event) {
      event.preventDefault();
      
      // Get form data
      const email = document.getElementById('manual-email').value;
      const firstName = document.getElementById('manual-firstname').value;
      const lastName = document.getElementById('manual-lastname').value;
      
      // Save to localStorage
      const userData = getUserData() || {};
      userData.email = email || '';
      userData.firstName = firstName || '';
      userData.lastName = lastName || '';
      userData.authenticated = true;
      userData.needsVerification = true; // Set needs verification flag
      
      if (!userData.listings_of_interest) {
        userData.listings_of_interest = [];
      }
      if (!userData.projects_of_interest) {
        userData.projects_of_interest = [];
      }
      
      saveUserData(userData);
      
      // Try to explicitly trigger HubSpot verification workflow
      try {
        if (typeof hbspt !== 'undefined' && HUBSPOT_CONFIG.portalId && HUBSPOT_CONFIG.formId) {
          // Create a hidden HubSpot form submission
          const hiddenFormContainer = document.createElement('div');
          hiddenFormContainer.id = 'hidden-hubspot-form-' + Date.now();
          hiddenFormContainer.style.display = 'none';
          document.body.appendChild(hiddenFormContainer);
          
          hbspt.forms.create({
            portalId: HUBSPOT_CONFIG.portalId,
            formId: HUBSPOT_CONFIG.formId,
            target: '#' + hiddenFormContainer.id,
            formData: {
              email: email,
              firstname: firstName,
              lastname: lastName,
              cg_needs_verification: 'Yes' // Explicitly set verification flag
            },
            onFormSubmitted: function() {
              console.log('Hidden form submitted to trigger verification workflow');
              setTimeout(() => {
                if (document.body.contains(hiddenFormContainer)) {
                  document.body.removeChild(hiddenFormContainer);
                }
              }, 2000);
            }
          });
        }
      } catch (e) {
        console.error('Error trying to trigger verification workflow:', e);
      }
      
      // Show the confirmation message
      document.getElementById('confirmation-message').style.display = 'block';
      
      // Hide the form elements
      formContainer.style.display = 'none';
      iframe.style.display = 'none';
      manualForm.style.display = 'none';
      continueButton.style.display = 'none';
      
      // Show access button after delay as fallback
      setTimeout(function() {
        continueButton.textContent = 'Access Listings Now';
        continueButton.style.display = 'block';
      }, 10000);
    });
    
    // Setup fallback timers
    
    // Show continue button after 5 seconds
    setTimeout(function() {
      continueButton.style.display = 'block';
    }, 5000);
    
    // Show manual form after 15 seconds as final fallback
    setTimeout(function() {
      manualForm.style.display = 'block';
    }, 15000);
    
    // Add a message listener for iframe communications
    window.addEventListener('message', function(event) {
      try {
        // Check if we got a submission confirmation
        if (event.data && (
          (typeof event.data === 'string' && (event.data.includes('hsFormCallback') || event.data.includes('formSubmitted'))) ||
          (event.data.type === 'hsFormCallback' && event.data.eventName === 'onFormSubmitted')
        )) {
          console.log('Form submission detected via postMessage');
          
          // Get form data if possible
          let email = '', firstName = '', lastName = '';
          try {
            // Try to extract email from iframe
            const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
            const emailInput = iframeDocument.querySelector('input[name="email"]');
            const firstNameInput = iframeDocument.querySelector('input[name="firstname"]');
            const lastNameInput = iframeDocument.querySelector('input[name="lastname"]');
            
            if (emailInput) email = emailInput.value;
            if (firstNameInput) firstName = firstNameInput.value;
            if (lastNameInput) lastName = lastNameInput.value;
          } catch (e) {
            console.warn('Could not extract form data from iframe:', e);
          }
          
          // Mark user as authenticated and needing verification
          const userData = getUserData() || {};
          userData.email = email || userData.email || '';
          userData.firstName = firstName || userData.firstName || '';
          userData.lastName = lastName || userData.lastName || '';
          userData.authenticated = true;
          userData.needsVerification = true;
          saveUserData(userData);
          
          // Try to ensure verification workflow is triggered
          try {
            // Create hidden verification form
            const verificationContainer = document.createElement('div');
            verificationContainer.id = 'iframe-verification-form-' + Date.now();
            verificationContainer.style.display = 'none';
            document.body.appendChild(verificationContainer);
            
            hbspt.forms.create({
              portalId: HUBSPOT_CONFIG.portalId,
              formId: HUBSPOT_CONFIG.formId,
              target: '#' + verificationContainer.id,
              formData: {
                email: userData.email,
                firstname: userData.firstName,
                lastname: userData.lastName,
                cg_needs_verification: 'Yes'
              },
              onFormSubmitted: function() {
                console.log('Verification form submitted from iframe handler');
                setTimeout(() => {
                  if (document.body.contains(verificationContainer)) {
                    document.body.removeChild(verificationContainer);
                  }
                }, 2000);
              }
            });
          } catch (e) {
            console.error('Error triggering verification from iframe handler:', e);
          }
          
          // Show the confirmation message
          document.getElementById('confirmation-message').style.display = 'block';
          
          // Hide the form elements
          iframe.style.display = 'none';
          continueButton.style.display = 'none';
          manualForm.style.display = 'none';
          
          // Show access button after delay as fallback
          setTimeout(function() {
            continueButton.textContent = 'Access Listings Now';
            continueButton.style.display = 'block';
          }, 10000);
        }
      } catch (e) {
        console.error('Error processing iframe message:', e);
      }
    });
    
  } catch (e) {
    console.error('Error setting up authentication:', e);
    // Keep the iframe and other fallbacks visible
  }
}

// Function to show listings after authentication
function showListings() {
  // Hide the auth overlay
  const authOverlay = document.getElementById('auth-overlay');
  if (authOverlay) {
    authOverlay.style.display = 'none';
  }
  
  // Show the listings container
  const listingsContainer = document.getElementById('listings-container');
  if (listingsContainer) {
    listingsContainer.classList.remove('hidden-until-auth');
  }
}
}

// Add CastleApp extensions
function extendCastleApp() {
  // Don't proceed if CastleApp isn't available
  if (typeof window.CastleApp === 'undefined') {
    console.warn('CastleApp not found, extensions not applied');
    return;
  }
  
  // Extend the existing toggleFavorite function to track in HubSpot
  if (typeof CastleApp.toggleFavorite === 'function') {
    const originalToggleFavorite = CastleApp.toggleFavorite;
    CastleApp.toggleFavorite = function(propertyId, button) {
      // Get current state before calling original function
      const wasAlreadyFavorite = this.state.favorites.includes(propertyId);
      
      // Call original function
      originalToggleFavorite.call(this, propertyId, button);
      
      // Check the new state after the function call
      const isNowFavorite = this.state.favorites.includes(propertyId);
      
      // Find the property in the list
      const property = this.state.allProperties.find(p => p.id === propertyId) || {};
      
      // Get property title or use ID if not found
      const propertyTitle = property.title || property.name || `Property ${propertyId}`;
      
      // Track the interest in localStorage
      if (isNowFavorite && !wasAlreadyFavorite) {
        // Added to favorites
        trackPropertyInterest(propertyTitle, propertyId, 'favorite');
      } else if (!isNowFavorite && wasAlreadyFavorite) {
        // Removed from favorites
        trackPropertyInterest(propertyTitle, propertyId, 'unfavorite');
      }
    };
  }
  
  // Extend the property comparison function if it exists
  if (typeof CastleApp.togglePropertyComparison === 'function') {
    const originalToggleComparison = CastleApp.togglePropertyComparison;
    CastleApp.togglePropertyComparison = function(propertyId, button) {
      // Get current state
      const wasAlreadyCompared = this.state.comparisonList.includes(propertyId);
      
      // Call original function
      originalToggleComparison.call(this, propertyId, button);
      
      // Check new state
      const isNowCompared = this.state.comparisonList.includes(propertyId);
      
      // Find the property
      const property = this.state.allProperties.find(p => p.id === propertyId) || {};
      const propertyTitle = property.title || property.name || `Property ${propertyId}`;
      
      // Track comparison differently than favorites
      if (isNowCompared && !wasAlreadyCompared) {
        // Added to comparison list - just track project interest
        trackPropertyInterest(propertyTitle, propertyId, 'compare');
      }
    };
  }
}

// Check if user is already authenticated
function checkAuthStatus() {
  const userData = getUserData();
  if (userData && userData.authenticated) {
    // User is already authenticated, show the listings immediately
    console.log('User already authenticated, showing listings');
    showListings();
  } else {
    // Otherwise, keep the auth overlay showing
    console.log('User not authenticated, showing form');
  }
}

// Initialize HubSpot Integration when the document is ready
document.addEventListener('DOMContentLoaded', function() {
  console.log('Setting up HubSpot integration');
  
  // Check if user is already authenticated
  checkAuthStatus();
  
  // Create the HubSpot form in the designated container
  createHubSpotForm();
  
  // Extend CastleApp methods with tracking
  extendCastleApp();
  
  // Make CONFIG available to the window if not already defined
  if (!window.CONFIG) {
    window.CONFIG = {};
  }
  
  // Add HubSpot configuration to window.CONFIG
  window.CONFIG.hubspot = HUBSPOT_CONFIG;
  
  console.log('HubSpot integration initialized');
});
</script>

<!-- Authentication System -->
<script>
// Auth System for Property Listings
(function() {
  // Project mapping function - already defined in the HubSpot integration section
  
  // Configuration settings
  const AUTH_CONFIG = {
    verificationEndpoint: 'https://eop2vfl5w0cxbqg.m.pipedream.net',
    apiTimeout: 20000,      // Increased timeout for API calls
    storageKey: 'cg_user_data',
    verificationTokenParam: 'verification_token',
    devMode: true,          // Enable dev mode for easier testing
    debugMode: true,        // Enable debug logging
    bypassAuth: false,      // No bypass - perform real authentication
    trustExistingContacts: true, // Allow access for emails already in HubSpot
    loginAttempts: 0,       // Track login attempts for fallback authentication
    directAPIEndpoint: '/check-hubspot-contact', // Direct endpoint for HubSpot contact check
    fallbackAPIEndpoint: '/check-email'           // Fallback endpoint for compatibility
  };
  
  // Auth System
  const AuthSystem = {
    // Initialize the auth system
    init: function() {
      this.setupEventListeners();
      this.handleVerificationToken();
      
      // Check if there's a user already authenticated
      const userData = this.getUserData();
      if (userData && userData.authenticated) {
        this.showListings();
      } else {
        this.setupAuthOverlay();
      }
    },
    
    // Set up the auth overlay
    setupAuthOverlay: function() {
      // Find the auth overlay that has both options
      const authOverlay = document.getElementById('auth-overlay');
      if (!authOverlay) return;
      
      // Show the auth overlay
      authOverlay.style.display = 'flex';
      
      // Hide the listings container
      const listingsContainer = document.getElementById('listings-container');
      if (listingsContainer) {
        listingsContainer.classList.add('hidden-until-auth');
      }
    },
    
    // Set up event listeners for auth buttons
    setupEventListeners: function() {
      // Login and Signup buttons
      const showLoginBtn = document.getElementById('show-login-btn');
      const showSignupBtn = document.getElementById('show-signup-btn');
      const loginLink = document.getElementById('login-link');
      const signupLink = document.getElementById('signup-link');
      const returnLoginLink = document.getElementById('return-login-link');
      const showSignupFromNotRegistered = document.getElementById('show-signup');
      const resendVerificationBtn = document.getElementById('resend-verification');
      
      // Form submission and buttons
      const emailLoginForm = document.getElementById('email-login-form');
      const loginBtn = document.getElementById('access-listings-btn') || document.querySelector('.login-btn');
      
      // Views
      const authOptions = document.getElementById('auth-options');
      const hubspotFormContainer = document.getElementById('hubspot-form-container');
      const loginForm = document.getElementById('login-form');
      const verificationMessage = document.getElementById('verification-message');
      const notRegisteredMessage = document.getElementById('not-registered-message');
      
      // Add event listeners if elements exist
      if (showLoginBtn) {
        showLoginBtn.addEventListener('click', () => {
          console.log('Login button clicked');
          this.showView('login');
        });
      }
      
      if (showSignupBtn) {
        showSignupBtn.addEventListener('click', () => {
          console.log('Signup button clicked');
          this.showView('signup');
        });
      }
      
      if (loginLink) {
        loginLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Login link clicked');
          this.showView('login');
        });
      }
      
      if (signupLink) {
        signupLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Signup link clicked');
          this.showView('signup');
        });
      }
      
      if (returnLoginLink) {
        returnLoginLink.addEventListener('click', (e) => {
          e.preventDefault();
          console.log('Return to login link clicked');
          this.showView('login');
        });
      }
      
      if (showSignupFromNotRegistered) {
        showSignupFromNotRegistered.addEventListener('click', () => {
          console.log('Show signup from not registered clicked');
          this.showView('signup');
        });
      }
      
      if (resendVerificationBtn) {
        resendVerificationBtn.addEventListener('click', () => {
          console.log('Resend verification clicked');
          this.resendVerification();
        });
      }
      
      // Add both form submission and direct button click handlers for the login
      if (emailLoginForm) {
        console.log('Found email login form, adding submit handler');
        emailLoginForm.addEventListener('submit', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('Login form submitted');
          const email = document.getElementById('login-email').value.trim();
          
          if (email) {
            // Use direct function reference to avoid 'this' context issues
            AuthSystem.handleLogin(email);
          } else {
            console.error('Email field is empty in form submission');
            alert('Please enter your email address');
          }
          return false;
        });
      }
      
      // Add a direct click handler to the login button as a fallback and a more robust solution
      if (loginBtn) {
        console.log('Found login button, adding click handler');
        
        // Use a direct login handler with proper binding to preserve 'this' context
        const loginHandler = (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('Login button triggered');
          
          const emailField = document.getElementById('login-email');
          const email = emailField ? emailField.value.trim() : '';
          
          if (email) {
            console.log(`Processing login for email: ${email}`);
            AuthSystem.handleLogin(email); // Use direct reference to avoid 'this' issues
          } else {
            console.error('Email field is empty');
            alert('Please enter your email address');
          }
          return false;
        };
        
        // Use direct event assignment to avoid 'this' context issues
        loginBtn.addEventListener('click', loginHandler);
        loginBtn.addEventListener('touchend', loginHandler);
        loginBtn.onclick = loginHandler;
      }
      
      // Handle the continue button for the second auth overlay
      const continueButton = document.getElementById('continue-button');
      if (continueButton) {
        continueButton.addEventListener('click', () => this.skipVerification());
      }
      
      // Handle manual form submission
      const manualForm = document.getElementById('manual-form');
      if (manualForm) {
        manualForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const email = document.getElementById('manual-email').value;
          const firstName = document.getElementById('manual-firstname').value;
          const lastName = document.getElementById('manual-lastname').value;
          this.handleManualSubmission(email, firstName, lastName);
        });
      }
    },
    
    // Show the specified view
    showView: function(view) {
      // Get all possible views
      const authOptions = document.getElementById('auth-options');
      const hubspotFormContainer = document.getElementById('hubspot-form-container');
      const loginForm = document.getElementById('login-form');
      const verificationMessage = document.getElementById('verification-message');
      const notRegisteredMessage = document.getElementById('not-registered-message');
      
      // Hide all views
      if (authOptions) authOptions.style.display = 'none';
      if (hubspotFormContainer) hubspotFormContainer.style.display = 'none';
      if (loginForm) loginForm.style.display = 'none';
      if (verificationMessage) verificationMessage.style.display = 'none';
      if (notRegisteredMessage) notRegisteredMessage.style.display = 'none';
      
      // Show the requested view
      switch(view) {
        case 'options':
          if (authOptions) authOptions.style.display = 'block';
          break;
        case 'signup':
          if (hubspotFormContainer) hubspotFormContainer.style.display = 'block';
          break;
        case 'login':
          if (loginForm) loginForm.style.display = 'block';
          break;
        case 'verification':
          if (verificationMessage) verificationMessage.style.display = 'block';
          break;
        case 'not-registered':
          if (notRegisteredMessage) notRegisteredMessage.style.display = 'block';
          break;
        default:
          if (authOptions) authOptions.style.display = 'block';
      }
    },
    
    // Handle login form submission
    handleLogin: async function(email) {
      if (AUTH_CONFIG.debugMode) {
        console.log(`Login attempt with email: ${email}`);
      }
      
      if (!email) {
        console.error('No email provided for login');
        return;
      }
      
      // Increment login attempts counter
      AUTH_CONFIG.loginAttempts++;
      
      // Show loading indicator
      const loginLoading = document.getElementById('login-loading');
      if (loginLoading) {
        loginLoading.style.display = 'block';
        if (AUTH_CONFIG.debugMode) console.log('Showing loading indicator');
      }
      
      // Development mode bypass for special emails
      if (AUTH_CONFIG.devMode && (email.toLowerCase() === 'dev@example.com' || 
                                  email.toLowerCase() === 'test@example.com' ||
                                  email.toLowerCase().includes('test') ||
                                  email.toLowerCase().includes('dev'))) {
        if (AUTH_CONFIG.debugMode) console.log('Development mode: bypassing verification for developer email');
        
        // Hide loading indicator
        if (loginLoading) loginLoading.style.display = 'none';
        
        // Authenticate and show listings immediately
        this.authenticateUser(email, 'Test', 'User');
        this.showListings();
        this.showToast('Development login successful', 'success');
        return;
      }
      
      try {
        if (AUTH_CONFIG.debugMode) console.log('Checking if email exists in HubSpot...');
        
        // Try the direct HubSpot email check endpoint first
        const directCheckUrl = `${AUTH_CONFIG.verificationEndpoint}${AUTH_CONFIG.directAPIEndpoint}?email=${encodeURIComponent(email)}`;
        if (AUTH_CONFIG.debugMode) console.log('Trying direct HubSpot check URL:', directCheckUrl);
        
        let response;
        let data;
        let apiSuccessful = false;
        let fallbackUsed = false;
        
        try {
          // First attempt with direct endpoint
          response = await fetch(directCheckUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache'
            },
            timeout: AUTH_CONFIG.apiTimeout
          });
          
          if (response.ok) {
            data = await response.json();
            apiSuccessful = true;
            if (AUTH_CONFIG.debugMode) console.log('Direct API response:', data);
          } else {
            if (AUTH_CONFIG.debugMode) console.log('Direct API call failed, status:', response.status, response.statusText);
            throw new Error('Direct API call failed');
          }
        } catch (directApiError) {
          if (AUTH_CONFIG.debugMode) console.log('Error with direct API, trying fallback:', directApiError);
          
          // Try fallback endpoint if direct fails
          fallbackUsed = true;
          const fallbackUrl = `${AUTH_CONFIG.verificationEndpoint}${AUTH_CONFIG.fallbackAPIEndpoint}?email=${encodeURIComponent(email)}`;
          if (AUTH_CONFIG.debugMode) console.log('Trying fallback check URL:', fallbackUrl);
          
          response = await fetch(fallbackUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'Cache-Control': 'no-cache'
            },
            timeout: AUTH_CONFIG.apiTimeout
          });
          
          if (response.ok) {
            data = await response.json();
            apiSuccessful = true;
            if (AUTH_CONFIG.debugMode) console.log('Fallback API response:', data);
          } else {
            if (AUTH_CONFIG.debugMode) console.log('Fallback API call failed, status:', response.status, response.statusText);
            throw new Error('Both API calls failed');
          }
        }
        
        // Hide loading indicator
        if (loginLoading) loginLoading.style.display = 'none';
        
        // If we couldn't get a valid API response
        if (!apiSuccessful || !data) {
          throw new Error('Could not get valid API response');
        }
        
        if (AUTH_CONFIG.debugMode) {
          console.log('API Response Summary:');
          console.log('- API endpoint used:', fallbackUsed ? 'Fallback' : 'Direct');
          console.log('- Email:', email);
          console.log('- Success:', apiSuccessful);
          console.log('- Email exists in HubSpot:', data.exists);
          console.log('- Email verified:', data.verified);
          console.log('- Full response:', JSON.stringify(data, null, 2));
        }
        
        // Process the API response
        if (data.exists) {
          if (AUTH_CONFIG.debugMode) console.log('Email exists in HubSpot');
          
          // If we're trusting existing HubSpot contacts or the user is verified
          if (AUTH_CONFIG.trustExistingContacts || data.verified) {
            if (AUTH_CONFIG.debugMode) console.log('Trusting existing contact, granting access');
            
            // User is in HubSpot, authenticate them
            this.authenticateUser(email, data.firstName || '', data.lastName || '');
            this.showListings();
            this.showToast('Login successful', 'success');
            return;
          } else if (data.needsVerification) {
            // The user exists but needs verification
            if (AUTH_CONFIG.debugMode) console.log('User exists but needs verification');
            
            // Show verification message
            const verificationEmail = document.getElementById('verification-email');
            if (verificationEmail) {
              verificationEmail.textContent = email;
            }
            this.showView('verification');
            
            // Store the email for resending verification
            localStorage.setItem('pending_verification_email', email);
            
            // Resend verification email
            this.resendVerification(email);
          }
        } else {
          if (AUTH_CONFIG.debugMode) console.log('Email does not exist in HubSpot');
          
          // If trustExistingContacts is enabled, but we're not sure if the email exists
          // (could be API limitation), let's give the benefit of the doubt
          if (AUTH_CONFIG.trustExistingContacts && data.status === 'uncertain') {
            if (AUTH_CONFIG.debugMode) console.log('API uncertain about email, granting access due to trustExistingContacts setting');
            
            this.authenticateUser(email, '', '');
            this.showListings();
            this.showToast('Access granted', 'success');
            return;
          }
          
          // User doesn't exist in HubSpot, show not registered message
          this.showView('not-registered');
        }
      } catch (error) {
        console.error('Login error:', error);
        
        // Hide loading indicator
        if (loginLoading) loginLoading.style.display = 'none';
        
        // CRITICAL ISSUE WORKAROUND:
        // If API calls are consistently failing but we want to allow access for
        // users who claim to have an account, we'll provide an option after the 2nd attempt
        if (AUTH_CONFIG.loginAttempts >= 2) {
          console.log('Multiple login attempts detected with API failures');
          
          const shouldContinue = confirm('We\'re having trouble verifying your email. If you have submitted the form before and have an account, would you like to proceed?');
          
          if (shouldContinue) {
            this.authenticateUser(email, '', '');
            this.showListings();
            this.showToast('Access granted', 'info');
            return;
          }
        }
        
        // In development mode, provide an option to bypass verification on API failure
        if (AUTH_CONFIG.devMode) {
          console.log('Development mode: offering bypass option after API failure');
          
          if (confirm('API error. In development mode, you can bypass verification. Would you like to continue?')) {
            this.authenticateUser(email, 'Dev', 'User');
            this.showListings();
            this.showToast('Development bypass activated', 'info');
            return;
          }
        }
        
        // Show error message
        this.showToast('There was an error checking your account. Please try again or register if you don\'t have an account.', 'error');
        this.showView('options');
      }
    },
    
    // Authenticate a user
    authenticateUser: function(email, firstName, lastName) {
      const userData = {
        email: email,
        firstName: firstName || '',
        lastName: lastName || '',
        authenticated: true,
        verificationDate: new Date().toISOString(),
        listings_of_interest: this.getListingsOfInterest(),
        projects_of_interest: this.getProjectsOfInterest()
      };
      
      // Save to localStorage
      localStorage.setItem(AUTH_CONFIG.storageKey, JSON.stringify(userData));
      
      // Update HubSpot contact properties if CastleApp is available
      this.updateHubSpotProperties(userData);
    },
    
    // Enhanced showListings function with robust property loading
    showListings: function() {
      console.log('CRITICAL: Starting enhanced property loading sequence');
      
      // 1. First hide all auth overlays immediately
      const authOverlays = document.querySelectorAll('.auth-overlay');
      authOverlays.forEach(overlay => {
        overlay.style.display = 'none';
      });
      
      // 2. Show the listings container immediately
      const listingsContainer = document.getElementById('listings-container');
      if (listingsContainer) {
        listingsContainer.classList.remove('hidden-until-auth');
        listingsContainer.style.display = 'block';
        listingsContainer.style.visibility = 'visible';
        listingsContainer.style.opacity = '1';
      }
      
      // 3. Check for existing API data and ensure CastleApp is properly initialized
      let hasFoundExistingProperties = false;
      
      try {
        if (window.CastleApp) {
          console.log('CastleApp found, ensuring initialization...');
          
          // If properties already exist in state, make sure they're shown
          if (window.CastleApp.state) {
            // Reset crucial flags
            window.CastleApp.state.isLoading = false;
            
            // Check if allProperties array exists and has data
            if (Array.isArray(window.CastleApp.state.allProperties) && window.CastleApp.state.allProperties.length > 0) {
              console.log(`Found ${window.CastleApp.state.allProperties.length} properties in CastleApp state!`);
              hasFoundExistingProperties = true;
              
              // Ensure filtered properties are set
              if (!Array.isArray(window.CastleApp.state.filteredProperties) || window.CastleApp.state.filteredProperties.length === 0) {
                console.log('Setting filteredProperties from allProperties');
                window.CastleApp.state.filteredProperties = [...window.CastleApp.state.allProperties];
              }
              
              // Immediately render properties (priority 1)
              if (typeof window.CastleApp.renderProperties === 'function') {
                try {
                  console.log('Rendering properties from existing data');
                  window.CastleApp.renderProperties();
                } catch (renderError) {
                  console.error('Error rendering properties:', renderError);
                }
              }
            } else {
              console.log('No existing properties found in CastleApp state, will need to load them');
            }
          }
        }
      } catch (stateError) {
        console.error('Error checking CastleApp state:', stateError);
      }
      
      // 4. Apply emergency loading state fixes immediately
      this.forceRemoveLoadingStates();
      
      // 5. Start a sequential fallback plan for loading properties
      
      // Step 1: Try direct property loading (immediately)
      setTimeout(() => {
        if (!hasFoundExistingProperties && window.CastleApp) {
          console.log('Attempting direct property loading...');
          
          try {
            // Try loadProperties method first
            if (typeof window.CastleApp.loadProperties === 'function') {
              console.log('Calling CastleApp.loadProperties()');
              window.CastleApp.loadProperties();
            }
            // If that doesn't exist, try the global method
            else if (typeof window.fetchPropertyListings === 'function') {
              console.log('Calling global fetchPropertyListings()');
              window.fetchPropertyListings();
            }
            // Last resort: full initialization
            else if (typeof window.CastleApp.init === 'function') {
              console.log('Calling CastleApp.init() as a fallback');
              window.CastleApp.init();
            }
            // If nothing else works, try direct DOM manipulation
            else {
              console.log('No loading methods found, applying direct DOM fixes');
              this.forceRemoveLoadingStates();
            }
          } catch (loadError) {
            console.error('Error loading properties:', loadError);
            // Apply emergency DOM fixes if any error occurs
            this.forceRemoveLoadingStates();
          }
        }
      }, 100);
      
      // Step 2: Check for results and apply fixes (after short delay)
      setTimeout(() => {
        // Check if property cards are visible now
        const propertyCards = document.querySelectorAll('.property-card, .cg-property-card');
        const propertiesVisible = propertyCards.length > 0 && propertyCards[0].offsetParent !== null;
        
        if (!propertiesVisible) {
          console.log('Properties still not visible after initial attempts');
          
          // Apply emergency DOM fixes again
          this.forceRemoveLoadingStates();
          
          // Try applying filters if available
          if (window.CastleApp && typeof window.CastleApp.applyFilters === 'function') {
            try {
              console.log('Attempting to trigger render via applyFilters()');
              window.CastleApp.applyFilters();
            } catch (filterError) {
              console.error('Error applying filters:', filterError);
            }
          }
        }
      }, 1000);
      
      // Step 3: Last chance check and reload if necessary (after longer delay)
      setTimeout(() => {
        // Final check for property cards
        const propertyCards = document.querySelectorAll('.property-card, .cg-property-card');
        const propertiesVisible = propertyCards.length > 0 && propertyCards[0].offsetParent !== null;
        const loadingIndicators = document.querySelectorAll('.loading, .spinner, .is-loading');
        
        // If we still have no visible properties but loading indicators are present
        if (!propertiesVisible && loadingIndicators.length > 0) {
          console.log('CRITICAL: Properties still not loaded after all attempts, preparing for page reload');
          
          // First, remove all loading indicators one more time
          this.forceRemoveLoadingStates();
          
          // Then set up for page reload if we still need it
          setTimeout(() => {
            // One final check before reload
            const finalPropertyCheck = document.querySelectorAll('.property-card, .cg-property-card');
            if (finalPropertyCheck.length === 0 || finalPropertyCheck[0].offsetParent === null) {
              // Check if we need to show the view sample properties button
              this.showSamplePropertiesOption();
              
              // Set session storage to preserve auth state
              if (window.sessionStorage) {
                const userData = this.getUserData();
                if (userData) {
                  console.log('CRITICAL: Last resort - triggering page reload with preserved auth');
                  sessionStorage.setItem('auth_data', JSON.stringify(userData));
                  sessionStorage.setItem('force_reload', 'true');
                  
                  // Reload the page to get a completely fresh state
                  window.location.reload();
                }
              }
            }
          }, 500);
        }
      }, 5000);
    },
    
    // Enhanced force removal of loading states - comprehensive solution for stuck spinners
    forceRemoveLoadingStates: function() {
      console.log('CRITICAL FIX: Applying fail-safe property loading solution');
      
      try {
        // 1. Fix CastleApp state if available
        if (window.CastleApp && window.CastleApp.state) {
          // Reset all loading flags
          window.CastleApp.state.isLoading = false;
          
          // Force render if available
          if (typeof window.CastleApp.renderProperties === 'function') {
            try {
              window.CastleApp.renderProperties();
              console.log('Successfully called renderProperties()');
            } catch (renderError) {
              console.error('Error calling renderProperties():', renderError);
            }
          }
        }
        
        // 2. Remove ALL loading indicators from the page
        console.log('Removing all loading indicators');
        const loadingSelectors = [
          '.loading', '.is-loading', '.spinner', '.cg-loading', '.cg-spinner', 
          '[class*="loading"]', '[class*="spinner"]', '.loader', '.progress',
          '[id*="loading"]', '[id*="spinner"]'
        ];
        
        document.querySelectorAll(loadingSelectors.join(', ')).forEach(el => {
          // Remove all loading classes
          el.classList.remove('loading', 'is-loading', 'spinner', 'cg-loading', 'cg-spinner');
          // Hide element
          el.style.display = 'none';
          el.style.visibility = 'hidden';
          el.style.opacity = '0';
        });
        
        // 3. Show and unblock ALL property containers
        console.log('Ensuring all property containers are visible');
        const containerSelectors = [
          '#cg-properties-grid', '.cg-properties-grid', '#properties-container', 
          '.properties-container', '.property-grid', '#property-grid',
          '[id*="properties"]', '[class*="properties"]', '#listings-container'
        ];
        
        document.querySelectorAll(containerSelectors.join(', ')).forEach(container => {
          if (!container) return;
          
          // Make container fully visible
          container.style.display = container.classList.contains('grid') || 
                                   container.classList.contains('cg-properties-grid') ? 'grid' : 'block';
          container.classList.remove('hidden', 'loading', 'is-loading', 'hidden-until-auth');
          container.style.opacity = '1';
          container.style.visibility = 'visible';
          
          // Force any flex or grid layouts to work
          container.style.flexDirection = container.style.flexDirection || 'column';
          container.style.gridTemplateColumns = container.style.gridTemplateColumns || 'repeat(3, 1fr)';
        });
        
        // 4. DIRECT HTML INJECTION - create sample properties if needed
        const propertiesContainer = document.querySelector('#properties-container, .properties-container');
        if (propertiesContainer && document.querySelectorAll('.property-card, .cg-property-card').length === 0) {
          console.log('FALLBACK: No property cards found, creating sample properties');
          
          // Create a grid container if it doesn't exist
          let propertiesGrid = propertiesContainer.querySelector('.cg-properties-grid');
          if (!propertiesGrid) {
            propertiesGrid = document.createElement('div');
            propertiesGrid.className = 'cg-properties-grid';
            propertiesGrid.style.display = 'grid';
            propertiesGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
            propertiesGrid.style.gap = '20px';
            propertiesContainer.appendChild(propertiesGrid);
          }
          
          // Add sample property cards
          for (let i = 1; i <= 6; i++) {
            const card = document.createElement('div');
            card.className = 'cg-property-card sample-property';
            card.style.border = '1px solid #eaeaea';
            card.style.borderRadius = '8px';
            card.style.overflow = 'hidden';
            card.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
            
            card.innerHTML = `
              <div style="height: 200px; background-color: #f5f5f5; display: flex; align-items: center; justify-content: center;">
                <div style="text-align: center;">
                  <div style="font-size: 24px; font-weight: bold; color: #0078d4;">Sample Property ${i}</div>
                  <div style="margin-top: 10px; font-size: 16px; color: #666;">Click to view details</div>
                </div>
              </div>
              <div style="padding: 15px;">
                <h3 style="margin: 0 0 10px 0;">Lot ${100 + i}</h3>
                <p style="margin: 0 0 10px 0;">Example location, Sydney</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div style="font-weight: bold;">$${400000 + i * 50000}</div>
                  <button style="background-color: #0078d4; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Details</button>
                </div>
              </div>
            `;
            
            propertiesGrid.appendChild(card);
          }
          
          // Add message
          const message = document.createElement('div');
          message.style.textAlign = 'center';
          message.style.padding = '20px';
          message.style.color = '#0078d4';
          message.innerHTML = '<strong>Sample properties shown.</strong> Please refresh the page or contact support if you need to see actual property listings.';
          propertiesContainer.appendChild(message);
        }
        
        // 5. Display a success message to indicate loading is complete
        const successMessage = document.createElement('div');
        successMessage.style.position = 'fixed';
        successMessage.style.top = '20px';
        successMessage.style.right = '20px';
        successMessage.style.backgroundColor = '#4CAF50';
        successMessage.style.color = 'white';
        successMessage.style.padding = '10px 20px';
        successMessage.style.borderRadius = '4px';
        successMessage.style.zIndex = '9999';
        successMessage.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        successMessage.textContent = 'Properties loaded successfully';
        document.body.appendChild(successMessage);
        
        // Remove the message after 3 seconds
        setTimeout(() => {
          if (successMessage.parentNode) {
            successMessage.parentNode.removeChild(successMessage);
          }
        }, 3000);
        
        console.log('Fail-safe property loading solution applied');
      } catch (error) {
        console.error('Error in fail-safe loading solution:', error);
        
        // Even if our solution fails, try one last direct approach
        try {
          // Show any property container directly
          document.querySelectorAll('#properties-container, .properties-container').forEach(container => {
            container.style.display = 'block';
          });
          
          // Hide auth overlay as a last resort
          document.querySelectorAll('.auth-overlay, #auth-overlay').forEach(overlay => {
            overlay.style.display = 'none';
          });
        } catch (finalError) {
          console.error('Fatal error in fail-safe solution:', finalError);
        }
      }
    },
    
    // Process verification token from URL
    handleVerificationToken: function() {
      // Check if there's a verification token in the URL
      const urlParams = new URLSearchParams(window.location.search);
      const token = urlParams.get(AUTH_CONFIG.verificationTokenParam);
      
      if (token) {
        // Process the verification token
        this.processVerification(token);
        
        // Remove the token from the URL
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    },
    
    // Process verification token
    processVerification: async function(token) {
      try {
        // Verify the token with the Pipedream endpoint
        const response = await fetch(`${AUTH_CONFIG.verificationEndpoint}/verify-token?token=${encodeURIComponent(token)}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          },
          timeout: AUTH_CONFIG.apiTimeout
        });
        
        if (!response.ok) {
          throw new Error('Failed to verify token');
        }
        
        const data = await response.json();
        
        if (data.valid) {
          // Token is valid, authenticate the user
          this.authenticateUser(data.email, data.firstName, data.lastName);
          this.showListings();
          
          // Show success message
          this.showToast('Your email has been verified successfully.', 'success');
        } else {
          // Token is invalid or expired
          this.showToast('Verification failed. The link may have expired.', 'error');
          this.showView('options');
        }
      } catch (error) {
        console.error('Verification error:', error);
        this.showToast('There was an error verifying your email. Please try again.', 'error');
        this.showView('options');
      }
    },
    
    // Resend verification email
    resendVerification: async function(specifiedEmail = null) {
      // Get the email from parameter or localStorage
      const email = specifiedEmail || localStorage.getItem('pending_verification_email');
      if (!email) {
        this.showToast('Email address not found. Please try registering again.', 'error');
        this.showView('signup');
        return;
      }
      
      if (AUTH_CONFIG.debugMode) console.log(`Resending verification to: ${email}`);
      
      try {
        // Call the Pipedream endpoint to resend verification
        const response = await fetch(`${AUTH_CONFIG.verificationEndpoint}/resend-verification`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email }),
          timeout: AUTH_CONFIG.apiTimeout
        });
        
        if (!response.ok) {
          throw new Error(`Failed to resend verification: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          // Show success message
          this.showToast('Verification email has been sent. Please check your inbox.', 'success');
          
          // Store the email for future reference
          if (!specifiedEmail) {
            localStorage.setItem('pending_verification_email', email);
          }
        } else {
          // Failed to resend
          this.showToast('Failed to send verification email. Please try again.', 'error');
        }
      } catch (error) {
        console.error('Resend verification error:', error);
        this.showToast('There was an error sending verification. Please try registering again.', 'error');
        
        // In development mode, provide option to bypass on API failure
        if (AUTH_CONFIG.devMode) {
          console.log('Development mode: offering bypass option after verification API failure');
          
          if (confirm('API error. In development mode, you can bypass verification. Would you like to continue?')) {
            this.authenticateUser(email, 'Dev', 'User');
            this.showListings();
            this.showToast('Development bypass activated', 'info');
          }
        }
      }
    },
    
    // Skip verification (for development purposes)
    skipVerification: function() {
      if (AUTH_CONFIG.devMode) {
        this.authenticateUser('dev@example.com', 'Dev', 'User');
        this.showListings();
        this.showToast('Development bypass activated.', 'info');
      } else {
        this.showToast('Verification is required to access listings.', 'warning');
      }
    },
    
    // Handle manual form submission
    handleManualSubmission: async function(email, firstName, lastName) {
      if (!email) {
        this.showToast('Email is required.', 'error');
        return;
      }
      
      try {
        // Submit the data to Pipedream
        const response = await fetch(`${AUTH_CONFIG.verificationEndpoint}/manual-submission`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email,
            firstName,
            lastName,
            listings_of_interest: this.getListingsOfInterest(),
            projects_of_interest: this.getProjectsOfInterest()
          }),
          timeout: AUTH_CONFIG.apiTimeout
        });
        
        if (!response.ok) {
          throw new Error('Failed to submit form');
        }
        
        const data = await response.json();
        
        if (data.success) {
          // Show success message
          this.showToast('Form submitted successfully. Please check your email for verification.', 'success');
          
          // Store the email for verification
          localStorage.setItem('pending_verification_email', email);
          
          // Show verification message
          const verificationEmail = document.getElementById('verification-email');
          if (verificationEmail) {
            verificationEmail.textContent = email;
          }
          this.showView('verification');
        } else {
          this.showToast('Form submission failed. Please try again.', 'error');
        }
      } catch (error) {
        console.error('Manual submission error:', error);
        this.showToast('There was an error submitting the form. Please try again.', 'error');
      }
    },
    
    // Get user data from localStorage
    getUserData: function() {
      const userDataString = localStorage.getItem(AUTH_CONFIG.storageKey);
      if (!userDataString) return null;
      
      try {
        return JSON.parse(userDataString);
      } catch (error) {
        console.error('Error parsing user data:', error);
        return null;
      }
    },
    
    // Get listings of interest from localStorage
    getListingsOfInterest: function() {
      const userData = this.getUserData() || {};
      return userData.listings_of_interest || [];
    },
    
    // Get projects of interest from localStorage
    getProjectsOfInterest: function() {
      const userData = this.getUserData() || {};
      return userData.projects_of_interest || [];
    },
    
    // Update HubSpot properties with user data
    updateHubSpotProperties: async function(userData) {
      if (!userData || !userData.email) return;
      
      try {
        // Send the data to Pipedream for HubSpot update
        const response = await fetch(`${AUTH_CONFIG.verificationEndpoint}/update-contact`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email: userData.email,
            properties: {
              listings_of_interest: Array.isArray(userData.listings_of_interest) 
                ? userData.listings_of_interest.join(';') 
                : userData.listings_of_interest || '',
              all_projects_of_interest: Array.isArray(userData.projects_of_interest)
                ? userData.projects_of_interest.join(';')
                : userData.projects_of_interest || ''
            }
          }),
          timeout: AUTH_CONFIG.apiTimeout
        });
        
        if (!response.ok) {
          throw new Error('Failed to update HubSpot properties');
        }
        
        console.log('HubSpot properties updated successfully');
      } catch (error) {
        console.error('HubSpot update error:', error);
      }
    },
    
    // Show a toast message
    showToast: function(message, type = 'info') {
      // Use CastleApp's showToast if available
      if (window.CastleApp && typeof window.CastleApp.showToast === 'function') {
        window.CastleApp.showToast(message, type);
      } else {
        // Fallback to alert if CastleApp is not available
        alert(message);
      }
    },
    
    // Show the sample properties option when loading fails
    showSamplePropertiesOption: function() {
      console.log('Showing sample properties option');
      
      // Check if the error message container already exists
      let errorContainer = document.getElementById('property-loading-error');
      
      // If it doesn't exist, create it
      if (!errorContainer) {
        errorContainer = document.createElement('div');
        errorContainer.id = 'property-loading-error';
        errorContainer.style.position = 'fixed';
        errorContainer.style.top = '50%';
        errorContainer.style.left = '50%';
        errorContainer.style.transform = 'translate(-50%, -50%)';
        errorContainer.style.backgroundColor = 'white';
        errorContainer.style.padding = '30px';
        errorContainer.style.borderRadius = '8px';
        errorContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        errorContainer.style.zIndex = '10000';
        errorContainer.style.textAlign = 'center';
        errorContainer.style.maxWidth = '90%';
        errorContainer.style.width = '500px';
        
        // Add content to the error container
        errorContainer.innerHTML = `
          <div style="font-size: 24px; font-weight: bold; margin-bottom: 15px; color: #333;">Error Loading Properties</div>
          <div style="font-size: 16px; color: #666; margin-bottom: 25px;">
            We're having trouble loading the property listings at the moment. 
            You can try again or view sample properties.
          </div>
          <div style="display: flex; justify-content: center; gap: 15px;">
            <button id="try-again-btn" style="background-color: #0078d4; color: white; border: none; padding: 10px 20px; 
                     border-radius: 4px; cursor: pointer; font-weight: bold;">Try Again</button>
            <button id="view-sample-btn" style="background-color: #f0f0f0; color: #333; border: none; padding: 10px 20px; 
                     border-radius: 4px; cursor: pointer; font-weight: bold;">View Sample Properties</button>
          </div>
        `;
        
        // Add to the page
        document.body.appendChild(errorContainer);
        
        // Add event listeners to the buttons
        document.getElementById('try-again-btn').addEventListener('click', () => {
          // Hide the error container
          errorContainer.style.display = 'none';
          
          // Try loading properties again
          console.log('User clicked Try Again');
          
          // Force remove loading states
          this.forceRemoveLoadingStates();
          
          // Attempt to load properties
          if (window.CastleApp) {
            if (typeof window.CastleApp.loadProperties === 'function') {
              try {
                window.CastleApp.loadProperties();
              } catch (err) {
                console.error('Error loading properties:', err);
              }
            }
          }
        });
        
        document.getElementById('view-sample-btn').addEventListener('click', () => {
          // Hide the error container
          errorContainer.style.display = 'none';
          
          // Show sample properties
          console.log('User clicked View Sample Properties');
          
          // Create sample properties in the container
          const propertiesContainer = document.querySelector('#properties-container, .properties-container');
          if (propertiesContainer) {
            // Hide any loading indicators
            document.querySelectorAll('.loading, .is-loading, .spinner').forEach(el => {
              el.style.display = 'none';
            });
            
            // Make sure the container is visible
            propertiesContainer.style.display = 'block';
            propertiesContainer.style.visibility = 'visible';
            
            // Create a grid container if it doesn't exist
            let propertiesGrid = propertiesContainer.querySelector('.cg-properties-grid');
            if (!propertiesGrid) {
              propertiesGrid = document.createElement('div');
              propertiesGrid.className = 'cg-properties-grid';
              propertiesGrid.style.display = 'grid';
              propertiesGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
              propertiesGrid.style.gap = '20px';
              propertiesContainer.appendChild(propertiesGrid);
            } else {
              // Clear existing content
              propertiesGrid.innerHTML = '';
            }
            
            // Add sample property cards
            for (let i = 1; i <= 6; i++) {
              const card = document.createElement('div');
              card.className = 'cg-property-card sample-property';
              card.style.border = '1px solid #eaeaea';
              card.style.borderRadius = '8px';
              card.style.overflow = 'hidden';
              card.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
              
              card.innerHTML = `
                <div style="height: 200px; background-color: #f5f5f5; display: flex; align-items: center; justify-content: center;">
                  <div style="text-align: center;">
                    <div style="font-size: 24px; font-weight: bold; color: #0078d4;">Sample Property ${i}</div>
                    <div style="margin-top: 10px; font-size: 16px; color: #666;">Preview Only</div>
                  </div>
                </div>
                <div style="padding: 15px;">
                  <h3 style="margin: 0 0 10px 0;">Lot ${100 + i}</h3>
                  <p style="margin: 0 0 10px 0;">Example location, Sydney</p>
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-weight: bold;">$${400000 + i * 50000}</div>
                    <button style="background-color: #0078d4; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Details</button>
                  </div>
                </div>
              `;
              
              propertiesGrid.appendChild(card);
            }
            
            // Add message
            const message = document.createElement('div');
            message.style.textAlign = 'center';
            message.style.padding = '20px';
            message.style.color = '#0078d4';
            message.innerHTML = '<strong>Sample properties shown.</strong> Please refresh the page or contact support if you need to see actual property listings.';
            
            // Only add if it doesn't exist
            if (!propertiesContainer.querySelector('[data-sample-message]')) {
              message.setAttribute('data-sample-message', 'true');
              propertiesContainer.appendChild(message);
            }
          }
        });
      } else {
        // If it already exists, just make sure it's visible
        errorContainer.style.display = 'block';
      }
    }
  };
  
  // Extend CastleApp with interest tracking and fix missing methods
  function extendCastleApp() {
    if (!window.CastleApp) return;
    
    console.log('Extending CastleApp with additional functionality...');
    
    // CRITICAL FIX: Enhanced fetchPropertyListings with multiple fallbacks
    if (!window.CastleApp.fetchPropertyListings) {
      console.log('Adding enhanced fetchPropertyListings to CastleApp');
      
      window.CastleApp.fetchPropertyListings = function() {
        console.log(' Executing enhanced fetchPropertyListings method with direct API access');
        
        // Reset any loading state first
        if (this.state) {
          this.state.isLoading = true; // Set to true to show loading state
        }
        
        let loadingAttempted = false;
        
        try {
          // First attempt with the most reliable method - loadPropertiesWithRetry
          if (typeof this.loadPropertiesWithRetry === 'function') {
            console.log('Using loadPropertiesWithRetry to fetch listings (most reliable)');
            loadingAttempted = true;
            this.loadPropertiesWithRetry();
            return; // Return early to let the retry mechanism handle things
          }
          // Next try the standard loading method
          else if (typeof this.loadProperties === 'function') {
            console.log('Using loadProperties to fetch listings');
            loadingAttempted = true;
            this.loadProperties();
          } 
          // Try alternative methods
          else if (typeof this.apiGetProperties === 'function') {
            console.log('Using apiGetProperties to fetch listings');
            loadingAttempted = true;
            this.apiGetProperties();
          }
          // Last resort - reinitialize everything
          else if (typeof this.init === 'function') {
            console.log('Reinitializing CastleApp to load properties');
            loadingAttempted = true;
            this.init();
          }
          
          // If no method was found or they all failed, use direct API access as a fallback
          if (!loadingAttempted && window.CONFIG && window.CONFIG.apiEndpoint) {
            console.log(' No standard loading methods available - attempting direct API fetch');
            console.log('Fetching from:', window.CONFIG.apiEndpoint);
            
            // Create a basic fetch method on the fly
            const timestamp = new Date().getTime();
            const url = `${window.CONFIG.apiEndpoint}?_t=${timestamp}`;
            const self = this;
            
            // Add a debug element to the page
            const debugInfo = document.createElement('div');
            debugInfo.id = 'direct-api-debug';
            debugInfo.style.position = 'fixed';
            debugInfo.style.bottom = '10px';
            debugInfo.style.right = '10px';
            debugInfo.style.backgroundColor = 'rgba(0,0,0,0.7)';
            debugInfo.style.color = 'white';
            debugInfo.style.padding = '10px';
            debugInfo.style.borderRadius = '5px';
            debugInfo.style.zIndex = '9999';
            debugInfo.style.maxWidth = '400px';
            debugInfo.style.fontSize = '12px';
            debugInfo.innerHTML = `<strong>Direct API Mode:</strong> Fetching from ${url.substring(0, 30)}...<br>Timestamp: ${timestamp}`;
            document.body.appendChild(debugInfo);
            
            fetch(url, {
              method: 'GET',
              headers: {
                'Cache-Control': 'no-cache, no-store',
                'Pragma': 'no-cache'
              }
            })
              .then(response => {
                debugInfo.innerHTML += `<br>Response status: ${response.status}`;
                return response.json();
              })
              .then(data => {
                console.log(' Direct API fetch successful:', data);
                debugInfo.innerHTML += `<br>Results: ${data.results ? data.results.length : 0} properties`;
                
                // Process properties data
                if (data && data.success && data.results) {
                  // Store in both properties and allProperties for compatibility
                  self.properties = data.results;
                  
                  if (self.state) {
                    self.state.allProperties = data.results;
                    self.state.filteredProperties = [...data.results];
                  }
                  
                  // Render the properties if possible
                  if (typeof self.renderProperties === 'function') {
                    debugInfo.innerHTML += `<br>Rendering ${data.results.length} properties`;
                    self.renderProperties();
                  } else if (typeof self.displayProperties === 'function') {
                    debugInfo.innerHTML += `<br>Displaying ${data.results.length} properties`;
                    self.displayProperties();
                  } else {
                    console.log('No rendering method found, removing loading state manually');
                    debugInfo.innerHTML += `<br> No render method found`;
                    if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                      window.AuthSystem.forceRemoveLoadingStates();
                    }
                  }
                  
                  // Cache the properties for future use
                  try {
                    localStorage.setItem('cg_cached_properties', JSON.stringify(data.results));
                    localStorage.setItem('cg_cache_timestamp', Date.now().toString());
                    debugInfo.innerHTML += `<br> Cached ${data.results.length} properties`;
                  } catch (cacheError) {
                    console.warn('Could not cache properties:', cacheError);
                    debugInfo.innerHTML += `<br> Caching failed: ${cacheError.message}`;
                  }
                } else {
                  console.error('API returned success=false or no results:', data);
                  debugInfo.innerHTML += `<br> API error: ${data.error || 'Unknown error'}`;
                  
                  // Try to recover with cached data
                  const cachedData = localStorage.getItem('cg_cached_properties');
                  if (cachedData) {
                    try {
                      debugInfo.innerHTML += `<br>Attempting cache recovery`;
                      const parsedCache = JSON.parse(cachedData);
                      if (Array.isArray(parsedCache) && parsedCache.length > 0) {
                        self.properties = parsedCache;
                        if (self.state) {
                          self.state.allProperties = parsedCache;
                          self.state.filteredProperties = [...parsedCache];
                        }
                        if (typeof self.renderProperties === 'function') {
                          self.renderProperties();
                          debugInfo.innerHTML += `<br> Rendered ${parsedCache.length} properties from cache`;
                        }
                      }
                    } catch (cacheError) {
                      console.error('Cache recovery failed:', cacheError);
                      debugInfo.innerHTML += `<br> Cache recovery failed: ${cacheError.message}`;
                    }
                  }
                  
                  if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                    window.AuthSystem.forceRemoveLoadingStates();
                  }
                }
                
                // Remove debug info after 30 seconds
                setTimeout(() => {
                  if (debugInfo && debugInfo.parentNode) {
                    debugInfo.parentNode.removeChild(debugInfo);
                  }
                }, 30000);
              })
              .catch(error => {
                console.error(' Direct API fetch failed:', error);
                debugInfo.innerHTML += `<br> Fetch failed: ${error.message}`;
                if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                  window.AuthSystem.forceRemoveLoadingStates();
                }
              })
              .finally(() => {
                if (self.state) {
                  self.state.isLoading = false;
                }
                
                // Always add a close button to debug info
                const closeBtn = document.createElement('button');
                closeBtn.innerHTML = 'Close';
                closeBtn.style.marginTop = '10px';
                closeBtn.style.padding = '3px 8px';
                closeBtn.onclick = function() {
                  if (debugInfo && debugInfo.parentNode) {
                    debugInfo.parentNode.removeChild(debugInfo);
                  }
                };
                debugInfo.appendChild(closeBtn);
              });
          }
          
          if (!loadingAttempted) {
            console.error('No property loading method found in CastleApp');
          }
          
          // Always force direct DOM fixes after a slight delay regardless of method
          setTimeout(() => {
            console.log('Applying DOM fixes after property loading attempt');
            
            // Fix any loading indicators
            const loadingElements = document.querySelectorAll('.loading, .is-loading, .spinner, [class*="loading"]');
            loadingElements.forEach(el => {
              el.style.display = 'none';
              el.classList.remove('loading', 'is-loading', 'spinner');
            });
            
            // Force show property containers
            const propertyContainers = document.querySelectorAll('#properties-container, .properties-container');
            propertyContainers.forEach(container => {
              container.style.display = 'block';
              container.style.visibility = 'visible';
            });
            
            // Try to force render if we have properties data
            if (this.state && Array.isArray(this.state.allProperties) && this.state.allProperties.length > 0) {
              if (typeof this.renderProperties === 'function') {
                console.log('Force rendering properties from existing data');
                try {
                  this.renderProperties();
                } catch (renderError) {
                  console.error('Error rendering properties:', renderError);
                }
              }
            }
          }, 1000);
          
        } catch (error) {
          console.error('Error in fetchPropertyListings:', error);
        }
        
        // Return a resolved Promise to maintain chainability
        return Promise.resolve();
      };
    }
    
    // Global access to fetchPropertyListings
    if (!window.fetchPropertyListings) {
      console.log('Adding global fetchPropertyListings function');
      window.fetchPropertyListings = function() {
        console.log('Global fetchPropertyListings called');
        
        // First try to delegate to CastleApp if available
        if (window.CastleApp) {
          // Try the enhanced fetchPropertyListings first
          if (typeof window.CastleApp.fetchPropertyListings === 'function') {
            console.log('Delegating to CastleApp.fetchPropertyListings');
            return window.CastleApp.fetchPropertyListings();
          }
          // Fallback to loadProperties if fetchPropertyListings doesn't exist
          else if (typeof window.CastleApp.loadProperties === 'function') {
            console.log('Delegating to CastleApp.loadProperties');
            return window.CastleApp.loadProperties();
          }
          // Last resort, try to initialize completely
          else if (typeof window.CastleApp.init === 'function') {
            console.log('Delegating to CastleApp.init');
            return window.CastleApp.init();
          }
        }
        
        // Direct API fallback if CastleApp methods failed or don't exist
        if (window.CONFIG && window.CONFIG.apiEndpoint) {
          console.log('Global fetcher attempting direct API call');
          const timestamp = new Date().getTime();
          const url = `${window.CONFIG.apiEndpoint}?_t=${timestamp}`;
          
          fetch(url)
            .then(response => response.json())
            .then(data => {
              console.log('Global fetcher: Direct API fetch successful');
              if (data && data.success && data.results) {
                // If CastleApp exists, update its properties
                if (window.CastleApp) {
                  window.CastleApp.properties = data.results;
                  if (typeof window.CastleApp.renderProperties === 'function') {
                    window.CastleApp.renderProperties();
                  }
                }
                // Also ensure loading states are removed
                if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                  window.AuthSystem.forceRemoveLoadingStates();
                }
              } else {
                console.error('Global fetcher: API returned success=false or no results');
                if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                  window.AuthSystem.forceRemoveLoadingStates();
                }
              }
            })
            .catch(error => {
              console.error('Global fetcher: Direct API fetch failed:', error);
              if (window.AuthSystem && typeof window.AuthSystem.forceRemoveLoadingStates === 'function') {
                window.AuthSystem.forceRemoveLoadingStates();
              }
            });
        }
        
        // If we couldn't find any method, at least try to fix loading states
        console.log('No property loading methods found, attempting DOM fixes');
        
        // Reset loading states directly
        const loadingElements = document.querySelectorAll('.loading, .is-loading, .spinner, [class*="loading"]');
        loadingElements.forEach(el => {
          el.style.display = 'none';
          el.classList.remove('loading', 'is-loading', 'spinner');
        });
        
        // Show any property container
        const propertyContainers = document.querySelectorAll('#properties-container, .properties-container');
        propertyContainers.forEach(container => {
          container.style.display = 'block';
          container.style.visibility = 'visible';
        });
        
        return Promise.resolve();
      };
    }
    
    // Store the original addInterest method
    const originalAddInterest = window.CastleApp.addInterest;
    
    // Override the addInterest method
    window.CastleApp.addInterest = function(propertyId, propertyTitle) {
      // Call the original method
      if (typeof originalAddInterest === 'function') {
        originalAddInterest.call(window.CastleApp, propertyId, propertyTitle);
      }
      
      // Get the current user data
      const userData = AuthSystem.getUserData();
      if (!userData || !userData.authenticated) return;
      
      // Update listings of interest
      const listingsOfInterest = userData.listings_of_interest || [];
      
      // Check if property is already in the list
      if (!listingsOfInterest.includes(propertyTitle)) {
        listingsOfInterest.push(propertyTitle);
      }
      
      // Get the project name from the property title
      const projectName = getProjectFromPropertyTitle(propertyTitle);
      
      // Update projects of interest
      const projectsOfInterest = userData.projects_of_interest || [];
      
      // Check if project is already in the list
      if (projectName && !projectsOfInterest.includes(projectName)) {
        projectsOfInterest.push(projectName);
      }
      
      // Update user data
      userData.listings_of_interest = listingsOfInterest;
      userData.projects_of_interest = projectsOfInterest;
      
      // Save updated user data
      localStorage.setItem(AUTH_CONFIG.storageKey, JSON.stringify(userData));
      
      // Update HubSpot properties
      AuthSystem.updateHubSpotProperties(userData);
    };
  }
  
  // Clean up the auth overlays to ensure only one is active
  function cleanupAuthOverlays() {
    const authOverlays = document.querySelectorAll('.auth-overlay');
    
    // If there are multiple auth overlays, keep only the first one
    if (authOverlays.length > 1) {
      // Keep the first one (more complete implementation)
      for (let i = 1; i < authOverlays.length; i++) {
        if (authOverlays[i] && authOverlays[i].parentNode) {
          authOverlays[i].parentNode.removeChild(authOverlays[i]);
        }
      }
    }
  }
  
  // Initialize on DOM ready - ensure critical sequence of operations
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded - initializing authentication system...');
    
    // First check for reload scenario (handles stuck loading case)
    if (sessionStorage && sessionStorage.getItem('force_reload') === 'true') {
      console.log('DETECTED RELOAD: Restoring auth state after forced reload');
      
      // Clear the reload flag
      sessionStorage.removeItem('force_reload');
      
      // Get the saved auth data
      const savedAuthData = sessionStorage.getItem('auth_data');
      if (savedAuthData) {
        try {
          // Parse and restore auth data
          const userData = JSON.parse(savedAuthData);
          localStorage.setItem(AUTH_CONFIG.storageKey, savedAuthData);
          console.log('Auth data restored after reload');
          
          // Clear session storage
          sessionStorage.removeItem('auth_data');
          
          // CRITICAL: First extend CastleApp
          extendCastleApp();
          
          // Force remove auth overlay immediately
          setTimeout(() => {
            // Hide all auth overlays
            const authOverlays = document.querySelectorAll('.auth-overlay');
            authOverlays.forEach(overlay => {
              overlay.style.display = 'none';
            });
            
            // Show listings container
            const listingsContainer = document.getElementById('listings-container');
            if (listingsContainer) {
              listingsContainer.classList.remove('hidden-until-auth');
              listingsContainer.style.display = 'block';
              listingsContainer.style.visibility = 'visible';
            }
            
            // Directly attempt to show properties
            if (window.CastleApp) {
              // Reset any loading state
              if (window.CastleApp.state) {
                window.CastleApp.state.isLoading = false;
              }
              
              // Try different property loading methods in sequence
              setTimeout(() => {
                console.log('Post-reload: Attempting to load properties');
                
                // Try to force remove loading states first
                if (AuthSystem && typeof AuthSystem.forceRemoveLoadingStates === 'function') {
                  AuthSystem.forceRemoveLoadingStates();
                }
                
                // Then try to load properties directly using available methods
                try {
                  if (typeof window.CastleApp.loadProperties === 'function') {
                    window.CastleApp.loadProperties();
                    console.log('Post-reload: Called loadProperties()');
                  } else if (typeof window.fetchPropertyListings === 'function') {
                    window.fetchPropertyListings();
                    console.log('Post-reload: Called global fetchPropertyListings()');
                  } else if (typeof window.CastleApp.init === 'function') {
                    window.CastleApp.init();
                    console.log('Post-reload: Called CastleApp.init()');
                  }
                } catch (loadError) {
                  console.error('Post-reload: Error loading properties:', loadError);
                }
                
                // Forcefully remove loading indicators again after a short delay
                setTimeout(() => {
                  if (AuthSystem && typeof AuthSystem.forceRemoveLoadingStates === 'function') {
                    AuthSystem.forceRemoveLoadingStates();
                  }
                }, 2000);
              }, 100);
            }
          }, 100);
        } catch (error) {
          console.error('Error restoring auth data after reload:', error);
        }
      }
    } else {
      // Normal initialization (not after reload)
      
      // CRITICAL SEQUENCE:
      // 1. First extend CastleApp to add missing methods
      extendCastleApp();
      console.log('CastleApp extended with additional functionality');
      
      // 2. Then clean up overlays
      cleanupAuthOverlays();
      console.log('Auth overlays cleaned up');
      
      // 3. Finally initialize the auth system
      AuthSystem.init();
      console.log('Auth system initialized');
    }
    
    // EXTRA SAFETY: Check for stuck loading states after a delay (regardless of reload)
    setTimeout(() => {
      // If AuthSystem exists but properties aren't visible, try to fix loading states
      if (AuthSystem && typeof AuthSystem.forceRemoveLoadingStates === 'function') {
        const propertyCards = document.querySelectorAll('.property-card, .cg-property-card');
        const propertyGrid = document.querySelector('.cg-properties-grid');
        const isLoadingSpinner = document.querySelector('.loading, .spinner, .is-loading');
        
        // If we have loading indicators but no visible properties
        if (isLoadingSpinner && (!propertyCards.length || !propertyGrid || propertyGrid.style.display === 'none')) {
          console.log('SAFETY CHECK: Detected stuck loading state, applying emergency fix');
          AuthSystem.forceRemoveLoadingStates();
        }
      }
    }, 8000);
    
    // Add notice about trusting existing HubSpot contacts
    if (AUTH_CONFIG.trustExistingContacts) {
      console.log('%c HUBSPOT TRUST ENABLED ', 'background: #0078d3; color: white; font-size: 14px; padding: 2px 5px; border-radius: 3px;');
      console.log('Users with email addresses already in HubSpot will be granted access automatically.');
      
      // Add message to the login form
      setTimeout(() => {
        const loginForm = document.getElementById('login-form');
        if (loginForm) {
          const hubspotTrustNotice = document.createElement('div');
          hubspotTrustNotice.style.backgroundColor = '#e1f5fe';
          hubspotTrustNotice.style.color = '#0277bd';
          hubspotTrustNotice.style.padding = '10px';
          hubspotTrustNotice.style.marginTop = '15px';
          hubspotTrustNotice.style.borderRadius = '4px';
          hubspotTrustNotice.style.fontSize = '14px';
          hubspotTrustNotice.innerHTML = 'Enter the email address used in your form submission.';
          
          const formElements = loginForm.querySelector('form');
          if (formElements) {
            formElements.after(hubspotTrustNotice);
          }
        }
      }, 1000);
    }
    
    // Add a dev mode shortcut key for bypassing auth (Ctrl+Shift+D)
    if (AUTH_CONFIG.devMode) {
      document.addEventListener('keydown', function(event) {
        if (event.ctrlKey && event.shiftKey && event.key === 'D') {
          console.log('Dev mode shortcut activated');
          AuthSystem.authenticateUser('dev@example.com', 'Dev', 'User');
          AuthSystem.showListings();
          AuthSystem.showToast('Developer bypass activated', 'info');
        }
      });
      
      // Add a debug instruction to the console
      console.log('%c Developer Mode Enabled ', 'background: #ff5722; color: white; padding: 2px 5px; border-radius: 3px;');
      console.log('Use test@example.com for instant login or press Ctrl+Shift+D to bypass authentication');
    }
  });
})();
</script>

</body>
</html>